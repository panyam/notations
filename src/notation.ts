import * as TSU from "@panyam/tsutils";
import { Entity } from "./entity";
import { Cycle } from "./cycle";
import { Line } from "./core";
import { LayoutParams } from "./layouts";
import {
  RoleDef,
  RawBlock,
  BlockItem,
  Block,
  SectionBlock,
  RepeatBlock,
  CycleBlock,
  BeatDurationBlock,
  BreaksBlock,
  RoleBlock,
  GroupBlock,
  isBlock,
  isLine,
  isRawBlock,
  findContainingBlock,
} from "./block";

// Re-export for backward compatibility
export {
  RoleDef,
  RawBlock,
  BlockItem,
  Block,
  SectionBlock,
  RepeatBlock,
  CycleBlock,
  BeatDurationBlock,
  BreaksBlock,
  RoleBlock,
  GroupBlock,
  isBlock,
  isLine,
  isRawBlock,
  findContainingBlock,
};

/**
 * Type representing a command parameter with optional key and value.
 */
export type CmdParam = { key: TSU.Nullable<string>; value: any };

/**
 * Base class for commands in the notation.
 * Commands modify the notation in various ways, such as adding content,
 * changing layout, setting roles, etc.
 */
export abstract class Command extends Entity {
  /** Whether this command was auto-generated */
  autoGenerated = false;

  /** Previous command in the sequence */
  prevSibling: null | Command = null;

  /** Next command in the sequence */
  nextSibling: null | Command = null;

  /** Parameters for this command */
  params: CmdParam[];

  /** Index of this command in the sequence */
  index: number;

  /**
   * Creates a new Command.
   * @param params Optional parameters for the command
   */
  constructor(params: CmdParam[] = []) {
    super();
    this.params = params;
    this.index = 0;
    this.validateParams();
  }

  /**
   * Validates the parameters for this command.
   * @throws Error if parameters are invalid
   */
  validateParams(): void {
    //
  }

  /**
   * Gets the name of this command.
   */
  get name(): string {
    return this.constructor.name;
  }

  /**
   * Returns a debug-friendly representation of this command.
   * @returns An object containing debug information
   */
  debugValue(): any {
    return { name: this.name, index: this.index, params: this.params };
  }

  /**
   * Gets a parameter value by name.
   * @param name The name of the parameter
   * @returns The parameter value, or null if not found
   */
  getParam(name: string): any {
    for (const param of this.params) {
      if (param.key == name) return param.value;
    }
    return null;
  }

  /**
   * Gets a parameter value by index.
   * @param index The index of the parameter
   * @returns The parameter value, or null if not found
   */
  getParamAt(index: number): any {
    return index < this.params.length ? this.params[index].value : null;
  }

  /**
   * Applies this command to a notation.
   * @param notation The notation to apply this command to
   */
  abstract applyToNotation(notebook: Notation): void;

  /**
   * Applies this command to a block.
   * By default, delegates to applyToNotation for backward compatibility.
   * Subclasses can override for block-specific behavior.
   * @param container The block to apply this command to
   */
  applyToBlock(container: Block): void {
    if (container instanceof Notation) {
      this.applyToNotation(container);
    }
    // For non-Notation containers, subclasses should implement specific behavior
  }
}

/**
 * Represents metadata for the notation.
 */
export class MetaData {
  /**
   * Creates a new MetaData.
   * @param key The key for this metadata
   * @param value The value of this metadata
   * @param params Optional additional parameters
   */
  constructor(
    public readonly key: string,
    public readonly value: string,
    public readonly params?: any,
  ) {
    params = params || {};
  }
}

/**
 * The main class representing a complete notation.
 * Notation is the root Block of the notation hierarchy.
 * It contains all the elements, settings, and layout information for a piece of music.
 *
 * TODO: Make Notation extend Block for full unification.
 * For now, it duplicates Block's interface to maintain compatibility.
 */
export class Notation extends Entity {
  readonly TYPE = "Notation";
  private _unnamedLayoutParams: LayoutParams[] = [];
  private _namedLayoutParams = new Map<string, LayoutParams>();
  private _currRoleDef: TSU.Nullable<RoleDef> = null;

  // ============================================
  // Block-like properties (TODO: extend Block)
  // ============================================

  /** Child items (blocks, lines, raw blocks) */
  readonly blockItems: BlockItem[] = [];

  /** Local cycle (same as currentCycle for backward compatibility) */
  localCycle: TSU.Nullable<Cycle> = Cycle.DEFAULT;

  /** Local atoms per beat (same as currentAPB for backward compatibility) */
  localAtomsPerBeat: TSU.Nullable<number> = 1;

  /** Local line breaks (same as currentBreaks for backward compatibility) */
  localBreaks: TSU.Nullable<number[]> = [];

  /** Roles defined locally in this notation */
  readonly localRoles = new Map<string, RoleDef>();

  /**
   * Notation is always the root, so parentBlock is always null.
   */
  get parentBlock(): TSU.Nullable<Block> {
    return null;
  }

  /**
   * Gets the effective cycle. Since Notation is root, returns localCycle.
   */
  get cycle(): TSU.Nullable<Cycle> {
    return this.localCycle;
  }

  /**
   * Gets the effective atoms per beat. Since Notation is root, returns localAtomsPerBeat.
   */
  get atomsPerBeat(): number {
    return this.localAtomsPerBeat ?? 1;
  }

  /**
   * Gets the effective line breaks. Since Notation is root, returns localBreaks.
   */
  get breaks(): number[] {
    return this.localBreaks ?? [];
  }

  /**
   * Gets a role by name from localRoles.
   * @param name The role name to look up
   */
  getRole(name: string): TSU.Nullable<RoleDef> {
    return this.localRoles.get(name.toLowerCase()) ?? null;
  }

  // ============================================
  // Backward compatibility aliases
  // ============================================

  /**
   * @deprecated Use blockItems instead
   * Legacy accessor for blocks array.
   */
  get blocks(): BlockItem[] {
    return this.blockItems;
  }

  /**
   * @deprecated Use localAtomsPerBeat instead
   * Legacy accessor for current atoms per beat.
   */
  get currentAPB(): number {
    return this.localAtomsPerBeat ?? 1;
  }

  set currentAPB(value: number) {
    this.localAtomsPerBeat = value;
  }

  /**
   * @deprecated Use localCycle instead
   * Legacy accessor for current cycle.
   */
  get currentCycle(): Cycle {
    return this.localCycle ?? Cycle.DEFAULT;
  }

  set currentCycle(value: Cycle) {
    this.localCycle = value;
  }

  /**
   * @deprecated Use localBreaks instead
   * Legacy accessor for current breaks.
   */
  get currentBreaks(): number[] {
    return this.localBreaks ?? [];
  }

  set currentBreaks(value: number[]) {
    this.localBreaks = value;
  }

  /**
   * @deprecated Use localRoles instead
   * Legacy accessor for roles array.
   */
  get roles(): RoleDef[] {
    return Array.from(this.localRoles.values());
  }

  // ============================================
  // Other properties
  // ============================================

  /** Metadata associated with this notation */
  metadata = new Map<string, MetaData>();

  /** Handler for missing roles */
  onMissingRole: (name: string) => RoleDef | null = (name) => this.newRoleDef(name, name == "sw");

  /**
   * Gets the unnamed layout parameters.
   */
  get unnamedLayoutParams(): ReadonlyArray<LayoutParams> {
    return this._unnamedLayoutParams;
  }

  /**
   * Gets the named layout parameters.
   */
  get namedLayoutParams(): ReadonlyMap<string, LayoutParams> {
    return this._namedLayoutParams;
  }

  /**
   * Adds a child item to this notation (BlockContainer implementation).
   * @param item The item to add (Block, Line, or RawBlock)
   */
  addBlockItem(item: BlockItem): void {
    item.setParent(this as unknown as Entity);
    this.blockItems.push(item);
  }

  /**
   * Adds a line to this notation.
   * @param line The line to add
   */
  addLine(line: Line): void {
    this.addBlockItem(line);
  }

  /**
   * Removes a line from this notation.
   * @param line The line to remove
   * @returns The index of the removed line, or -1 if not found
   */
  removeLine(line: Line): number {
    const index = this.blockItems.findIndex((l) => l === line);
    if (index >= 0) {
      this.blockItems.splice(index, 1);
      line.setParent(null);
    }
    return index;
  }

  /**
   * Adds a raw block to this notation.
   * @param raw The raw block to add
   */
  addRawBlock(raw: RawBlock): void {
    this.addBlockItem(raw);
    this.resetLine();
  }

  /**
   * Adds metadata to this notation.
   * @param meta The metadata to add
   * @param addBlock Whether to add a corresponding raw block, defaults to true
   */
  addMetaData(meta: MetaData, addBlock = true): void {
    if (addBlock && !this.metadata.has(meta.key)) {
      // Add a new raw block here
      // set this by key so even if metadata changes we can
      // get latest value of it
      const raw = new RawBlock(meta.key, "metadata");
      this.addRawBlock(raw);
    }
    this.metadata.set(meta.key, meta);
  }

  /**
   * Returns a debug-friendly representation of this notation.
   * @returns An object containing debug information
   */
  debugValue(): any {
    return {
      ...super.debugValue,
      roles: this.roles,
      blocks: this.blocks.map((b) => b.debugValue()),
      currentAPB: this.currentAPB,
      currentCycle: this.currentCycle?.uuid,
      currentBreaks: this.currentBreaks,
    };
  }

  /**
   * Gets a role definition by name.
   * @param name The name of the role
   * @returns The role definition, or null if not found
   */
  getRoleDef(name: string): TSU.Nullable<RoleDef> {
    name = name.trim().toLowerCase();
    if (name === "") {
      // Return the last added role if name is empty
      const roles = Array.from(this.localRoles.values());
      return roles[roles.length - 1] || null;
    }
    return this.localRoles.get(name) ?? null;
  }

  /**
   * Creates a new role definition.
   * @param name The name of the role
   * @param notesOnly Whether the role contains only notes, defaults to false
   * @returns The created role definition
   * @throws Error if the name is empty or the role already exists
   */
  newRoleDef(name: string, notesOnly = false): RoleDef {
    name = name.trim().toLowerCase();
    if (name === "") {
      throw new Error("Role name cannot be empty");
    }
    if (this.localRoles.has(name)) {
      throw new Error("Role already exists: " + name);
    }
    // create new and add
    const rd = new RoleDef();
    rd.name = name;
    rd.notesOnly = notesOnly;
    rd.index = this.localRoles.size;
    this.localRoles.set(name, rd);

    return rd;
  }

  /**
   * Gets the current role definition.
   */
  get currRoleDef(): RoleDef | null {
    if (this._currRoleDef == null) {
      const roles = Array.from(this.localRoles.values());
      if (roles.length === 0) {
        return null;
      } else {
        this._currRoleDef = roles[roles.length - 1];
      }
    }
    return this._currRoleDef;
  }

  /**
   * Sets the current role by name.
   * @param name The name of the role to set as current
   * @throws Error if the name is empty or the role is not found
   */
  setCurrRole(name: string): void {
    name = name.trim().toLowerCase();
    if (name.trim() == "") {
      throw new Error("Role name cannot be empty");
    }
    const roleDef = this.getRoleDef(name) || (this.onMissingRole ? this.onMissingRole(name) || null : null);
    if (roleDef == null) {
      throw new Error("Role not found: " + name);
    }
    this._currRoleDef = roleDef;
  }

  // Gets the current line, creating it if needed
  private _currentLine: Line | null = null;

  /**
   * Gets the current line, creating it if needed.
   */
  get currentLine(): Line {
    if (this._currentLine == null) {
      return this.newLine();
    }
    return this._currentLine;
  }

  /**
   * Resets the current line pointer to null.
   */
  resetLine(): void {
    this._currentLine = null;
  }

  /**
   * Creates a new line and makes it the current line.
   * @returns The newly created line
   */
  newLine(): Line {
    if (this._currentLine && this._currentLine.isEmpty) {
      // then remove it first instead of adding another
      // so we dont have a string of empty lines
      this.removeLine(this._currentLine);
    }
    this._currentLine = new Line();
    this.addLine(this._currentLine);
    return this._currentLine;
  }

  private _layoutParams: LayoutParams | null = null;

  /**
   * Resets the current layout parameters to null.
   */
  resetLayoutParams(): void {
    this._layoutParams = null;
    this.resetLine();
  }

  /**
   * Gets the current layout parameters, creating or finding an appropriate one if needed.
   */
  get layoutParams(): LayoutParams {
    if (this._layoutParams == null) {
      // create it or find one that matches current params
      this._layoutParams = this.findUnnamedLayoutParams();
      if (this._layoutParams == null) {
        this._layoutParams = this.snapshotLayoutParams();
        this._unnamedLayoutParams.push(this._layoutParams);
      }
    }
    return this._layoutParams;
  }

  /**
   * Ensures that named layout parameters with the given name exist.
   * Creates them if they don't exist, or updates current layout parameters to match.
   *
   * @param name The name of the layout parameters
   * @returns The layout parameters
   */
  ensureNamedLayoutParams(name: string): LayoutParams {
    let lp = this._namedLayoutParams.get(name) || null;
    if (lp == null || this._layoutParams != lp) {
      // no change so go ahead
      if (lp == null) {
        // does not exist so create one by re-snapshotting it
        // and saving it
        lp = this.snapshotLayoutParams();
        this._namedLayoutParams.set(name, lp);
      } else {
        // copy named LPs attributes into our locals
        this.currentCycle = lp.cycle;
        this.currentAPB = lp.beatDuration;
        this.currentBreaks = lp.lineBreaks;
      }
      this._layoutParams = lp;
      this.resetLine(); // since layout params have changed
    }
    return this._layoutParams;
  }

  /**
   * Creates a snapshot of the current layout parameters.
   * @returns A new LayoutParams object with the current settings
   */
  protected snapshotLayoutParams(): LayoutParams {
    return new LayoutParams({
      cycle: this.currentCycle,
      beatDuration: this.currentAPB,
      layout: this.currentBreaks,
    });
  }

  /**
   * Finds an unnamed layout parameters object that matches the current settings.
   * @returns Matching layout parameters, or null if none found
   */
  protected findUnnamedLayoutParams(): LayoutParams | null {
    return (
      this._unnamedLayoutParams.find((lp) => {
        return (
          lp.beatDuration == this.currentAPB &&
          this.currentCycle.equals(lp.cycle) &&
          lp.lineBreaksEqual(this.currentBreaks)
        );
      }) || null
    );
  }
}
