import * as TSU from "@panyam/tsutils";
import { Entity, Line } from "../../models";
import { KeyedEnv } from "../../models/env";

export class RawBlock extends Entity {
  get type(): unknown {
    return "Raw";
  }
}

export class Role {
  name = "";
  notesOnly = false;
  index = 0;
}

export type CmdParam = { key: TSU.Nullable<string>; value: any };
export abstract class Command extends Entity {
  // Commands that are auto generated are usually created by other commands
  autoGenerated = false;
  prevSibling: null | Command = null;
  nextSibling: null | Command = null;
  params: CmdParam[];
  index: number;

  constructor(params: CmdParam[] = []) {
    super();
    this.params = params;
    this.index = 0;
  }

  get name(): string {
    return this.constructor.name;
  }

  get type(): string {
    return "Command";
  }

  debugValue(): any {
    return { name: this.name, index: this.index, params: this.params };
  }

  getParam(name: string): any {
    for (const param of this.params) {
      if (param.key == name) return param.value;
    }
    return null;
  }

  getParamAt(index: number): any {
    return index < this.params.length ? this.params[index].value : null;
  }

  abstract applyToNotation(notebook: Notation): void;
}

export class Notation extends Entity {
  private blocks: (Line | RawBlock)[] = [];
  private _currRole: TSU.Nullable<Role> = null;
  roles: Role[] = [];
  readonly properties = new KeyedEnv();

  add(item: Line | RawBlock): void {
    this.blocks.push(item);
  }

  get type(): unknown {
    return "Notation";
  }

  children(): Entity[] {
    return this.blocks;
  }

  getRole(name: string): TSU.Nullable<Role> {
    name = name.trim().toLowerCase();
    if (name == "") {
      return this.roles[this.roles.length - 1] || null;
    }
    for (let i = 0; i < this.roles.length; i++) {
      const rd = this.roles[i];
      if (name == rd.name) return rd;
    }
    return null;
  }

  newRole(name: string, notesOnly = false): Role {
    name = name.trim().toLowerCase();
    if (name.trim() == "") {
      throw new Error("Role name cannot be empty");
    }
    const roleDef = this.getRole(name);
    if (roleDef != null) {
      // if (snippet == this) {
      // then replace it
      roleDef.notesOnly = notesOnly;
      return roleDef;
      // }
      // throw new Error(`Role ${name} already exists`);
    }
    // create new and add
    const rd = new Role();
    rd.name = name;
    rd.notesOnly = notesOnly;
    rd.index = this.roles.length;
    this.roles.push(rd);

    return rd;
  }

  get currRole(): Role {
    if (this._currRole == null) {
      if (this.roles.length == 0) {
        throw new Error("No roles defined");
      } else {
        this._currRole = this.roles[this.roles.length - 1];
      }
    }
    return this._currRole;
  }

  setCurrRole(name: string): void {
    name = name.trim().toLowerCase();
    if (name.trim() == "") {
      throw new Error("Role name cannot be empty");
    }
    const roleDef = this.getRole(name);
    if (roleDef == null) {
      throw new Error("Role not found: " + name);
    }
    this._currRole = roleDef;
  }

  // Gets the current line, creating it if needed
  get currentLine(): Line {
    if (this.blocks.length == 0 || this.blocks[this.blocks.length - 1].type != "Line") {
      this.newLine();
    }
    return this.blocks[this.blocks.length - 1] as Line;
  }

  newLine(): Line {
    const l = new Line();
    this.blocks.push(l);
    return l;
  }
}
