{"version":3,"file":"126.734787bdf64205cf222c.js","mappings":"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","sources":["webpack://notations/./src/notation.ts","webpack://notations/./src/carnatic/embelishments.ts","webpack://notations/./src/iterators.ts","webpack://notations/./src/events.ts","webpack://notations/./src/cycle.ts","webpack://notations/./src/carnatic/LineView.ts","webpack://notations/./src/carnatic/atomviews.ts","webpack://notations/./src/entity.ts","webpack://notations/./src/carnatic/gamakas.ts","webpack://notations/./styles/NotationView.scss","webpack://notations/./src/carnatic/NotationView.ts","webpack://notations/./src/loader.ts","webpack://notations/./src/layouts.ts","webpack://notations/./src/shapes.ts","webpack://notations/./styles/NotationView.scss?ffea","webpack://notations/./src/beatview.ts","webpack://notations/./src/carnatic/beatviews.ts","webpack://notations/./src/beats.ts","webpack://notations/./src/core.ts","webpack://notations/./src/utils.ts","webpack://notations/./src/commands.ts","webpack://notations/./src/parser.ts"],"sourcesContent":["import * as TSU from \"@panyam/tsutils\";\nimport { Entity, CmdParam, ParamsMixin } from \"./entity\";\nimport { Cycle } from \"./cycle\";\nimport { Line } from \"./core\";\nimport {\n  RoleDef,\n  RawBlock,\n  BlockItem,\n  Block,\n  SectionBlock,\n  RepeatBlock,\n  CycleBlock,\n  BeatDurationBlock,\n  BreaksBlock,\n  RoleBlock,\n  GroupBlock,\n  isBlock,\n  isLine,\n  isRawBlock,\n  findContainingBlock,\n} from \"./block\";\n\n// Re-export for backward compatibility\nexport {\n  RoleDef,\n  RawBlock,\n  BlockItem,\n  Block,\n  SectionBlock,\n  RepeatBlock,\n  CycleBlock,\n  BeatDurationBlock,\n  BreaksBlock,\n  RoleBlock,\n  GroupBlock,\n  isBlock,\n  isLine,\n  isRawBlock,\n  findContainingBlock,\n};\n\n// Re-export CmdParam for backwards compatibility\nexport { CmdParam } from \"./entity\";\n\n// Apply ParamsMixin to Entity for Command base class\nconst EntityWithParams = ParamsMixin(Entity);\n\n/**\n * Base class for commands in the notation.\n * Commands modify the notation in various ways, such as adding content,\n * changing layout, setting roles, etc.\n */\nexport abstract class Command extends EntityWithParams {\n  /** Whether this command was auto-generated */\n  autoGenerated = false;\n\n  /** Previous command in the sequence */\n  prevSibling: null | Command = null;\n\n  /** Next command in the sequence */\n  nextSibling: null | Command = null;\n\n  /** Index of this command in the sequence */\n  index: number;\n\n  /**\n   * Creates a new Command.\n   * @param params Optional parameters for the command\n   */\n  constructor(params: CmdParam[] = []) {\n    super();\n    this.params = params;\n    this.index = 0;\n    this.validateParams();\n  }\n\n  /**\n   * Validates the parameters for this command.\n   * @throws Error if parameters are invalid\n   */\n  validateParams(): void {\n    //\n  }\n\n  /**\n   * Gets the name of this command.\n   */\n  get name(): string {\n    return this.constructor.name;\n  }\n\n  /**\n   * Returns a debug-friendly representation of this command.\n   * @returns An object containing debug information\n   */\n  debugValue(): any {\n    return { name: this.name, index: this.index, params: this.params };\n  }\n\n  /**\n   * Applies this command to a block (the primary method).\n   * Since Notation extends Block, this works for both.\n   * @param container The block to apply this command to\n   */\n  abstract applyToBlock(container: Block): void;\n\n  /**\n   * @deprecated Use applyToBlock instead\n   * Applies this command to a notation.\n   * Default implementation delegates to applyToBlock.\n   * @param notation The notation to apply this command to\n   */\n  applyToNotation(notation: Notation): void {\n    this.applyToBlock(notation);\n  }\n}\n\n/**\n * Represents metadata for the notation.\n */\nexport class MetaData {\n  /**\n   * Creates a new MetaData.\n   * @param key The key for this metadata\n   * @param value The value of this metadata\n   * @param params Optional additional parameters\n   */\n  constructor(\n    public readonly key: string,\n    public readonly value: string,\n    public readonly params?: any,\n  ) {\n    params = params || {};\n  }\n}\n\n/**\n * The main class representing a complete notation.\n * Notation is the root Block of the notation hierarchy.\n * It contains all the elements, settings, and layout information for a piece of music.\n */\nexport class Notation extends Block {\n  readonly TYPE = \"Notation\";\n\n  // ============================================\n  // Notation-specific properties\n  // ============================================\n\n  /** Metadata associated with this notation */\n  metadata = new Map<string, MetaData>();\n\n  /** Handler for missing roles */\n  onMissingRole: (name: string) => RoleDef | null = (name) => this.newRoleDef(name, name == \"sw\");\n\n  /**\n   * Creates a new Notation.\n   */\n  constructor() {\n    super(\"notation\", null);\n    // Set default values for root notation\n    this.localCycle = Cycle.DEFAULT;\n    this.localAtomsPerBeat = 1;\n    this.localBreaks = [];\n  }\n\n  // ============================================\n  // Backward compatibility aliases\n  // ============================================\n\n  /**\n   * @deprecated Use blockItems instead\n   * Legacy accessor for blocks array.\n   */\n  get blocks(): BlockItem[] {\n    return this.blockItems;\n  }\n\n  /**\n   * @deprecated Use localAtomsPerBeat instead\n   * Legacy accessor for current atoms per beat.\n   */\n  get currentAPB(): number {\n    return this.localAtomsPerBeat ?? 1;\n  }\n\n  set currentAPB(value: number) {\n    this.localAtomsPerBeat = value;\n  }\n\n  /**\n   * @deprecated Use localCycle instead\n   * Legacy accessor for current cycle.\n   */\n  get currentCycle(): Cycle {\n    return this.localCycle ?? Cycle.DEFAULT;\n  }\n\n  set currentCycle(value: Cycle) {\n    this.localCycle = value;\n  }\n\n  /**\n   * @deprecated Use localBreaks instead\n   * Legacy accessor for current breaks.\n   */\n  get currentBreaks(): number[] {\n    return this.localBreaks ?? [];\n  }\n\n  set currentBreaks(value: number[]) {\n    this.localBreaks = value;\n  }\n\n  /**\n   * @deprecated Use localRoles instead\n   * Legacy accessor for roles array.\n   */\n  get roles(): RoleDef[] {\n    return Array.from(this.localRoles.values());\n  }\n\n  // ============================================\n  // Overridden methods\n  // ============================================\n\n  /**\n   * Sets the current role by name.\n   * Uses onMissingRole callback for auto-creation of missing roles.\n   * @param name The name of the role to set as current\n   * @throws Error if the name is empty or the role is not found\n   */\n  setCurrRole(name: string): void {\n    name = name.trim().toLowerCase();\n    if (name.trim() == \"\") {\n      throw new Error(\"Role name cannot be empty\");\n    }\n    const roleDef = this.getRole(name) || (this.onMissingRole ? this.onMissingRole(name) || null : null);\n    if (roleDef == null) {\n      throw new Error(\"Role not found: \" + name);\n    }\n    this._currRoleDef = roleDef;\n  }\n\n  /**\n   * Gets a role definition by name.\n   * Handles empty name by returning the last added role.\n   * @param name The name of the role\n   * @returns The role definition, or null if not found\n   */\n  getRoleDef(name: string): TSU.Nullable<RoleDef> {\n    name = name.trim().toLowerCase();\n    if (name === \"\") {\n      // Return the last added role if name is empty\n      const roles = Array.from(this.localRoles.values());\n      return roles[roles.length - 1] || null;\n    }\n    return this.localRoles.get(name) ?? null;\n  }\n\n  /**\n   * Creates a new role definition.\n   * @param name The name of the role\n   * @param notesOnly Whether the role contains only notes, defaults to false\n   * @returns The created role definition\n   * @throws Error if the name is empty or the role already exists\n   */\n  newRoleDef(name: string, notesOnly = false): RoleDef {\n    name = name.trim().toLowerCase();\n    if (name === \"\") {\n      throw new Error(\"Role name cannot be empty\");\n    }\n    if (this.localRoles.has(name)) {\n      throw new Error(\"Role already exists: \" + name);\n    }\n    // create new and add\n    const rd = new RoleDef();\n    rd.name = name;\n    rd.notesOnly = notesOnly;\n    rd.index = this.localRoles.size;\n    this.localRoles.set(name, rd);\n\n    return rd;\n  }\n\n  // ============================================\n  // Additional methods\n  // ============================================\n\n  /**\n   * Adds a line to this notation.\n   * @param line The line to add\n   */\n  addLine(line: Line): void {\n    this.addBlockItem(line);\n  }\n\n  /**\n   * Removes a line from this notation.\n   * @param line The line to remove\n   * @returns The index of the removed line, or -1 if not found\n   */\n  removeLine(line: Line): number {\n    return this.removeBlockItem(line);\n  }\n\n  /**\n   * Adds a raw block to this notation.\n   * @param raw The raw block to add\n   */\n  addRawBlock(raw: RawBlock): void {\n    this.addBlockItem(raw);\n    this.resetLine();\n  }\n\n  /**\n   * Adds metadata to this notation.\n   * @param meta The metadata to add\n   * @param addBlock Whether to add a corresponding raw block, defaults to true\n   */\n  addMetaData(meta: MetaData, addBlock = true): void {\n    if (addBlock && !this.metadata.has(meta.key)) {\n      // Add a new raw block here\n      // set this by key so even if metadata changes we can\n      // get latest value of it\n      const raw = new RawBlock(meta.key, \"metadata\");\n      this.addRawBlock(raw);\n    }\n    this.metadata.set(meta.key, meta);\n  }\n\n  /**\n   * Resets the current line pointer to null.\n   */\n  resetLine(): void {\n    this._currentLine = null;\n  }\n\n  /**\n   * Returns a debug-friendly representation of this notation.\n   * Uses Notation-specific property names for backward compatibility.\n   * @returns An object containing debug information\n   */\n  debugValue(): any {\n    // Use Notation-specific names (blocks, currentCycle, etc.)\n    // instead of Block names (blockItems, localCycle, etc.)\n    // to maintain backward compatibility with existing tests\n    return {\n      blocks: this.blocks.map((b) => b.debugValue()),\n      currentAPB: this.currentAPB,\n      currentBreaks: this.currentBreaks,\n      currentCycle: this.currentCycle?.uuid,\n      roles: this.roles,\n    };\n  }\n\n  // Need protected access to _currRoleDef for setCurrRole override\n  protected _currRoleDef: TSU.Nullable<RoleDef> = null;\n\n  /**\n   * Gets the current role definition.\n   */\n  get currRoleDef(): RoleDef | null {\n    if (this._currRoleDef == null) {\n      const roles = Array.from(this.localRoles.values());\n      if (roles.length === 0) {\n        return null;\n      } else {\n        this._currRoleDef = roles[roles.length - 1];\n      }\n    }\n    return this._currRoleDef;\n  }\n\n  // Need protected access to _currentLine for resetLine\n  protected _currentLine: Line | null = null;\n\n  /**\n   * Gets the current line, creating it if needed.\n   */\n  get currentLine(): Line {\n    if (this._currentLine == null) {\n      return this.newLine();\n    }\n    return this._currentLine;\n  }\n\n  /**\n   * Creates a new line and makes it the current line.\n   * @returns The newly created line\n   */\n  newLine(): Line {\n    if (this._currentLine && this._currentLine.isEmpty) {\n      // then remove it first instead of adding another\n      // so we dont have a string of empty lines\n      this.removeLine(this._currentLine);\n    }\n    this._currentLine = new Line();\n    this.addLine(this._currentLine);\n    return this._currentLine;\n  }\n}\n","import * as TSU from \"@panyam/tsutils\";\nimport { Note } from \"../core\";\nimport { BeatView } from \"../beatview\";\nimport { Embelishment, GroupView as GroupViewBase } from \"../shapes\";\nimport { LeafAtomView } from \"./atomviews\";\nimport { JaaruGamaka } from \"./gamakas\";\n\n/**\n * Embelishments specifically \"around\" a single atom view.\n */\nexport abstract class LeafAtomViewEmbelishment extends Embelishment {\n  constructor(public readonly atomView: LeafAtomView) {\n    super();\n  }\n}\n\nexport class OctaveIndicator extends LeafAtomViewEmbelishment {\n  dotRadius = 1;\n  dotSpacing = 2.5;\n  dotsElem: SVGGElement;\n\n  constructor(\n    public readonly noteView: LeafAtomView,\n    public readonly note: Note,\n  ) {\n    super(noteView);\n    const rootElem = this.noteView.embRoot();\n    const numDots = Math.abs(note.octave);\n    this.dotsElem = TSU.DOM.createSVGNode(\"g\", {\n      doc: document,\n      parent: rootElem,\n      attrs: {\n        width: this.dotRadius * 2 * numDots + (numDots - 1) * this.dotSpacing,\n        height: this.dotRadius * 2,\n        source: \"atom\" + this.noteView.leafAtom.uuid,\n      },\n    });\n    let cx = 0;\n    for (let i = 0; i < numDots; i++) {\n      TSU.DOM.createSVGNode(\"circle\", {\n        doc: document,\n        parent: this.dotsElem,\n        attrs: {\n          cx: cx,\n          cy: 0,\n          r: this.dotRadius,\n          class: \"notation-octave-dot\",\n        },\n      });\n      cx += this.dotRadius + this.dotRadius + this.dotSpacing;\n    }\n  }\n\n  protected refreshBBox(): TSU.Geom.Rect {\n    return TSU.DOM.svgBBox(this.dotsElem);\n  }\n\n  protected refreshMinSize(): TSU.Geom.Size {\n    const numDots = Math.abs(this.note.octave);\n    return {\n      width: this.dotRadius * 2 * numDots + (numDots - 1) * this.dotSpacing,\n      height: this.dotRadius * 2,\n    };\n  }\n\n  protected updateBounds(\n    x: null | number,\n    y: null | number,\n    _w: null | number,\n    _h: null | number,\n  ): [number | null, number | null, number | null, number | null] {\n    if (x == null) x = this.x;\n    if (y == null) y = this.y;\n    // cannot set w/h\n    // this.bbox.x = x;\n    // this.bbox.y = y;\n    return [x, y, null, null];\n  }\n\n  refreshLayout(): void {\n    this.dotsElem.setAttribute(\"transform\", \"translate(\" + this.x + \",\" + this.y + \")\");\n  }\n}\n\n////////// Carnatic embelishments\nexport class LabelEmbelishment extends LeafAtomViewEmbelishment {\n  labelElem: SVGTextElement;\n  constructor(\n    public readonly label: string,\n    public readonly atomView: LeafAtomView,\n  ) {\n    super(atomView);\n    const rootElem = this.atomView.embRoot();\n    this.labelElem = TSU.DOM.createSVGNode(\"text\", {\n      doc: document,\n      parent: rootElem,\n      text: label,\n      attrs: {\n        source: \"atom\" + this.atomView.leafAtom.uuid,\n        class: \"notation-embelishment-label\",\n        \"dominant-baseline\": \"hanging\",\n      },\n    });\n  }\n\n  protected refreshBBox(): TSU.Geom.Rect {\n    return TSU.DOM.svgBBox(this.labelElem);\n  }\n\n  protected refreshMinSize(): TSU.Geom.Size {\n    return TSU.DOM.svgBBox(this.labelElem);\n  }\n\n  protected updateBounds(\n    x: null | number,\n    y: null | number,\n    w: null | number,\n    h: null | number,\n  ): [number | null, number | null, number | null, number | null] {\n    return [x, y, w, h];\n  }\n\n  refreshLayout(): void {\n    this.labelElem.setAttribute(\"x\", \"\" + this.x);\n    this.labelElem.setAttribute(\"y\", \"\" + this.y);\n  }\n}\n\nexport class BeatStartLines extends Embelishment {\n  barSpacing = 10;\n  protected line: SVGLineElement;\n\n  constructor(\n    public readonly source: BeatView,\n    public readonly rootElement: SVGGraphicsElement,\n  ) {\n    super();\n    this.line = TSU.DOM.createSVGNode(\"line\", {\n      doc: document,\n      parent: this.rootElement,\n      attrs: {\n        class: \"bar-start-line\",\n      },\n    });\n  }\n\n  protected refreshBBox(): TSU.Geom.Rect {\n    return new TSU.Geom.Rect(0, 0, 0, 0);\n  }\n\n  protected refreshMinSize(): TSU.Geom.Size {\n    return new TSU.Geom.Rect(0, 0, 0, 0);\n  }\n\n  refreshLayout(): void {\n    const line = this.line;\n    const x = this.source.x - this.barSpacing;\n    line.setAttribute(\"x1\", \"\" + x);\n    line.setAttribute(\"x2\", \"\" + x);\n    const y = this.source.y + this.source.bbox.y;\n    const h = this.source.bbox.height;\n    line.setAttribute(\"y1\", \"\" + y);\n    line.setAttribute(\"y2\", \"\" + (y + h));\n  }\n\n  protected updateBounds(\n    x: null | number,\n    y: null | number,\n    w: null | number,\n    h: null | number,\n  ): [number | null, number | null, number | null, number | null] {\n    return [x, y, null, h];\n  }\n}\n\nexport class BeatEndLines extends Embelishment {\n  lineSpacing = 2;\n  protected lines: SVGLineElement[];\n\n  constructor(\n    public readonly source: BeatView,\n    public readonly rootElement: SVGGraphicsElement,\n    nLines = 1,\n  ) {\n    super();\n    this.lines = [];\n    for (let i = 0; i < nLines; i++) {\n      this.lines.push(\n        TSU.DOM.createSVGNode(\"line\", {\n          doc: document,\n          // parent: l2g,\n          parent: this.rootElement,\n          attrs: {\n            class: \"bar-end-line\",\n          },\n        }),\n      );\n    }\n  }\n\n  protected refreshBBox(): TSU.Geom.Rect {\n    return new TSU.Geom.Rect(0, 0, 0, 0);\n  }\n\n  protected refreshMinSize(): TSU.Geom.Size {\n    return new TSU.Geom.Rect(0, 0, 0, 0);\n  }\n\n  protected updatePosition(x: null | number, y: null | number): [number | null, number | null] {\n    return [x, y];\n  }\n\n  barSpacing = 0;\n\n  refreshLayout(): void {\n    // const x = this.source.width + this.barSpacing;\n    // const y = 0;\n    // const h = this.source.height;\n    const x = this.source.x + this.source.width + this.barSpacing;\n    const y = this.source.y + this.source.bbox.y;\n    const h = this.source.bbox.height;\n    let currX = x;\n    for (const line of this.lines) {\n      const lx = \"\" + currX;\n      line.setAttribute(\"x1\", lx);\n      line.setAttribute(\"x2\", lx);\n      currX += 4;\n    }\n    for (const line of this.lines) {\n      line.setAttribute(\"y1\", \"\" + y);\n      line.setAttribute(\"y2\", \"\" + (y + h));\n    }\n  }\n\n  protected updateBounds(\n    _x: null | number,\n    _y: null | number,\n    _w: null | number,\n    _h: null | number,\n  ): [number | null, number | null, number | null, number | null] {\n    return [null, null, null, null];\n  }\n}\n\n/// Carnatic Embelishments\nexport class Kampitham extends LabelEmbelishment {\n  constructor(public readonly atomView: LeafAtomView) {\n    super(\"~\", atomView);\n  }\n}\n\nexport class Nokku extends LabelEmbelishment {\n  constructor(public readonly atomView: LeafAtomView) {\n    super(\"w\", atomView);\n  }\n}\n\nexport class Prathyagatham extends LabelEmbelishment {\n  constructor(public readonly atomView: LeafAtomView) {\n    super(\"\", atomView);\n  }\n}\nexport class Spuritham extends LabelEmbelishment {\n  constructor(public readonly atomView: LeafAtomView) {\n    super(\"\", atomView);\n  }\n}\nexport class Raavi extends LabelEmbelishment {\n  constructor(public readonly atomView: LeafAtomView) {\n    super(\"^\", atomView);\n  }\n}\nexport class Kandippu extends LabelEmbelishment {\n  constructor(public readonly atomView: LeafAtomView) {\n    super(\"\", atomView);\n  }\n}\n\nexport class Vaali extends LabelEmbelishment {\n  constructor(public readonly atomView: LeafAtomView) {\n    super(\"\", atomView);\n  }\n}\nexport class Odukkal extends LabelEmbelishment {\n  constructor(public readonly atomView: LeafAtomView) {\n    super(\"x\", atomView);\n  }\n}\nexport class Orikkai extends LabelEmbelishment {\n  constructor(public readonly atomView: LeafAtomView) {\n    super(\"\", atomView);\n  }\n}\n\nexport class Jaaru extends LeafAtomViewEmbelishment {\n  pathElem: SVGPathElement;\n  constructor(\n    public readonly jaaru: JaaruGamaka,\n    public readonly atomView: LeafAtomView,\n  ) {\n    super(atomView);\n    // TODO - Create the \"fancier\" view\n    // for now represent this with just a slant line (like a slash)\n    const rootElem = this.atomView.embRoot();\n    this.pathElem = TSU.DOM.createSVGNode(\"path\", {\n      doc: document,\n      parent: rootElem,\n      attrs: {\n        source: \"atom\" + this.atomView.leafAtom.uuid,\n        class: \"notation-jaaru-path\",\n        d: this.pathAttribute(),\n      },\n    });\n  }\n\n  pathAttribute(x = 0): string {\n    const avbbox = this.atomView.glyph.minSize;\n    let y2 = 0;\n    const h2 = avbbox.height / 2;\n    const x2 = x + h2;\n    let y = this.atomView.y;\n    if (this.jaaru.ascending) {\n      y += avbbox.height;\n      y2 = y - h2;\n    } else {\n      y -= h2;\n      y2 = y + h2;\n    }\n    return [`M ${x} ${y}`, `Q ${x2} ${y} ${x2} ${y2}`].join(\" \");\n  }\n\n  protected refreshMinSize(): TSU.Geom.Size {\n    return TSU.DOM.svgBBox(this.pathElem);\n  }\n\n  protected refreshBBox(): TSU.Geom.Rect {\n    return TSU.DOM.svgBBox(this.pathElem);\n  }\n\n  protected updateBounds(\n    x: null | number,\n    _y: null | number,\n    _w: null | number,\n    _h: null | number,\n  ): [number | null, number | null, number | null, number | null] {\n    return [x, null, null, null];\n  }\n\n  refreshLayout(): void {\n    this.pathElem.setAttribute(\"d\", this.pathAttribute(this.x));\n  }\n}\n\n/**\n * Position mode for GroupBracket - controls how the bracket interacts with embellishments.\n */\nexport type GroupBracketPositionMode = \"above-all\" | \"below-embellishments\" | \"separate-space\";\n\n/**\n * Renders a single bracket line as the top border of a GroupView container.\n * Each nested group gets its own bracket line, creating a visual effect where\n * atoms inside deeply nested groups appear to have multiple lines above them.\n *\n * For example, with notation `A B [ S R [ P D [ W X ] ] ]`:\n * - Group 1 (outermost) has 1 bracket line\n * - Group 2 has 1 bracket line (inside Group 1's bracket)\n * - Group 3 (innermost) has 1 bracket line (inside Groups 1 & 2's brackets)\n * - Atoms W X visually appear to have 3 lines above (cumulative effect)\n */\nexport class GroupBracket extends Embelishment {\n  private line: SVGLineElement | null = null;\n  private leftCircle: SVGCircleElement | null = null;\n  private rightCircle: SVGCircleElement | null = null;\n  private bracketGroup: SVGGElement | null = null;\n\n  // Configuration - exposed for experimentation\n  /** Distance above group content */\n  lineOffset = 2;\n  /** End circle radius */\n  circleRadius = 1.5;\n  /** How far line extends beyond group content on each side */\n  lineExtension = 2;\n\n  /**\n   * Position mode for embellishment interaction experimentation:\n   * - 'above-all': Bracket at very top, above all embellishments\n   * - 'below-embellishments': Bracket between glyphs and embellishments (default)\n   * - 'separate-space': Bracket in dedicated reserved space\n   */\n  positionMode: GroupBracketPositionMode = \"below-embellishments\";\n\n  constructor(public readonly groupView: GroupViewBase) {\n    super();\n\n    this.bracketGroup = TSU.DOM.createSVGNode(\"g\", {\n      doc: document,\n      parent: this.groupView.groupElement,\n      attrs: {\n        class: \"group-bracket\",\n        source: \"group\" + this.groupView.group.uuid,\n      },\n    });\n\n    this.line = TSU.DOM.createSVGNode(\"line\", {\n      doc: document,\n      parent: this.bracketGroup,\n      attrs: {\n        class: \"group-bracket-line\",\n      },\n    });\n\n    this.leftCircle = TSU.DOM.createSVGNode(\"circle\", {\n      doc: document,\n      parent: this.bracketGroup,\n      attrs: {\n        class: \"group-bracket-circle\",\n        r: String(this.circleRadius),\n      },\n    });\n\n    this.rightCircle = TSU.DOM.createSVGNode(\"circle\", {\n      doc: document,\n      parent: this.bracketGroup,\n      attrs: {\n        class: \"group-bracket-circle\",\n        r: String(this.circleRadius),\n      },\n    });\n  }\n\n  protected refreshBBox(): TSU.Geom.Rect {\n    if (!this.bracketGroup) return new TSU.Geom.Rect(0, 0, 0, 0);\n    return TSU.DOM.svgBBox(this.bracketGroup);\n  }\n\n  protected refreshMinSize(): TSU.Geom.Size {\n    // Single bracket line height contribution\n    return new TSU.Geom.Size(0, this.lineOffset + this.circleRadius);\n  }\n\n  protected updateBounds(\n    x: null | number,\n    y: null | number,\n    w: null | number,\n    h: null | number,\n  ): [number | null, number | null, number | null, number | null] {\n    return [x, y, w, h];\n  }\n\n  refreshLayout(): void {\n    if (!this.line || !this.leftCircle || !this.rightCircle) return;\n\n    const bbox = this.groupView.bbox;\n    // Use actual content width (not bbox which may include extra space)\n    const groupWidth = this.groupView.contentWidth || bbox.width;\n\n    // Calculate Y position based on position mode\n    let y: number;\n    switch (this.positionMode) {\n      case \"below-embellishments\":\n        // Position just above glyph content, below other embellishments\n        y = bbox.y + this.lineOffset - 2;\n        break;\n      case \"separate-space\":\n        // Use dedicated space at very top of group bbox\n        y = bbox.y - this.lineOffset;\n        break;\n      case \"above-all\":\n      default:\n        // Position above everything including embellishments\n        y = bbox.y - this.lineOffset;\n        break;\n    }\n\n    const x1 = -this.lineExtension;\n    const x2 = groupWidth + this.lineExtension;\n\n    this.line.setAttribute(\"x1\", String(x1));\n    this.line.setAttribute(\"y1\", String(y));\n    this.line.setAttribute(\"x2\", String(x2));\n    this.line.setAttribute(\"y2\", String(y));\n\n    this.leftCircle.setAttribute(\"cx\", String(x1));\n    this.leftCircle.setAttribute(\"cy\", String(y));\n    this.rightCircle.setAttribute(\"cx\", String(x2));\n    this.rightCircle.setAttribute(\"cy\", String(y));\n  }\n}\n","import * as TSU from \"@panyam/tsutils\";\nimport { TimedEntity } from \"./entity\";\nimport { Atom, LeafAtom, Space, Group, AtomType } from \"./core\";\n\ntype Fraction = TSU.Num.Fraction;\n// type FlatAtom2 = [atom: Atom, duration: TSU.Num.Fraction, offset: TSU.Num.Fraction];\n\n/**\n * Represents a flattened atom with timing information.\n * FlatAtom is used to process nested atom structures in a flat, sequential manner\n * with proper timing information.\n */\nexport class FlatAtom extends TimedEntity {\n  readonly TYPE = \"FlatAtom\";\n\n  /** Nesting depth of this atom in the original structure */\n  depth: number;\n\n  /** Duration of this atom */\n  duration: TSU.Num.Fraction;\n\n  /** Time offset of this atom */\n  offset: TSU.Num.Fraction;\n\n  /** Whether this atom is a continuation of a previous atom */\n  private isContinuation: boolean;\n\n  /**\n   * Creates a new FlatAtom.\n   * @param atom The leaf atom this flat atom represents\n   * @param config Optional configuration with depth, duration, offset, and continuation info\n   */\n  constructor(\n    public atom: LeafAtom,\n    config: any = null,\n  ) {\n    super((config = config || {}));\n    this.depth = config.depth || 0;\n    this.duration = config.duration || atom.duration;\n    this.offset = config.offset || TSU.Num.Fraction.ZERO;\n    this.isContinuation = \"isContinuation\" in config ? config.isContinuation : false;\n  }\n\n  /**\n   * Gets the end offset of this atom (offset + duration).\n   */\n  get endOffset(): TSU.Num.Fraction {\n    return this.offset.plus(this.duration);\n  }\n\n  /**\n   * Returns a debug-friendly representation of this FlatAtom.\n   * @returns An object containing debug information\n   */\n  debugValue(): any {\n    const out = {\n      ...super.debugValue(),\n      atom: this.atom.debugValue(),\n      duration: this.duration.toString(),\n      offset: this.offset.toString(),\n      depth: this.depth,\n    };\n    if (this.isContinuation) out.isContinuation = true;\n    return out;\n  }\n}\n\n/**\n * A nested atom iterator that returns one atom at a time at the leaf-most level.\n * If we have a Group (or nested Groups) only the leaf atoms are returned as if\n * in an in-order traversal, thus ensuring time order of atoms.\n */\nexport class AtomIterator {\n  private atomQueue = new TSU.Lists.List<[Atom, number, Fraction]>();\n  private currOffset = TSU.Num.Fraction.ZERO;\n  private peeked: TSU.Nullable<FlatAtom> = null;\n\n  /**\n   * Creates a new AtomIterator with optional initial atoms.\n   * @param atoms Initial atoms to iterate through\n   */\n  constructor(...atoms: Atom[]) {\n    this.push(...atoms);\n  }\n\n  /**\n   * Push atoms to be flattened and served by this iterator.\n   * @param atoms The atoms to add to the queue\n   * @returns This iterator instance for method chaining\n   */\n  push(...atoms: Atom[]): this {\n    for (const atom of atoms) {\n      this.atomQueue.add([atom, 0, atom.duration]);\n    }\n    return this;\n  }\n\n  /**\n   * Gets the next atom in the sequence and advances the iterator.\n   * @returns The next FlatAtom, or null if no more atoms are available\n   */\n  next(): TSU.Nullable<FlatAtom> {\n    const out = this.peek();\n    this.peeked = null;\n    if (out != null) {\n      this.currOffset = this.currOffset.plus(out.duration).factorized;\n    }\n    return out;\n  }\n\n  /**\n   * Peeks at the next atom without advancing the iterator.\n   * @returns The next FlatAtom, or null if no more atoms are available\n   */\n  peek(): TSU.Nullable<FlatAtom> {\n    if (this.peeked == null) {\n      if (this.hasNext) {\n        const [nextAtom, nextDepth, nextDuration] = this.atomQueue.popFront();\n        this.peeked = new FlatAtom(nextAtom as LeafAtom, {\n          depth: nextDepth,\n          offset: this.currOffset,\n          duration: nextDuration,\n        });\n      }\n    }\n    return this.peeked;\n  }\n\n  /**\n   * Checks if more atoms are available in this iterator.\n   * This may process group atoms to find the next leaf atom.\n   */\n  get hasNext(): boolean {\n    while (this.atomQueue.first != null) {\n      // Get from front of queue\n      const [nextAtom, nextDepth, nextDuration] = this.atomQueue.first.value;\n      if (nextAtom.TYPE != AtomType.GROUP) {\n        return true;\n      } else {\n        this.atomQueue.popFront();\n        const group = nextAtom as Group;\n        for (const child of group.atoms.reversedValues()) {\n          this.atomQueue.pushFront([\n            child,\n            nextDepth + 1,\n            nextDuration.times(child.duration).divby(group.totalChildDuration).factorized,\n          ]);\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Gets the atom with the minimum offset from multiple iterators.\n   * @param iterators An array of AtomIterators to compare\n   * @returns A tuple containing the index of the selected iterator and its next atom\n   */\n  static getMin(iterators: AtomIterator[]): [number, FlatAtom] {\n    let currRole = -1;\n    let currAtom: TSU.Nullable<FlatAtom> = null;\n    for (let ri = 0; ri < iterators.length; ri++) {\n      const flatAtom = iterators[ri].peek();\n      if (flatAtom != null) {\n        if (currAtom == null || flatAtom.offset.cmp(currAtom.offset) < 0) {\n          currRole = ri;\n          currAtom = flatAtom;\n        }\n      }\n    }\n    if (currRole >= 0) {\n      iterators[currRole].next();\n    }\n    return [currRole, currAtom!];\n  }\n}\n\n/**\n * An iterator that provides atoms within specified time windows.\n * WindowIterator allows fetching atoms to cover a specific duration,\n * handling the splitting of atoms if necessary.\n */\nexport class WindowIterator {\n  private atomQueue = new TSU.Lists.List<Atom>();\n  private currOffset = TSU.Num.Fraction.ZERO;\n  private peeked: TSU.Nullable<Atom> = null;\n\n  /**\n   * Creates a new WindowIterator with optional initial atoms.\n   * @param atoms Initial atoms to iterate through\n   */\n  constructor(...atoms: Atom[]) {\n    this.push(...atoms);\n  }\n\n  /**\n   * Push atoms to be served by this iterator.\n   * @param atoms The atoms to add to the queue\n   * @returns This iterator instance for method chaining\n   */\n  push(...atoms: Atom[]): this {\n    for (const atom of atoms) {\n      this.atomQueue.add(atom);\n    }\n    return this;\n  }\n\n  /**\n   * Gets the next atom in the sequence and advances the iterator.\n   * For atoms with participatesInTiming=false, the offset is not advanced.\n   * @returns The next Atom, or null if no more atoms are available\n   */\n  next(): TSU.Nullable<Atom> {\n    const out = this.peek();\n    this.peeked = null;\n    if (out != null && out.participatesInTiming) {\n      this.currOffset = this.currOffset.plus(out.duration, true);\n    }\n    return out;\n  }\n\n  /**\n   * Peeks at the next atom without advancing the iterator.\n   * @returns The next Atom, or null if no more atoms are available\n   */\n  peek(): TSU.Nullable<Atom> {\n    if (this.peeked == null && this.hasMore) {\n      this.peeked = this.atomQueue.popFront();\n    }\n    return this.peeked;\n  }\n\n  /**\n   * Checks if more atoms are available in this iterator.\n   */\n  get hasMore(): boolean {\n    return !this.atomQueue.isEmpty;\n  }\n\n  /**\n   * Gets atoms to cover the specified duration.\n   *\n   * If the number of atoms left in the iterator is 0, an empty list\n   * is returned. Otherwise, the duration of atoms returned will cover\n   * the given duration even if padding with Space atoms is necessary.\n   *\n   * Atoms with participatesInTiming=false (like Markers) are returned\n   * but don't consume any of the requested duration.\n   *\n   * @param duration The duration to cover\n   * @returns A tuple containing the array of atoms and whether the full duration was filled\n   */\n  get(duration: TSU.Num.Fraction): [Atom[], boolean] {\n    const out: Atom[] = [];\n    let remaining = duration;\n    while (remaining.isGTNum(0) && this.hasMore) {\n      const next = this.next();\n      TSU.assert(next != null, \"Next cannot be null here\");\n      out.push(next);\n\n      // Only process timing for atoms that participate in timing\n      // Markers and other non-timing atoms are returned without consuming duration\n      if (next.participatesInTiming) {\n        const spillOver = next.splitAt(remaining);\n        remaining = remaining.minus(next.duration);\n        if (spillOver != null) {\n          // push the spill over to the front of the queue to be\n          // picked up on the next \"get\" call\n          this.atomQueue.pushFront(spillOver);\n        }\n      }\n    }\n    return [out, remaining.isZero];\n  }\n}\n\n/**\n * An iterator that provides atoms with specific durations.\n * DurationIterator ensures that atoms fit within specified duration windows,\n * splitting atoms if necessary to fit.\n */\nexport class DurationIterator {\n  private atomIterator: AtomIterator;\n  private spillOver: TSU.Nullable<FlatAtom> = null;\n\n  /**\n   * Creates a new DurationIterator.\n   * @param atomIterator The AtomIterator to use as a source of atoms\n   */\n  constructor(atomIterator: AtomIterator) {\n    this.atomIterator = atomIterator;\n  }\n\n  /**\n   * Checks if more atoms are available in this iterator.\n   */\n  get hasMore(): boolean {\n    if (this.spillOver != null) {\n      return true;\n    }\n    return this.atomIterator.hasNext;\n  }\n\n  /**\n   * Gets atoms to cover the specified duration.\n   *\n   * If the number of atoms left in the iterator is 0, an empty list\n   * is returned. Otherwise, the duration of atoms returned will cover\n   * the given duration even if padding with Space atoms is necessary.\n   *\n   * @param duration The duration to cover\n   * @returns A tuple containing the array of FlatAtoms and whether the full duration was filled\n   */\n  get(duration: TSU.Num.Fraction): [FlatAtom[], boolean] {\n    const iter = this.atomIterator;\n    const out: FlatAtom[] = [];\n    let remaining = duration;\n    while (remaining.isGTNum(0)) {\n      const next = this.spillOver == null ? iter.next() : this.spillOver;\n      this.spillOver = null;\n      if (next == null) {\n        // stop here\n        break;\n      } else {\n        out.push(next);\n        if (next.duration.cmp(remaining) <= 0) {\n          remaining = remaining.minus(next.duration);\n        } else {\n          // Next leaf atom is > duration\n          // so split it into two\n          this.spillOver = new FlatAtom(new Space(next.duration.minus(remaining)));\n          next.duration = remaining;\n          remaining = TSU.Num.Fraction.ZERO;\n        }\n      }\n    }\n    return [out, remaining.isZero];\n  }\n}\n","/**\n * Model change events for incremental updates.\n *\n * This module defines the event types, interfaces, and observer patterns for\n * change notifications on model entities (Group, Role, Line, Block). These\n * events enable incremental updates to the rendering pipeline without full\n * re-renders.\n *\n * Uses the Observer pattern instead of pub/sub EventHub for:\n * - Type safety: Observers have strongly-typed method signatures\n * - Traceability: Easy to see who is observing what\n * - Explicit contracts: Clear interface between observable and observers\n *\n * Note: This module uses generic types to avoid circular dependencies with\n * core.ts and block.ts. The actual types are enforced at the call sites.\n */\n\n// ============================================\n// Event Types and Payloads\n// ============================================\n\n/**\n * Event types for Atom-related changes.\n */\nexport enum AtomChangeType {\n  /** Atoms were added to the end */\n  ADD = \"add\",\n  /** Atoms were inserted at a specific position */\n  INSERT = \"insert\",\n  /** Atoms were removed */\n  REMOVE = \"remove\",\n  /** An atom's properties changed (duration, value, etc.) */\n  UPDATE = \"update\",\n}\n\n/**\n * Event payload for atom changes in a Group or Role.\n * Generic T is typically Atom from core.ts.\n */\nexport interface AtomChangeEvent<T = any> {\n  /** The type of change */\n  type: AtomChangeType;\n  /** The atoms that were added, inserted, or removed */\n  atoms: T[];\n  /** For INSERT: the index where atoms were inserted */\n  index?: number;\n  /** For UPDATE: the specific property that changed */\n  property?: string;\n  /** For UPDATE: the old value of the property */\n  oldValue?: any;\n  /** For UPDATE: the new value of the property */\n  newValue?: any;\n}\n\n/**\n * Event types for Role-related changes on a Line.\n */\nexport enum RoleChangeType {\n  /** A role was added to the line */\n  ADD = \"add\",\n  /** A role was removed from the line */\n  REMOVE = \"remove\",\n}\n\n/**\n * Event payload for role changes on a Line.\n */\nexport interface RoleChangeEvent {\n  /** The type of change */\n  type: RoleChangeType;\n  /** The role that was added or removed */\n  roleName: string;\n}\n\n/**\n * Event types for BlockItem changes on a Block.\n */\nexport enum BlockItemChangeType {\n  /** An item was added to the block */\n  ADD = \"add\",\n  /** An item was removed from the block */\n  REMOVE = \"remove\",\n}\n\n/**\n * Event payload for block item changes.\n * Generic T is typically BlockItem (Block | Line | RawBlock) from block.ts.\n */\nexport interface BlockItemChangeEvent<T = any> {\n  /** The type of change */\n  type: BlockItemChangeType;\n  /** The item that was added or removed */\n  item: T;\n  /** For ADD: the index where the item was added */\n  index?: number;\n}\n\n// ============================================\n// Observer Interfaces\n// ============================================\n\n/**\n * Observer interface for Group atom changes.\n * Implement this interface to receive notifications when atoms are\n * added, inserted, or removed from a Group.\n *\n * @template TAtom The atom type (defaults to any to avoid circular deps)\n * @template TGroup The group type (defaults to any to avoid circular deps)\n */\nexport interface GroupObserver<TAtom = any, TGroup = any> {\n  /**\n   * Called when atoms are added to the end of the group.\n   * @param group The group that changed\n   * @param atoms The atoms that were added\n   * @param index The index where atoms were added\n   */\n  onAtomsAdded?(group: TGroup, atoms: TAtom[], index: number): void;\n\n  /**\n   * Called when atoms are inserted at a specific position.\n   * @param group The group that changed\n   * @param atoms The atoms that were inserted\n   * @param index The index where atoms were inserted\n   */\n  onAtomsInserted?(group: TGroup, atoms: TAtom[], index: number): void;\n\n  /**\n   * Called when atoms are removed from the group.\n   * @param group The group that changed\n   * @param atoms The atoms that were removed\n   */\n  onAtomsRemoved?(group: TGroup, atoms: TAtom[]): void;\n}\n\n/**\n * Observer interface for Role atom changes.\n * Implement this interface to receive notifications when atoms are\n * added, inserted, or removed from a Role.\n *\n * @template TAtom The atom type (defaults to any to avoid circular deps)\n * @template TRole The role type (defaults to any to avoid circular deps)\n */\nexport interface RoleObserver<TAtom = any, TRole = any> {\n  /**\n   * Called when atoms are added to the end of the role.\n   * @param role The role that changed\n   * @param atoms The atoms that were added\n   * @param index The index where atoms were added\n   */\n  onAtomsAdded?(role: TRole, atoms: TAtom[], index: number): void;\n\n  /**\n   * Called when atoms are inserted at a specific position.\n   * @param role The role that changed\n   * @param atoms The atoms that were inserted\n   * @param index The index where atoms were inserted\n   */\n  onAtomsInserted?(role: TRole, atoms: TAtom[], index: number): void;\n\n  /**\n   * Called when atoms are removed from the role.\n   * @param role The role that changed\n   * @param atoms The atoms that were removed\n   */\n  onAtomsRemoved?(role: TRole, atoms: TAtom[]): void;\n}\n\n/**\n * Observer interface for Line role changes.\n * Implement this interface to receive notifications when roles are\n * added or removed from a Line.\n *\n * @template TRole The role type (defaults to any to avoid circular deps)\n * @template TLine The line type (defaults to any to avoid circular deps)\n */\nexport interface LineObserver<TRole = any, TLine = any> {\n  /**\n   * Called when a role is added to the line.\n   * @param line The line that changed\n   * @param roleName The name of the added role\n   * @param role The role that was added\n   */\n  onRoleAdded?(line: TLine, roleName: string, role: TRole): void;\n\n  /**\n   * Called when a role is removed from the line.\n   * @param line The line that changed\n   * @param roleName The name of the removed role\n   */\n  onRoleRemoved?(line: TLine, roleName: string): void;\n}\n\n/**\n * Observer interface for Block item changes.\n * Implement this interface to receive notifications when items are\n * added or removed from a Block.\n *\n * @template TItem The block item type (defaults to any to avoid circular deps)\n * @template TBlock The block type (defaults to any to avoid circular deps)\n */\nexport interface BlockObserver<TItem = any, TBlock = any> {\n  /**\n   * Called when an item is added to the block.\n   * @param block The block that changed\n   * @param item The item that was added\n   * @param index The index where the item was added\n   */\n  onItemAdded?(block: TBlock, item: TItem, index: number): void;\n\n  /**\n   * Called when an item is removed from the block.\n   * @param block The block that changed\n   * @param item The item that was removed\n   * @param index The index where the item was located\n   */\n  onItemRemoved?(block: TBlock, item: TItem, index: number): void;\n}\n\n// ============================================\n// Legacy Event Names (kept for compatibility)\n// ============================================\n\n/**\n * Model event names as constants.\n * @deprecated Use observer interfaces instead\n */\nexport const ModelEvents = {\n  /** Emitted when atoms change in a Group or Role */\n  ATOMS_CHANGED: \"atomsChanged\",\n  /** Emitted when roles change on a Line */\n  ROLES_CHANGED: \"rolesChanged\",\n  /** Emitted when block items change on a Block */\n  ITEMS_CHANGED: \"itemsChanged\",\n  /** Emitted when an atom's duration changes */\n  DURATION_CHANGED: \"durationChanged\",\n} as const;\n\n/**\n * Type for model event names.\n * @deprecated Use observer interfaces instead\n */\nexport type ModelEventName = (typeof ModelEvents)[keyof typeof ModelEvents];\n","import * as TSU from \"@panyam/tsutils\";\nimport { Entity, TimedEntity } from \"./entity\";\n\n/**\n * Alias to TSU.Num.Fraction in tsutils.\n */\ntype Fraction = TSU.Num.Fraction;\nexport type CyclePosition = [number, number, number];\nexport type CycleIterator = Generator<[CyclePosition, Fraction]>;\n\nconst ZERO = TSU.Num.Fraction.ZERO;\nconst ONE = TSU.Num.Fraction.ONE;\n\n/**\n * A cursor that traverses through a Cycle's beats in a controlled manner.\n * Allows forward and backward navigation through the cycle.\n */\nexport class CycleCursor {\n  /**\n   * Creates a new CycleCursor.\n   * @param cycle The Cycle to traverse\n   * @param barIndex The starting bar index, defaults to 0\n   * @param beatIndex The starting beat index within the bar, defaults to 0\n   * @param instance The starting instance index within the beat, defaults to 0\n   */\n  constructor(\n    public readonly cycle: Cycle,\n    public barIndex = 0,\n    public beatIndex = 0,\n    public instance = 0,\n  ) {}\n\n  /**\n   * Advances the cursor to the next beat and returns the current position and beat length.\n   * @returns A tuple containing the current position and beat length\n   */\n  get next(): [CyclePosition, Fraction] {\n    const currBar = this.cycle.bars[this.barIndex];\n    const result: [CyclePosition, Fraction] = [\n      [this.barIndex, this.beatIndex, this.instance],\n      currBar.beatLengths[this.beatIndex],\n    ];\n    this.instance++;\n    if (!currBar.beatCounts[this.beatIndex] || this.instance >= currBar.beatCounts[this.beatIndex]) {\n      this.instance = 0;\n      this.beatIndex++;\n      if (this.beatIndex >= currBar.beatLengths.length) {\n        this.beatIndex = 0;\n        this.barIndex++;\n        if (this.barIndex >= this.cycle.bars.length) {\n          this.barIndex = 0;\n        }\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Moves the cursor to the previous beat and returns the current position and beat length.\n   * @returns A tuple containing the current position and beat length\n   */\n  get prev(): [CyclePosition, Fraction] {\n    const currBar = this.cycle.bars[this.barIndex];\n    const result: [CyclePosition, Fraction] = [\n      [this.barIndex, this.beatIndex, this.instance],\n      currBar.beatLengths[this.beatIndex],\n    ];\n    // TODO - result should be set *after* decrementing if we had already\n    // done a \"next\" before this otherwise user may have to do a prev twice\n    this.instance--;\n    if (this.instance < 0) {\n      this.beatIndex--;\n      if (this.beatIndex < 0) {\n        this.barIndex--;\n        if (this.barIndex < 0) {\n          this.barIndex = this.cycle.bars.length - 1;\n        }\n        this.beatIndex = this.cycle.bars[this.barIndex].beatCount - 1;\n      }\n      this.instance = (this.cycle.bars[this.barIndex].beatCounts[this.beatIndex] || 1) - 1;\n    }\n    return result;\n  }\n}\n\n/**\n * Represents a bar in a musical cycle.\n * A bar consists of beats with specific lengths and counts.\n */\nexport class Bar extends TimedEntity {\n  readonly TYPE: string = \"Bar\";\n\n  /** Name of the bar (e.g., \"Laghu\", \"Dhrutam\") */\n  name: string;\n\n  /** Length/Duration of each beat in the bar */\n  beatLengths: Fraction[] = [];\n\n  /** How many times each beat should be repeated (the Kalai) */\n  beatCounts: number[] = [];\n\n  /**\n   * Creates a new Bar.\n   * @param config Configuration object containing name, beatLengths, and beatCounts\n   */\n  constructor(config: any = null) {\n    super((config = config || {}));\n    this.name = config.name || \"\";\n    for (const bl of config.beatLengths || []) {\n      if (typeof bl === \"number\") {\n        this.beatLengths.push(TSU.Num.Frac(bl));\n      } else {\n        this.beatLengths.push(bl);\n      }\n    }\n    for (const bc of config.beatCounts || []) {\n      this.beatCounts.push(bc);\n    }\n    while (this.beatCounts.length < this.beatLengths.length) {\n      this.beatCounts.push(1);\n    }\n  }\n\n  /**\n   * Returns a debug-friendly representation of this Bar.\n   * @returns An object containing debug information\n   */\n  debugValue(): any {\n    return { ...super.debugValue(), name: name, beatLengths: this.beatLengths };\n  }\n\n  /**\n   * Checks if this Bar is equal to another Bar.\n   * @param another The Bar to compare with\n   * @returns True if the Bars are equal, false otherwise\n   */\n  equals(another: this): boolean {\n    if (!super.equals(another)) return false;\n    if (this.beatLengths.length != another.beatLengths.length) return false;\n    if (this.beatCounts.length != another.beatCounts.length) return false;\n    for (let i = 0; i < this.beatLengths.length; i++) {\n      if (!this.beatLengths[i].equals(another.beatLengths[i])) return false;\n    }\n    for (let i = 0; i < this.beatCounts.length; i++) {\n      if (this.beatCounts[i] != another.beatCounts[i]) return false;\n    }\n    return true;\n  }\n\n  /**\n   * Copies the properties of this Bar to another Bar.\n   * @param another The target Bar to copy properties to\n   */\n  copyTo(another: this): void {\n    super.copyTo(another);\n    another.name = this.name;\n    another.beatLengths = [...this.beatLengths];\n    another.beatCounts = [...this.beatCounts];\n  }\n\n  /**\n   * Gets the instance count for a specific beat in the bar.\n   * @param beatIndex The index of the beat\n   * @returns The number of instances for the specified beat\n   */\n  instanceCount(beatIndex: number): number {\n    if (beatIndex > this.beatCounts.length) {\n      // by default each beat has 1 instance?\n      return 1;\n    } else {\n      return this.beatCounts[beatIndex];\n    }\n  }\n\n  /**\n   * Gets the number of unique beats in this bar (irrespective of instances).\n   */\n  get beatCount(): number {\n    return this.beatLengths.length;\n  }\n\n  /**\n   * Gets the total number of beat instances in this bar.\n   */\n  get totalBeatCount(): number {\n    let out = 0;\n    for (let i = 0; i < this.beatLengths.length; i++) {\n      out += this.beatCounts[i] || 1;\n    }\n    return out;\n  }\n\n  /**\n   * Gets the total duration of time across all beats in this bar.\n   */\n  get duration(): Fraction {\n    let total = ZERO;\n    for (let i = 0; i < this.beatLengths.length; i++) {\n      total = total.plus(this.beatLengths[i].timesNum(this.beatCounts[i] || 1));\n    }\n    return total;\n  }\n}\n\n/**\n * Represents a complete rhythmic cycle pattern composed of bars.\n * In carnatic music, this typically represents a tala.\n */\nexport class Cycle extends TimedEntity {\n  readonly TYPE: string = \"Cycle\";\n\n  /** Name of the cycle (e.g., \"Adi Thalam\") */\n  name: string;\n\n  /** The bars that make up this cycle */\n  bars: Bar[];\n\n  /**\n   * Default cycle representing Adi Thalam (4+2+2 structure).\n   */\n  static readonly DEFAULT = new Cycle({\n    name: \"Adi Thalam\",\n    bars: [\n      new Bar({ name: \"Laghu\", beatLengths: [1, 1, 1, 1] }),\n      new Bar({ name: \"Dhrutam\", beatLengths: [1, 1] }),\n      new Bar({ name: \"Dhrutam\", beatLengths: [1, 1] }),\n    ],\n  });\n\n  /**\n   * Creates a new Cycle.\n   * @param config Configuration object containing name and bars\n   */\n  constructor(config: null | { name?: string; bars?: Bar[] } = null) {\n    super((config = config || {}));\n    this.name = config.name || \"\";\n    this.bars = config.bars || [];\n  }\n\n  /**\n   * Returns a debug-friendly representation of this Cycle.\n   * @returns An object containing debug information\n   */\n  debugValue(): any {\n    return { ...super.debugValue(), name: name, bars: this.bars.map((p) => p.debugValue()) };\n  }\n\n  /**\n   * Gets all child entities of this Cycle.\n   * @returns An array of child entities (bars)\n   */\n  children(): Entity[] {\n    return this.bars;\n  }\n\n  /**\n   * Checks if this Cycle is equal to another Cycle.\n   * @param another The Cycle to compare with\n   * @returns True if the Cycles are equal, false otherwise\n   */\n  equals(another: this): boolean {\n    if (!super.equals(another)) {\n      return false;\n    }\n    if (this.bars.length != another.bars.length) return false;\n    for (let i = 0; i < this.bars.length; i++) {\n      if (!this.bars[i].equals(another.bars[i])) return false;\n    }\n    return true;\n  }\n\n  /**\n   * Given a global beat index, returns the position within the cycle.\n   *\n   * @param globalIndex The global beat index\n   * @returns A tuple containing [cycle number, position, start offset]\n   *         - cycle: The nth cycle in which the beat lies\n   *         - position: [barIndex, beatIndex, instance] within the cycle\n   *         - startOffset: Offset of the beat at this global index\n   */\n  getAtIndex(globalIndex: number): [number, CyclePosition, Fraction] {\n    let cycle = 0;\n    while (globalIndex < 0) {\n      globalIndex += this.totalBeatCount;\n      cycle--;\n    }\n    if (globalIndex >= this.totalBeatCount) {\n      cycle = Math.floor(globalIndex / this.totalBeatCount);\n    }\n    globalIndex = globalIndex % this.totalBeatCount;\n    let offset = ZERO;\n    for (let barIndex = 0; barIndex < this.bars.length; barIndex++) {\n      const bar = this.bars[barIndex];\n      if (globalIndex >= bar.totalBeatCount) {\n        globalIndex -= bar.totalBeatCount;\n        offset = offset.plus(bar.duration);\n      } else {\n        // this is the bar!\n        for (let beatIndex = 0; beatIndex < bar.beatCount; beatIndex++) {\n          const beatLength = bar.beatLengths[beatIndex];\n          const beatCount = bar.beatCounts[beatIndex] || 1;\n          if (globalIndex >= beatCount) {\n            globalIndex -= beatCount;\n            offset = offset.plus(beatLength.timesNum(beatCount));\n          } else {\n            // this is it\n            const instance = globalIndex;\n            return [cycle, [barIndex, beatIndex, instance], offset.plus(beatLength.timesNum(instance))];\n          }\n        }\n      }\n    }\n    throw new Error(\"Should not be here!\");\n  }\n\n  /**\n   * Given a global offset, returns the position within the cycle.\n   *\n   * @param globalOffset The global time offset\n   * @returns A tuple containing [cycle number, position, note offset, global index]\n   *         - cycle: The nth cycle in which the offset lies\n   *         - position: [barIndex, beatIndex, instance] within the cycle\n   *         - startOffset: The note offset within the beat\n   *         - globalIndex: The beat index within the entire cycle\n   */\n  getPosition(globalOffset: Fraction): [number, CyclePosition, Fraction, number] {\n    const duration = this.duration;\n    let cycleNum = 0;\n    if (globalOffset.isLT(ZERO)) {\n      while (globalOffset.isLT(ZERO)) {\n        cycleNum--;\n        globalOffset = globalOffset.plus(duration);\n      }\n    } else if (globalOffset.isGTE(duration)) {\n      const realOffset = globalOffset.mod(duration);\n      globalOffset = globalOffset.minus(realOffset).divby(duration);\n      TSU.assert(globalOffset.isWhole);\n      cycleNum = globalOffset.floor;\n      globalOffset = realOffset;\n    }\n\n    // here globalOffset is positive and >= 0 and < this.duration\n    let globalIndex = 0;\n    for (let barIndex = 0; barIndex < this.bars.length; barIndex++) {\n      const bar = this.bars[barIndex];\n      const barDuration = bar.duration;\n      if (globalOffset.isGTE(barDuration)) {\n        globalOffset = globalOffset.minus(barDuration);\n      } else {\n        // this is the bar!\n        for (let beatIndex = 0; beatIndex < bar.beatCount; beatIndex++) {\n          const beatLength = bar.beatLengths[beatIndex];\n          const beatCount = bar.beatCounts[beatIndex] || 1;\n          for (let instance = 0; instance < beatCount; instance++, globalIndex++) {\n            if (globalOffset.isGTE(beatLength)) {\n              globalOffset = globalOffset.minus(beatLength);\n            } else {\n              // this is it\n              return [cycleNum, [barIndex, beatIndex, instance], globalOffset, globalIndex];\n            }\n          }\n        }\n      }\n      globalIndex += bar.totalBeatCount;\n    }\n\n    throw new Error(\"Should not be here!\");\n  }\n\n  /**\n   * Creates an iterator that yields beats in sequence from a starting position.\n   *\n   * @param startBar The starting bar index, defaults to 0\n   * @param startBeat The starting beat index, defaults to 0\n   * @param startInstance The starting instance index, defaults to 0\n   * @returns A generator that yields [position, beat length] pairs\n   */\n  *iterateBeats(startBar = 0, startBeat = 0, startInstance = 0): CycleIterator {\n    let barIndex = startBar;\n    let beatIndex = startBeat;\n    let instanceIndex = startInstance;\n    while (true) {\n      const currBar = this.bars[barIndex];\n      yield [[barIndex, beatIndex, instanceIndex], currBar.beatLengths[beatIndex]];\n      instanceIndex++;\n      if (!currBar.beatCounts[beatIndex] || instanceIndex >= currBar.beatCounts[beatIndex]) {\n        instanceIndex = 0;\n        beatIndex++;\n        if (beatIndex >= currBar.beatLengths.length) {\n          beatIndex = 0;\n          barIndex++;\n          if (barIndex >= this.bars.length) {\n            barIndex = 0;\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Copies the properties of this Cycle to another Cycle.\n   * @param another The target Cycle to copy properties to\n   */\n  copyTo(another: this): void {\n    super.copyTo(another);\n    another.name = this.name;\n    another.bars = this.bars.map((x) => x.clone());\n  }\n\n  /**\n   * Gets the number of unique beats in this cycle (irrespective of instances).\n   */\n  get beatCount(): number {\n    let out = 0;\n    for (const bar of this.bars) out += bar.beatCount;\n    return out;\n  }\n\n  /**\n   * Gets the total number of beat instances in this cycle.\n   */\n  get totalBeatCount(): number {\n    let out = 0;\n    for (const bar of this.bars) out += bar.totalBeatCount;\n    return out;\n  }\n\n  /**\n   * Gets the total duration of time across all bars in this cycle.\n   */\n  get duration(): Fraction {\n    return this.bars.reduce((x, y) => x.plus(y.duration), ZERO);\n  }\n}\n","import * as TSU from \"@panyam/tsutils\";\nimport { GridModel } from \"../grids\";\nimport { Line } from \"../core\";\n\nexport class LineView {\n  // The beat layout associated with the layout params of this Line\n  // at this point beats have already been added to the right columns\n  gridModel: GridModel;\n  gElem: SVGGElement;\n\n  // Space between two roles (within the same row)\n  roleSpacing = 20;\n\n  // Vertical space between two rows (of multiple roles)\n  rowSpacing = 10;\n\n  constructor(\n    public readonly rootElement: SVGSVGElement,\n    public line: Line,\n    public readonly config?: any,\n  ) {\n    // create the gElem for wrapping and adjusting to size\n    this.gElem = TSU.DOM.createSVGNode(\"g\", {\n      parent: this.rootElement,\n      attrs: {\n        class: \"lineRoot\",\n        id: \"lineRoot\" + this.line.uuid,\n      },\n    }) as SVGGElement;\n  }\n\n  wrapToSize(): void {\n    const bbox = (this.gElem as SVGSVGElement).getBBox();\n    // set the size of the svg\n    this.rootElement.setAttribute(\"width\", \"\" + (4 + bbox.width));\n    this.rootElement.setAttribute(\"height\", \"\" + (15 + bbox.height));\n    this.gElem.setAttribute(\"transform\", `translate(${4 - bbox.x}, ${4 - bbox.y})`);\n  }\n\n  get prefSize(): TSU.Geom.Size {\n    const bbox = this.rootElement.getBBox();\n    // return new TSU.Geom.Size(4 + bbox.width + bbox.x, 4 + bbox.y + bbox.height);\n    return new TSU.Geom.Size(4 + bbox.width, 4 + bbox.height);\n  }\n}\n","import * as TSU from \"@panyam/tsutils\";\nimport { Atom, Group, Literal, AtomType, Note, Space, Syllable, Marker } from \"../core\";\nimport {\n  LeafAtomView as LeafAtomViewBase,\n  GroupView as GroupViewBase,\n  AtomView,\n  Embelishment,\n  ElementShape,\n} from \"../shapes\";\nimport {\n  OctaveIndicator,\n  Kampitham,\n  Nokku,\n  Spuritham,\n  Prathyagatham,\n  Orikkai,\n  Odukkal,\n  Raavi,\n  Kandippu,\n  Vaali,\n  Jaaru,\n  GroupBracket,\n} from \"./embelishments\";\nimport { GamakaType } from \"./gamakas\";\n\nexport class GroupView extends GroupViewBase {\n  /** Height reserved for bracket line (lineOffset + circleRadius + padding) */\n  static readonly BRACKET_HEIGHT = 8;\n\n  createAtomView(atom: Atom): AtomView {\n    // Propagate depth + 1 to child atoms\n    return createAtomView(this.groupElement, atom, this.defaultToNotes, 0.7, this.depth + 1);\n  }\n\n  /**\n   * Creates embellishments for this group, including the bracket line\n   * that serves as the top border of this group container.\n   */\n  protected createEmbelishments(): Embelishment[] {\n    const embelishments = super.createEmbelishments();\n    // Add bracket line for nested groups (depth >= 1)\n    if (this.depth >= 1) {\n      embelishments.push(new GroupBracket(this));\n    }\n    return embelishments;\n  }\n\n  /**\n   * Calculates the minimum size of this group, including space for the bracket line.\n   * The bracket line adds height for nested groups (depth >= 1).\n   */\n  protected refreshMinSize(): TSU.Geom.Size {\n    const baseSize = super.refreshMinSize();\n\n    // Add height for bracket line if this is a nested group\n    if (this.depth >= 1) {\n      return new TSU.Geom.Size(baseSize.width, baseSize.height + GroupView.BRACKET_HEIGHT * this.scaleFactor);\n    }\n\n    return baseSize;\n  }\n}\n\nexport abstract class LeafAtomView extends LeafAtomViewBase {\n  leftSlot: Embelishment[] = [];\n  topSlot: Embelishment[] = [];\n  rightSlot: Embelishment[] = [];\n  bottomSlot: Embelishment[] = [];\n  glyph: ElementShape;\n\n  // Spaces required before and after to accomodate for left and right slots\n  protected postSpacingSpan: SVGTSpanElement;\n  // Sometimes this.element may not be the root element if we need spacings\n  // the rootElement is the top of the chain\n  protected rootGroup: ElementShape;\n  protected rootText: ElementShape;\n\n  abstract get glyphLabel(): string;\n\n  protected refreshBBox(): TSU.Geom.Rect {\n    return TSU.DOM.svgBBox(this.rootGroup.element);\n  }\n\n  protected refreshMinSize(): TSU.Geom.Size {\n    const out = { ...this.rootText.minSize };\n    const totalWidth =\n      this.leftSlot.reduce((a, b) => a + b.minSize.width, 0) +\n      this.rightSlot.reduce((a, b) => a + b.minSize.width, 0) +\n      this.leftSlot.length + // Padding of 1\n      this.rightSlot.length; // Padding of 1\n    const totalHeight =\n      this.topSlot.reduce((a, b) => a + b.minSize.height, 0) +\n      this.bottomSlot.reduce((a, b) => a + b.minSize.height, 0);\n    out.width += totalWidth;\n    out.height += totalHeight;\n    // if (this.postSpacingSpan) out.width += this.postSpacingSpan.getBBox().width;\n    return out;\n  }\n\n  /**\n   * Returns the horizontal offset from the atom's origin to where the note glyph starts.\n   * This is the total width of left embellishments (e.g., Jaaru symbols).\n   */\n  get glyphOffset(): number {\n    return (\n      this.leftSlot.reduce((a, b) => a + b.minSize.width, 0) + this.leftSlot.length // Padding of 1 per embellishment\n    );\n  }\n\n  protected updateBounds(\n    x: null | number,\n    y: null | number,\n    w: null | number,\n    h: null | number,\n  ): [number | null, number | null, number | null, number | null] {\n    return [x, y, NaN, NaN];\n  }\n\n  protected layoutElements(): void {\n    // Lays out all the child elements locally\n    const textSize = this.rootText.minSize;\n    // assume text is at 0,0 and lay things around it\n\n    // now layout leftSlots\n    let currX = 0;\n    let currY = this.hasY ? this.y : 0;\n    // place left embelishments\n    for (const emb of this.leftSlot) {\n      emb.x = currX;\n      emb.refreshLayout();\n      currX += emb.minSize.width + 1;\n    }\n\n    // now place the text\n    const textX = currX;\n    this.rootText.x = currX;\n    this.rootText.refreshLayout();\n\n    // And right embelishments\n    currX += this.rootText.minSize.width;\n    for (const emb of this.rightSlot) {\n      emb.x = currX;\n      emb.refreshLayout();\n      currX += emb.minSize.width + 1;\n    }\n\n    // layout top and bottom if x or y has changed\n    const gminSize = this.glyph.minSize;\n\n    // top embelishments\n    const glyphX = textX + this.glyph.x;\n    const glyphY = this.glyph.y;\n    currY = glyphY - this.glyph.minSize.height + 5;\n    for (const emb of this.topSlot) {\n      const bb = emb.minSize;\n      emb.setBounds(glyphX + (gminSize.width - bb.width) / 2, currY - bb.height, null, null, true);\n      currY = emb.y;\n    }\n\n    // bottom embelishments\n    currY = glyphY + 7;\n    for (const emb of this.bottomSlot) {\n      const bb = emb.minSize;\n      emb.setBounds(glyphX + (gminSize.width - bb.width) / 2, currY, null, null, true);\n      currY = emb.y + bb.height;\n    }\n    this.invalidateBounds();\n  }\n\n  refreshLayout(): void {\n    // TODO - move this code out to refreshLayout?\n    // set the glyphs Y first so we can layout others\n    this.layoutElements();\n    this.rootGroup.element.setAttribute(\"transform\", \"translate(\" + this.x + \",\" + this.y + \")\");\n  }\n\n  protected addEmbelishment(slot: Embelishment[], emb: Embelishment): void {\n    slot.push(emb);\n    // this.addShape(emb);\n  }\n\n  /**\n   * Orders embelishments and creates their views.\n   */\n  orderEmbelishments(): void {\n    const atom = this.leafAtom;\n    if (atom.TYPE != AtomType.SYLLABLE && atom.TYPE != AtomType.NOTE) {\n      return;\n    }\n    const lit = atom as Literal;\n    if (lit.embelishments.length == 0) return;\n    for (const emb of lit.embelishments) {\n      switch (emb.type) {\n        case GamakaType.Kampitham:\n          this.addEmbelishment(this.topSlot, new Kampitham(this));\n          break;\n        case GamakaType.Nokku:\n          this.addEmbelishment(this.topSlot, new Nokku(this));\n          break;\n        case GamakaType.Spuritham:\n          this.addEmbelishment(this.topSlot, new Spuritham(this));\n          break;\n        case GamakaType.Prathyagatham:\n          this.addEmbelishment(this.topSlot, new Prathyagatham(this));\n          break;\n        case GamakaType.Orikkai:\n          this.addEmbelishment(this.topSlot, new Orikkai(this));\n          break;\n        case GamakaType.Odukkal:\n          this.addEmbelishment(this.topSlot, new Odukkal(this));\n          break;\n        case GamakaType.Aahaatam_Raavi:\n          this.addEmbelishment(this.topSlot, new Raavi(this));\n          break;\n        case GamakaType.Aahaatam_Kandippu:\n          this.addEmbelishment(this.topSlot, new Kandippu(this));\n          break;\n        case GamakaType.Vaali:\n          this.addEmbelishment(this.topSlot, new Vaali(this));\n          break;\n        case GamakaType.Jaaru_Eetra:\n        case GamakaType.Jaaru_Irakka:\n          this.addEmbelishment(this.leftSlot, new Jaaru(emb, this));\n          break;\n      }\n    }\n  }\n\n  embRoot(): SVGGraphicsElement {\n    return this.rootGroup.element;\n  }\n\n  needsRootElement(): boolean {\n    return true; // this.rightSlot.length > 0 || this.leafAtom.beforeRest;\n  }\n\n  createElements(parent: SVGGraphicsElement): void {\n    // Create the glyph element first before anything\n    // this allows embelishments to get early access to this element\n    this.createGlyphRoot(parent);\n    this.createGlyphElement();\n    // Order embelishments (without creating any views)\n    this.orderEmbelishments();\n    this.createPostSpacingElement();\n    this.invalidateBounds();\n  }\n\n  protected createGlyphRoot(parent: SVGGraphicsElement): void {\n    this.rootGroup = new ElementShape(\n      TSU.DOM.createSVGNode(\"g\", {\n        doc: document,\n        parent: parent,\n        attrs: {\n          atomid: this.leafAtom.uuid,\n          class: \"atomViewRootGroup\",\n          id: \"atomViewRootGroup\" + this.leafAtom.uuid,\n        },\n      }),\n    );\n    this.rootText = new ElementShape(\n      TSU.DOM.createSVGNode(\"text\", {\n        doc: document,\n        parent: this.rootGroup.element,\n        attrs: {\n          atomid: this.leafAtom.uuid,\n          class: \"atomViewTextRoot\",\n          id: \"atomViewTextRoot\" + this.leafAtom.uuid,\n        },\n      }),\n    );\n  }\n\n  protected createGlyphElement(): void {\n    const atom = this.leafAtom;\n    this.glyph = new ElementShape(\n      TSU.DOM.createSVGNode(\"tspan\", {\n        doc: document,\n        parent: this.rootText.element,\n        attrs: {\n          atomid: atom.uuid,\n          id: \"atomGlyph\" + atom.uuid,\n        },\n        text: this.glyphLabel, // + (note.beforeRest ? \" - \" : \" \"),\n      }),\n    );\n  }\n\n  protected createPostSpacingElement(): void {\n    if (this.leafAtom.beforeRest) {\n      this.postSpacingSpan = TSU.DOM.createSVGNode(\"tspan\", {\n        doc: document,\n        parent: this.rootText.element,\n        attrs: {\n          atomid: this.leafAtom.uuid,\n          id: \"postSpacing\" + this.leafAtom.uuid,\n        },\n        text: this.leafAtom.beforeRest ? \" - \" : \"  \",\n      });\n    }\n  }\n}\n\nclass SpaceView extends LeafAtomView {\n  get glyphLabel(): string {\n    if (this.space.isSilent) return \" \";\n    if (this.space.duration.isOne) return \",\";\n    if (this.space.duration.cmpNum(2) == 0) return \";\";\n    return \"_\";\n  }\n\n  get space(): Space {\n    return this.leafAtom as Space;\n  }\n}\n\nclass NoteView extends LeafAtomView {\n  protected shiftElement: SVGTSpanElement;\n  get glyphLabel(): string {\n    return this.note.value;\n  }\n\n  needsRootElement(): boolean {\n    return true; // this.note.shift == true || this.note.shift != 0 || super.needsRootElement();\n  }\n\n  protected createGlyphElement(): void {\n    super.createGlyphElement();\n    if (this.note.shift == true || this.note.shift != 0) {\n      this.shiftElement = TSU.DOM.createSVGNode(\"tspan\", {\n        doc: document,\n        parent: this.rootText.element,\n        attrs: {\n          atomid: this.note.uuid,\n          class: \"noteShiftTSpan\",\n          id: \"noteShift\" + this.note.uuid,\n          \"baseline-shift\": \"sub\",\n        },\n        text: (this.note.shift == true ? \"*\" : this.note.shift) + \" \",\n      });\n    }\n  }\n\n  protected moveGlyphToRoot(): void {\n    // super.moveGlyphToRoot();\n    if (this.shiftElement) {\n      this.rootGroup.element.appendChild(this.shiftElement);\n    }\n  }\n\n  orderEmbelishments(): void {\n    const note = this.note;\n    // create the embelishments if needed\n    if (note.octave > 0) {\n      this.topSlot.push(new OctaveIndicator(this, note));\n    } else if (this.note.octave < 0) {\n      this.bottomSlot.push(new OctaveIndicator(this, note));\n    }\n    super.orderEmbelishments();\n  }\n\n  get note(): Note {\n    return this.leafAtom as Note;\n  }\n}\n\nclass SyllableView extends LeafAtomView {\n  get glyphLabel(): string {\n    return this.syllable.value;\n  }\n\n  get syllable(): Syllable {\n    return this.leafAtom as Syllable;\n  }\n}\n\n/**\n * View for rendering Marker atoms (annotations like \\@label).\n * Displays the marker's text content.\n */\nclass MarkerView extends LeafAtomView {\n  get glyphLabel(): string {\n    return this.marker.text;\n  }\n\n  get marker(): Marker {\n    return this.leafAtom as Marker;\n  }\n}\n\n/**\n * Placeholder view for unknown/unhandled atom types.\n * Shows an error indicator instead of crashing the renderer.\n */\nclass UnknownAtomView extends LeafAtomView {\n  get glyphLabel(): string {\n    // Show the atom type in brackets as a visual error indicator\n    return `[?${this.leafAtom.TYPE}]`;\n  }\n}\n\nexport function createAtomView(\n  parent: SVGGraphicsElement,\n  atom: Atom,\n  litDefaultsToNote = false,\n  groupViewScale = 1.0,\n  depth = 0,\n): AtomView {\n  let out: AtomView;\n  switch (atom.TYPE) {\n    // Dealing with leaf atoms\n    case AtomType.SPACE:\n      out = new SpaceView(atom as Space);\n      break;\n    case AtomType.SYLLABLE:\n      out = new SyllableView(atom as Syllable);\n      break;\n    case AtomType.NOTE:\n      out = new NoteView(atom as Note);\n      break;\n    case AtomType.LITERAL:\n      if (litDefaultsToNote) {\n        const lit = Note.fromLit(atom as Note);\n        out = new NoteView(lit);\n      } else {\n        const lit = Syllable.fromLit(atom as Syllable);\n        out = new SyllableView(lit);\n      }\n      break;\n    case AtomType.GROUP:\n      out = new GroupView(atom as Group);\n      (out as GroupView).defaultToNotes = litDefaultsToNote;\n      (out as GroupView).scaleFactor = groupViewScale;\n      break;\n    case AtomType.MARKER:\n      out = new MarkerView(atom as Marker);\n      break;\n    default:\n      // Unknown atom type - show placeholder instead of crashing\n      console.warn(`Unknown atom type: ${atom.TYPE} - rendering placeholder`);\n      out = new UnknownAtomView(atom as any);\n  }\n  out.depth = depth;\n  out.createElements(parent);\n  return out;\n}\n","import * as TSU from \"@panyam/tsutils\";\n\n/**\n * Parameter type for commands and markers.\n * Used by both Command and Marker classes.\n */\nexport type CmdParam = { key: TSU.Nullable<string>; value: any };\n\n/**\n * Interface for entities that have parameters.\n */\nexport interface HasParams {\n  params: CmdParam[];\n}\n\n/**\n * Mixin that adds parameter handling to a class.\n * Provides getParam and getParamAt methods.\n * Works with both concrete and abstract base classes.\n */\n// eslint-disable-next-line @typescript-eslint/explicit-function-return-type\nexport function ParamsMixin<T extends abstract new (...args: any[]) => object>(Base: T) {\n  abstract class Mixed extends Base implements HasParams {\n    params: CmdParam[] = [];\n\n    /**\n     * Gets a parameter value by key.\n     * @param key The parameter key to look for\n     * @returns The parameter value, or null if not found\n     */\n    getParam(key: string): any {\n      return this.params.find((p) => p.key === key)?.value ?? null;\n    }\n\n    /**\n     * Gets a parameter value by index (for positional params).\n     * @param index The parameter index\n     * @returns The parameter value, or null if not found\n     */\n    getParamAt(index: number): any {\n      return this.params[index]?.value ?? null;\n    }\n  }\n  return Mixed;\n}\n\n/**\n * A common Entity base class with support for unique IDs, parent references,\n * copying, and debug info. This serves as the foundation for all entities\n * in the notation system.\n *\n * Note: Child management is intentionally NOT included here. Each container type\n * (BlockContainer, Line, Group, etc.) defines its own child management with\n * appropriate types.\n *\n * Observer Pattern:\n * Each observable entity subclass (Group, Role, Line, Block) manages its own\n * typed observer list. This provides type safety and clear contracts between\n * observables and observers.\n */\nexport class Entity {\n  readonly TYPE: string = \"Entity\";\n\n  private static counter = 0;\n  /** Unique identifier for this entity */\n  readonly uuid = Entity.counter++;\n  /** Parent entity in the tree hierarchy */\n  protected _parent: TSU.Nullable<Entity> = null;\n\n  /**\n   * Whether events/observer notifications are enabled for this entity.\n   * Subclasses check this flag before notifying observers.\n   */\n  protected _eventsEnabled = false;\n\n  /**\n   * Creates a new Entity.\n   * @param config Optional configuration object\n   */\n  constructor(config: any = null) {\n    config = config || {};\n    if (config.metadata) throw new Error(\"See where metadata is being passed\");\n  }\n\n  /**\n   * Enables observer notifications for this entity.\n   * Call this to activate change notifications on entities that support them.\n   * @returns This entity for method chaining\n   */\n  enableEvents(): this {\n    this._eventsEnabled = true;\n    return this;\n  }\n\n  /**\n   * Disables observer notifications for this entity.\n   * @returns This entity for method chaining\n   */\n  disableEvents(): this {\n    this._eventsEnabled = false;\n    return this;\n  }\n\n  /**\n   * Checks if events/observer notifications are enabled.\n   */\n  get eventsEnabled(): boolean {\n    return this._eventsEnabled;\n  }\n\n  /**\n   * Gets the parent entity.\n   */\n  get parent(): TSU.Nullable<Entity> {\n    return this._parent;\n  }\n\n  /**\n   * Sets the parent entity.\n   * @param parent The parent entity to set\n   */\n  setParent(parent: TSU.Nullable<Entity>): void {\n    this._parent = parent;\n  }\n\n  /**\n   * Returns a debug-friendly representation of this entity.\n   * Usually overridden by children to add more debug info.\n   * @returns An object containing debug information\n   */\n  debugValue(): any {\n    return { type: this.TYPE };\n  }\n\n  /**\n   * Returns a simple string representation of this Entity.\n   * @returns A string representation\n   */\n  toString(): string {\n    return `Entity(id = ${this.uuid})`;\n  }\n\n  /**\n   * Checks if this Entity is equal to another Entity.\n   * @param another The Entity to compare with\n   * @param expect Optional parameter\n   * @returns True if the Entities are equal, false otherwise\n   */\n  equals(another: this, expect = false): boolean {\n    if (this.TYPE != another.TYPE) return false;\n    return true;\n  }\n\n  /**\n   * Creates a clone of this entity.\n   * Cloning is a two-part process:\n   * 1. Creation of a new instance via this.newInstance()\n   * 2. Copying of data into the new instance via this.copyTo()\n   *\n   * @returns A new instance of the same type with the same properties\n   */\n  clone(): this {\n    const out = this.newInstance();\n    this.copyTo(out);\n    return out;\n  }\n\n  /**\n   * Copies information about this instance into another instance of the same type.\n   * @param another The target instance to copy properties to\n   */\n  copyTo(another: this): void {\n    // Subclasses override to copy their specific properties\n  }\n\n  /**\n   * First part of the cloning process where the instance is created.\n   * @returns A new instance of the same type\n   */\n  protected newInstance(): this {\n    return new (this.constructor as any)();\n  }\n}\n\n/**\n * Music is all about timing! TimedEntities are base of all entities that\n * have a duration. This is an abstract class that all timed entities inherit from.\n */\nexport abstract class TimedEntity extends Entity {\n  readonly TYPE: string = \"TimedEntity\";\n\n  /**\n   * Gets the duration of this entity in terms of beats.\n   * By default, entity durations are readonly.\n   */\n  abstract get duration(): TSU.Num.Fraction;\n\n  /**\n   * Checks if this TimedEntity is equal to another TimedEntity.\n   * @param another The TimedEntity to compare with\n   * @returns True if the TimedEntities are equal, false otherwise\n   */\n  equals(another: this): boolean {\n    return super.equals(another) && this.duration.equals(another.duration);\n  }\n}\n","import { Note } from \"../core\";\n\nexport enum GamakaType {\n  // Kampitam (~)\n  // The oscilation between 2 notes - eg p , S..n S..n S..n\n  Kampitham = \"Kampitham\",\n\n  // Nokku (w)\n  Nokku = \"Nokku\",\n\n  // Spuritham ( / u+2234) - Stress on the second note of a jantai\n  Spuritham = \"Spuritham\",\n\n  // Prathyagatham ( / u+2235) - Similar to reverse of Spuritham (in descending order)\n  Prathyagatham = \"Prathyagatham\",\n\n  // Raavi (^)\n  Aahaatam_Raavi = \"Raavi\",\n\n  // Kandippu ()\n  // eg - Shankarabharanam's S. ,,, n , P ,,,  - where the n is subtle\n  Aahaatam_Kandippu = \"Kandippu\",\n\n  // Vali ( - U+2312)\n  Vaali = \"Vaali\",\n\n  // Odukkal (x):\n  // A veena gamakam where the note itself is stretched more to get the next\n  // note effect (instead of plucking the next note itself).\n  // Not possible where plucking of strings is not possible.\n  // On voice etc it just will sound like an Eetra Jaaru.\n  Odukkal = \"Odukkal\",\n\n  // (/) Ascension from one note to another - eg S / P\n  Jaaru_Eetra = \"EetraJaaru\",\n\n  // (\\) Descending from one note to another - eg P \\ S\n  Jaaru_Irakka = \"IrakkaJaaru\",\n\n  // Orikkai ()\n  // eg S~~ RN N~~S.D  D~~~NP\n  Orikkai = \"Orikkai\",\n}\n\nexport class Gamaka {\n  constructor(public readonly type: GamakaType) {}\n  debugValue(): any {\n    return { type: this.type };\n  }\n}\n\nexport class JaaruGamaka extends Gamaka {\n  constructor(\n    public readonly ascending = true,\n    public readonly startingNote: null | Note = null,\n  ) {\n    super(ascending ? GamakaType.Jaaru_Eetra : GamakaType.Jaaru_Irakka);\n  }\n\n  debugValue(): any {\n    const out = { ...super.debugValue(), ascending: this.ascending };\n    if (this.startingNote) out[\"startingNote\"] = this.startingNote.debugValue();\n    return out;\n  }\n}\n\nexport function parseEmbelishment(value: string): [any, boolean] {\n  value = value.substring(1);\n  if (value == \"\") {\n    return [new Gamaka(GamakaType.Kampitham), true];\n  } else if (value == \"^\") {\n    return [new Gamaka(GamakaType.Aahaatam_Raavi), true];\n  } else if (value == \"~\") {\n    return [new Gamaka(GamakaType.Vaali), true];\n  } else if (value == \"w\" || value == \"W\") {\n    return [new Gamaka(GamakaType.Nokku), true];\n  } else if (value == \"\" || value == \":-\") {\n    return [new Gamaka(GamakaType.Spuritham), true];\n  } else if (value == \"\" || value == \"-:\") {\n    return [new Gamaka(GamakaType.Prathyagatham), true];\n  } else if (value == \"\" || value == \"./\" || value == \".\\\\\") {\n    return [new Gamaka(GamakaType.Aahaatam_Kandippu), true];\n  } else if (value.endsWith(\"/\")) {\n    value = value.substring(0, value.length - 1).trim();\n    return [new JaaruGamaka(true, value.length > 0 ? new Note(value) : null), true];\n  } else if (value.endsWith(\"\\\\\")) {\n    value = value.substring(0, value.length - 1);\n    return [new JaaruGamaka(false, value.length > 0 ? new Note(value) : null), true];\n  } else if (value == \"x\") {\n    return [new Gamaka(GamakaType.Odukkal), true];\n  } else if (value == \"\" || value == \"Y\") {\n    return [new Gamaka(GamakaType.Orikkai), true];\n  }\n  // throw new Error(\"Invalid carnatic embelishment: \" + value);\n  return [null, false];\n}\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../node_modules/.pnpm/css-loader@7.1.2_webpack@5.104.1/node_modules/css-loader/dist/runtime/sourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../node_modules/.pnpm/css-loader@7.1.2_webpack@5.104.1/node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `:root{--notation-stroke-color: black;--notation-fill-color: transparent;--notation-text-color: #1a1a1a;--notation-border-color: gray;--notation-stroke-width: 1;--notation-bar-line-width: 1;--notation-line-padding: 5px;--notation-annotation-padding: 10px}:root.dark,[data-theme=dark]{--notation-stroke-color: #e5e5e5;--notation-fill-color: transparent;--notation-text-color: #f0f0f0;--notation-border-color: #555}@media(prefers-color-scheme: dark){:root:not(.light):not([data-theme=light]){--notation-stroke-color: #e5e5e5;--notation-fill-color: transparent;--notation-text-color: #f0f0f0;--notation-border-color: #555}}.notation-octave-dot{stroke:var(--notation-stroke-color);stroke-width:var(--notation-stroke-width)}.bar-start-line,.bar-end-line{stroke:var(--notation-stroke-color);stroke-width:var(--notation-bar-line-width)}.notation-jaaru-path{stroke:var(--notation-stroke-color);fill:var(--notation-fill-color)}.group-bracket-line{stroke:var(--notation-stroke-color);stroke-width:1}.group-bracket-circle{fill:var(--notation-stroke-color);stroke:none}.group-bracket{opacity:.8}.notationsContentRootTable text,.atomViewTextRoot,.notation-embelishment-label{fill:var(--notation-text-color)}.notationsContentRootTable,.rawBlockContentCell,.rawBlockContentCell *{color:var(--notation-text-color)}.role_sw text{fill:#2563eb}:root.dark .role_sw text,[data-theme=dark] .role_sw text{fill:#ef4444}@media(prefers-color-scheme: dark){:root:not(.light):not([data-theme=light]) .role_sw text{fill:#ef4444}}.lineRow{border:none}.lineAnnotationCell{padding:0px;padding-left:10px;padding-right:10px;padding-top:10px;vertical-align:top}.lineContentCell{padding:0px;padding-top:5px;padding-bottom:5px}.rawBlockRow{border:none}.rawBlockContentCell{padding-top:5px;padding-bottom:5px}.notationsContentRootTable{border-top:solid 1px var(--notation-border-color);width:100%}`, \"\",{\"version\":3,\"sources\":[\"webpack://./styles/NotationView.scss\"],\"names\":[],\"mappings\":\"AAIA,MAEE,8BAAA,CACA,kCAAA,CACA,8BAAA,CACA,6BAAA,CAGA,0BAAA,CACA,4BAAA,CAGA,4BAAA,CACA,mCAAA,CAIF,6BAEE,gCAAA,CACA,kCAAA,CACA,8BAAA,CACA,6BAAA,CAIF,mCACE,0CACE,gCAAA,CACA,kCAAA,CACA,8BAAA,CACA,6BAAA,CAAA,CASJ,qBACE,mCAAA,CACA,yCAAA,CAIF,8BAEE,mCAAA,CACA,2CAAA,CAIF,qBACE,mCAAA,CACA,+BAAA,CAIF,oBACE,mCAAA,CACA,cAAA,CAGF,sBACE,iCAAA,CACA,WAAA,CAGF,eACE,UAAA,CAIF,+EAGE,+BAAA,CAIF,uEAGE,gCAAA,CAQF,cACE,YAAA,CAIF,yDAEE,YAAA,CAIF,mCACE,wDACE,YAAA,CAAA,CAQJ,SACE,WAAA,CAGF,oBACE,WAAA,CACA,iBAAA,CACA,kBAAA,CACA,gBAAA,CACA,kBAAA,CAGF,iBACE,WAAA,CACA,eAAA,CACA,kBAAA,CAIF,aACE,WAAA,CAGF,qBACE,eAAA,CACA,kBAAA,CAMF,2BACE,iDAAA,CACA,UAAA\",\"sourcesContent\":[\"/* ========================================\\n   CSS Custom Properties (Theme Variables)\\n   ======================================== */\\n\\n:root {\\n  /* Colors */\\n  --notation-stroke-color: black;\\n  --notation-fill-color: transparent;\\n  --notation-text-color: #1a1a1a;\\n  --notation-border-color: gray;\\n\\n  /* Strokes */\\n  --notation-stroke-width: 1;\\n  --notation-bar-line-width: 1;\\n\\n  /* Spacing (can be overridden) */\\n  --notation-line-padding: 5px;\\n  --notation-annotation-padding: 10px;\\n}\\n\\n/* Dark mode */\\n:root.dark,\\n[data-theme=\\\"dark\\\"] {\\n  --notation-stroke-color: #e5e5e5;\\n  --notation-fill-color: transparent;\\n  --notation-text-color: #f0f0f0;\\n  --notation-border-color: #555;\\n}\\n\\n/* System preference fallback */\\n@media (prefers-color-scheme: dark) {\\n  :root:not(.light):not([data-theme=\\\"light\\\"]) {\\n    --notation-stroke-color: #e5e5e5;\\n    --notation-fill-color: transparent;\\n    --notation-text-color: #f0f0f0;\\n    --notation-border-color: #555;\\n  }\\n}\\n\\n/* ========================================\\n   SVG Element Styles\\n   ======================================== */\\n\\n/* Octave indicator dots */\\n.notation-octave-dot {\\n  stroke: var(--notation-stroke-color);\\n  stroke-width: var(--notation-stroke-width);\\n}\\n\\n/* Bar lines (start and end) */\\n.bar-start-line,\\n.bar-end-line {\\n  stroke: var(--notation-stroke-color);\\n  stroke-width: var(--notation-bar-line-width);\\n}\\n\\n/* Jaaru (glide) paths */\\n.notation-jaaru-path {\\n  stroke: var(--notation-stroke-color);\\n  fill: var(--notation-fill-color);\\n}\\n\\n/* Group bracket lines - top border of nested group containers */\\n.group-bracket-line {\\n  stroke: var(--notation-stroke-color);\\n  stroke-width: 1;\\n}\\n\\n.group-bracket-circle {\\n  fill: var(--notation-stroke-color);\\n  stroke: none;\\n}\\n\\n.group-bracket {\\n  opacity: 0.8;\\n}\\n\\n/* Text elements - target all SVG text within notation */\\n.notationsContentRootTable text,\\n.atomViewTextRoot,\\n.notation-embelishment-label {\\n  fill: var(--notation-text-color);\\n}\\n\\n/* HTML text elements (metadata, headings, markdown content) */\\n.notationsContentRootTable,\\n.rawBlockContentCell,\\n.rawBlockContentCell * {\\n  color: var(--notation-text-color);\\n}\\n\\n/* ========================================\\n   Role-specific Styles\\n   ======================================== */\\n\\n/* Swara (Sw) role - blue in light theme for distinction from Sahitya */\\n.role_sw text {\\n  fill: #2563eb; /* Blue-600 */\\n}\\n\\n/* Dark mode - red for swara */\\n:root.dark .role_sw text,\\n[data-theme=\\\"dark\\\"] .role_sw text {\\n  fill: #ef4444; /* Red-500 */\\n}\\n\\n/* System preference fallback for dark mode */\\n@media (prefers-color-scheme: dark) {\\n  :root:not(.light):not([data-theme=\\\"light\\\"]) .role_sw text {\\n    fill: #ef4444; /* Red-500 */\\n  }\\n}\\n\\n/* ========================================\\n   Layout Styles\\n   ======================================== */\\n\\n.lineRow {\\n  border: none;\\n}\\n\\n.lineAnnotationCell {\\n  padding: 0px;\\n  padding-left: 10px;\\n  padding-right: 10px;\\n  padding-top: 10px;\\n  vertical-align: top;\\n}\\n\\n.lineContentCell {\\n  padding: 0px;\\n  padding-top: 5px;\\n  padding-bottom: 5px;\\n  // border-bottom: solid 1px gray;\\n}\\n\\n.rawBlockRow {\\n  border: none;\\n}\\n\\n.rawBlockContentCell {\\n  padding-top: 5px;\\n  padding-bottom: 5px;\\n}\\n\\n.lineRootSVG {\\n}\\n\\n.notationsContentRootTable {\\n  border-top: solid 1px var(--notation-border-color);\\n  width: 100%;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","import * as TSU from \"@panyam/tsutils\";\nimport { LineView } from \"./LineView\";\nimport { Notation, RawBlock, Block, BlockItem, isLine, isBlock, isRawBlock } from \"../notation\";\nimport { Beat, GlobalBeatLayout } from \"../beats\";\nimport { GridCell, GridCellView, GridLayoutGroup, LayoutChangeEvent } from \"../grids\";\nimport { Line } from \"../core\";\nimport { BeatView, MarkerView } from \"./beatviews\";\n\n/**\n * Configuration options for NotationView.\n */\nexport interface NotationViewConfig {\n  /**\n   * Optional shared GridLayoutGroup for column alignment across multiple NotationViews.\n   * When provided, this view will share column widths with other views using the same group.\n   */\n  sharedGridLayoutGroup?: GridLayoutGroup;\n\n  /**\n   * Optional markdown parser for RawBlock content.\n   */\n  markdownParser?: (contents: string) => string;\n}\n\nexport class NotationView {\n  headerElement: HTMLDivElement;\n  notation: Notation;\n  lineViews: LineView[] = [];\n  // Mapping from line id -> list of beats in each of its roles\n  currentSVGElement: SVGSVGElement | null = null;\n  tableElement: HTMLTableElement;\n  markdownParser: (contents: string) => string;\n  _beatLayout: GlobalBeatLayout;\n\n  /** Unsubscribe function for layout change listener */\n  private layoutChangeUnsubscribe: (() => void) | null = null;\n\n  constructor(\n    public readonly rootElement: HTMLElement,\n    public readonly config?: NotationViewConfig,\n  ) {\n    this.loadChildViews();\n    // Default to identity function if no markdown parser provided\n    this.markdownParser = config?.markdownParser ?? ((content) => content);\n  }\n\n  get beatLayout(): GlobalBeatLayout {\n    return this._beatLayout;\n  }\n\n  set beatLayout(beatLayout: GlobalBeatLayout) {\n    this._beatLayout = beatLayout;\n    beatLayout.gridLayoutGroup.getCellView = (cell) => this.viewForBeat(cell);\n  }\n\n  loadChildViews(): void {\n    this.tableElement = TSU.DOM.createNode(\"table\", {\n      parent: this.rootElement,\n      attrs: {\n        class: \"notationsContentRootTable\",\n      },\n    }) as HTMLTableElement;\n  }\n\n  renderNotation(notation: Notation, beatLayout: GlobalBeatLayout): void {\n    this.notation = notation;\n    this.beatLayout = beatLayout;\n    const startTime = performance.now();\n    this.refreshLayout();\n    const layoutTime = performance.now();\n    console.log(`V4 Document, Layout Time: ${layoutTime - startTime}ms`);\n  }\n\n  public addNewRow(id: string, prefix: string, withAnnotation = true): [HTMLElement, HTMLElement] {\n    const tr = TSU.DOM.createNode(\"tr\", {\n      parent: this.tableElement, // parent,\n      attrs: {\n        class: prefix + \"Row\",\n        id: prefix + \"Row\" + id,\n      },\n    });\n    let td1: HTMLElement | null = null;\n    if (withAnnotation) {\n      td1 = TSU.DOM.createNode(\"td\", {\n        parent: tr,\n        attrs: {\n          class: prefix + \"AnnotationCell\",\n          id: prefix + \"Annotation\" + id,\n        },\n      }) as HTMLElement;\n    }\n    const td2 = TSU.DOM.createNode(\"td\", {\n      parent: tr,\n      attrs: {\n        class: prefix + \"ContentCell\",\n        id: prefix + \"Content\" + id,\n        colspan: withAnnotation ? 1 : 2,\n      },\n    }) as HTMLElement;\n    return [td1!, td2];\n  }\n\n  public newLineRoot(parent: Element, line: Line): SVGSVGElement {\n    const [td1, td2] = this.addNewRow(line.uuid + \"\", \"line\");\n    // Hacky solution to \"line headings\"\n    if (line.marginText) {\n      td1.innerHTML = line.marginText;\n    }\n    return TSU.DOM.createSVGNode(\"svg\", {\n      parent: td2, // parent\n      attrs: {\n        style: \"margin-bottom: 10px\",\n        class: \"lineRootSVG\",\n      },\n    }) as SVGSVGElement;\n  }\n\n  ensureLineView(line: Line): LineView {\n    let lineView = this.getLineView(line);\n    if (lineView == null) {\n      const layoutParams = line.layoutParams || null;\n      const svgElem = this.newLineRoot(this.tableElement, line);\n      lineView = new LineView(svgElem, line, {\n        layoutParams: layoutParams,\n      } as any);\n      if (!line.isEmpty) {\n        // Probably because this is an empty line and AddAtoms was not called\n        TSU.assert(layoutParams != null, \"Layout params for a non empty line *should* exist\");\n        lineView.gridModel = this.beatLayout!.getGridModelForLine(line.uuid);\n      }\n      this.lineViews.push(lineView);\n    }\n    return lineView;\n  }\n\n  getLineView(line: Line): TSU.Nullable<LineView> {\n    return this.lineViews.find((l) => l.line == line) || null;\n  }\n\n  get currentLineView(): LineView {\n    return this.lineViews[this.lineViews.length - 1];\n  }\n\n  clear(): void {\n    this.lineViews = [];\n    // Mapping from line id -> list of beats in each of its roles\n    this.currentSVGElement = null;\n    this.tableElement.innerHTML = \"\";\n    this.beatViews = new Map<number, BeatView>();\n  }\n\n  /**\n   * Layout all the blocks in the Notation along with their corresponding blocks.\n   * Key thing is here is an opportunity to perform any batch rendering as needed.\n   */\n  refreshLayout(): void {\n    const lineViews = [] as LineView[];\n\n    // Recursively process the notation (which is a Block) and collect LineViews\n    this.processBlock(this.notation, lineViews);\n\n    const now = performance.now();\n    for (const lineView of lineViews) {\n      lineView.gridModel.lastUpdatedAt = now;\n    }\n\n    this.beatLayout.gridLayoutGroup.refreshLayout();\n\n    for (const lineView of lineViews) {\n      lineView.wrapToSize();\n    }\n  }\n\n  /**\n   * Recursively processes a block and its children for rendering.\n   * Uses block.children() to get expanded children (e.g., RepeatBlock expands to N copies).\n   *\n   * @param block The block to process\n   * @param lineViews Array to collect LineViews for batch layout\n   */\n  protected processBlock(block: Block, lineViews: LineView[]): void {\n    for (const child of block.children()) {\n      this.processBlockItem(child, lineViews);\n    }\n  }\n\n  /**\n   * Processes a single block item (Block, Line, or RawBlock) for rendering.\n   *\n   * @param item The item to process\n   * @param lineViews Array to collect LineViews for batch layout\n   */\n  protected processBlockItem(item: BlockItem, lineViews: LineView[]): void {\n    if (isRawBlock(item)) {\n      // Render raw content (markdown, metadata)\n      this.renderBlock(item as RawBlock);\n    } else if (isLine(item)) {\n      // Render line\n      const line = item as Line;\n      if (!line.isEmpty) {\n        const lineView = this.ensureLineView(line);\n        lineViews.push(lineView);\n      }\n    } else if (isBlock(item)) {\n      // Recursively process nested block\n      this.processBlock(item as Block, lineViews);\n    }\n  }\n\n  renderBlock(raw: RawBlock): void {\n    const [, td2] = this.addNewRow(raw.uuid + \"\", \"rawBlock\", false);\n    if (raw.contentType == \"metadata\") {\n      // we have a metadata block\n      const meta = this.notation.metadata.get(raw.content);\n      if (meta) {\n        // For now ignore metadata with \":\" in the key\n        if (meta.key.toLowerCase().indexOf(\":\") < 0) {\n          const div = td2.appendChild(TSU.DOM.createNode(\"div\"));\n          const html = `<span class = \"${meta.key.toLowerCase()}\"><strong>${meta.key}</strong>: ${meta.value}</span>`;\n          div.innerHTML = html;\n        }\n      }\n    } else {\n      const div = td2.appendChild(TSU.DOM.createNode(\"div\"));\n      div.innerHTML = this.markdownParser(raw.content.trim());\n    }\n    this.currentSVGElement = null;\n  }\n\n  beatViews = new Map<number, BeatView>();\n  markerViews = new Map<string, MarkerView>();\n  viewForBeat(cell: GridCell): GridCellView {\n    if (cell.colIndex % 3 == 1) {\n      // beat view needed\n      const beat = cell.value;\n      let curr = this.beatViews.get(beat.uuid) || null;\n      if (curr == null) {\n        const line = beat.role.line;\n        // how to get the bar and beat index for a given beat in a given row?\n        const lineView = this.ensureLineView(line);\n        const lp = line.layoutParams;\n        curr = new BeatView(cell, beat, lineView.gElem, lp.cycle);\n        this.beatViews.set(beat.uuid, curr);\n\n        // Eagerly position view based on current alignment offsets.\n        // Since BFS layout processes alignments in order, predecessors are already positioned.\n        this.eagerlyPositionView(curr, cell);\n      }\n      return curr;\n    } else {\n      // markers view\n      const marker = cell.value;\n      const beat = marker.beat as Beat;\n      let curr = this.markerViews.get(\"pre:\" + beat.uuid) || null;\n      if (curr == null) {\n        const line = beat.role.line;\n        const lineView = this.ensureLineView(line);\n        const lp = line.layoutParams;\n        const isPreMarker = cell.colIndex % 3 == 0;\n        curr = new MarkerView(cell, beat, marker.markers, isPreMarker, lineView.gElem);\n        this.markerViews.set(\"pre:\" + beat.uuid, curr);\n\n        // Eagerly position view based on current alignment offsets.\n        this.eagerlyPositionView(curr, cell);\n      }\n      return curr;\n    }\n  }\n\n  /**\n   * Eagerly positions a newly created view based on current alignment offsets.\n   * This helps with debugging by showing intermediate positions during BFS layout.\n   */\n  protected eagerlyPositionView(view: GridCellView, cell: GridCell): void {\n    const x = cell.colAlign?.coordOffset ?? 0;\n    const y = cell.rowAlign?.coordOffset ?? 0;\n    const w = cell.colAlign?.maxLength ?? null;\n    const h = cell.rowAlign?.maxLength ?? null;\n    view.setBounds(x, y, w, h, true);\n  }\n}\n","import * as TSU from \"@panyam/tsutils\";\nimport * as G from \"galore\";\nimport { GlobalBeatLayout } from \"./beats\";\nimport { Parser } from \"./parser\";\nimport { Notation } from \"./notation\";\n\n/**\n * Parses a notation string into a Notation object.\n *\n * @param input The notation string to parse\n * @returns A tuple containing the parsed Notation and any parsing errors\n */\nexport function parse(input: string): [Notation, G.ParseError[]] {\n  return new Parser().parseAndBuild(input);\n}\n\n/**\n * Loads a notation from a string and builds the beat layout.\n *\n * @param codeText The notation string to load\n * @param config Optional configuration object\n * @returns A tuple containing the Notation, GlobalBeatLayout, parsing errors, and timing information\n */\nexport function load(\n  codeText: string,\n  config: any = {},\n): [Notation, GlobalBeatLayout, G.ParseError[], TSU.StringMap<number>] {\n  codeText = codeText || \"\";\n  const beatLayout = new GlobalBeatLayout();\n  const startTime = performance.now();\n  const [notation, errors] = parse(codeText);\n  const parseTime = performance.now();\n\n  // Process all blocks recursively using block.children()\n  // This handles nested blocks like \\repeat { }, \\section { }, etc.\n  beatLayout.processBlock(notation);\n\n  const buildTime = performance.now();\n  if (config.log) {\n    console.log(`V4 Document, Parse Time: ${parseTime - startTime}ms, Build Time: ${buildTime - parseTime}ms`);\n  }\n  return [\n    notation,\n    beatLayout,\n    errors,\n    {\n      parseTime: parseTime - startTime,\n      buildTime: buildTime - parseTime,\n    },\n  ];\n}\n","import * as TSU from \"@panyam/tsutils\";\nimport { Cycle, CyclePosition, CycleCursor } from \"./cycle\";\n\ntype Fraction = TSU.Num.Fraction;\nconst ZERO = TSU.Num.Fraction.ZERO;\n\n/**\n * Manages layout parameters for arranging beats and notes in the notation.\n * LayoutParams determines how beats are organized into lines and rows based on\n * cycle patterns and line breaks.\n */\nexport class LayoutParams {\n  private static counter = 0;\n  /** Unique identifier for this layout parameters instance */\n  readonly uuid = LayoutParams.counter++;\n\n  /** Duration of a single beat (multiplier for beat lengths) */\n  beatDuration: number;\n\n  /** The cycle pattern to use for this layout */\n  cycle: Cycle;\n\n  /** The pattern of line breaks to apply */\n  protected _lineBreaks: number[];\n\n  /** Cache of row start offsets */\n  private _rowStartOffsets: Fraction[];\n\n  /** Cache of row end offsets */\n  private _rowEndOffsets: Fraction[];\n\n  /** Cache of row durations */\n  private _rowDurations: Fraction[];\n\n  /** Total duration of the layout pattern */\n  private _totalLayoutDuration;\n\n  /** Cached beat layout information */\n  private _beatLayouts: [CyclePosition, Fraction][][];\n\n  /** Total number of beats across all layout lines */\n  private _totalBeats: number;\n\n  /**\n   * Creates a new LayoutParams instance.\n   * @param config Configuration object containing beatDuration, cycle, and lineBreaks\n   */\n  constructor(config?: any) {\n    config = config || {};\n    this.beatDuration = config.beatDuration || 1;\n    if (\"cycle\" in config) this.cycle = config.cycle;\n    if (!this.cycle || this.cycle.duration.isZero) {\n      this.cycle = Cycle.DEFAULT;\n    }\n\n    this._rowStartOffsets = [];\n    this._rowEndOffsets = [];\n    this._rowDurations = [];\n    this._totalLayoutDuration = ZERO;\n    this._totalBeats = 0;\n    this._beatLayouts = [];\n    this.lineBreaks = config.lineBreaks || config.layout || [];\n  }\n\n  /**\n   * Checks if this LayoutParams is equal to another LayoutParams.\n   * @param another The LayoutParams to compare with\n   * @returns True if the LayoutParams are equal, false otherwise\n   */\n  equals(another: this): boolean {\n    return (\n      // super.equals(another) &&\n      this.beatDuration == another.beatDuration &&\n      this.cycle.equals(another.cycle) &&\n      this.lineBreaksEqual(another._lineBreaks)\n    );\n  }\n\n  /**\n   * Checks if the line breaks pattern is equal to another pattern.\n   * @param another The line breaks pattern to compare with\n   * @returns True if the patterns are equal, false otherwise\n   */\n  lineBreaksEqual(another: number[]): boolean {\n    return this._lineBreaks.length == another.length && this._lineBreaks.every((x, i) => x == another[i]);\n  }\n\n  /**\n   * Returns a debug-friendly representation of this LayoutParams.\n   * @returns An object containing debug information\n   */\n  debugValue(): any {\n    return {\n      // ...super.debugValue(),\n      cycle: this.cycle?.debugValue(),\n      beatDuration: this.beatDuration,\n      lineBreaks: this._lineBreaks,\n    };\n  }\n\n  /**\n   * Returns the \"location\" of a beat within a layout.\n   *\n   * Lines are broken into beats of notes and those beats are aligned as per\n   * the specs in the LayoutParams (breaks). For example if the breaks param\n   * stipulates [5, 5, 4] then we have 5 beats in the first 2 lines and 4 in\n   * the last line.\n   *\n   * @param beat The beat to locate\n   * @returns A tuple containing [layoutLine, layoutColumn, rowOffset]\n   *         - layoutLine: The line in the layout break spec this beat falls in\n   *         - layoutColumn: The column within the layoutLine\n   *         - rowOffset: The offset of the beat from the start of the row/line\n   */\n  getBeatLocation(beat: {\n    index: number;\n    barIndex: number;\n    beatIndex: number;\n    instance: number;\n  }): [number, number, Fraction] {\n    //\n    // If a line contains say 50 beats (B1 - B50), then it is laid out as:\n    //\n    //      C0  C1  C2  C3  C4\n    //    ---------------------\n    // L0 | B1  B2  B3  B4  B5\n    // L1 | B6  B7  B8  B9  B10\n    // L2 | B11 B12 B13 B14\n    // L0 | B15 B16 B17 B18 B19\n    // L1 | B20 B21 B22 B23 B24\n    // L2 | B25 B26 B27 B28\n    // L0 | B29 B30 B31 B32 B33\n    // L1 | B34 B35 B36 B37 B38\n    // L2 | B39 B40 B41 B42\n    // L0 | B43 B44 B45 B46 B47\n    // L1 | B48 B49 B50\n    //\n    // This methods returns the triple: [layoutLine, layoutColumn, rowOffset]\n    // where\n    //\n    //  layoutLine: The particular line in the layout break spec this index falls in.\n    //              *Note*: Since lines can start with negative offsets, we can\n    //              even return a layoutLine that is towards the end and then go\n    //              back to 0, eg 4, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4 ...\n    //              (eg returns L0 or L1 ... Ln)\n    //  layoutColumn: The column within the layoutLine line where this beat falls.\n    //                (eg C0 - C4 above - or depending on how many columns exist\n    //                in the particular layout line).\n    //  rowOffset: The note offset of the beat from the start of the row/line\n    //             (not from the start of the cycle).\n    //\n    // Note the beatIndex can also be negative so we can return a beat\n    // starting from before the cycle starting point.\n    //\n    //  To calculate the \"real\" line globally simply do:\n    //\n    //    realLine = lineBreaks.length  // Math.floor(beatIndex / this.totalBeats) + layoutLine;\n    //\n    // Some examples here are (using B1-B50 above):\n    const modIndex = beat.index % this.totalBeats;\n    let total = 0;\n    for (let i = 0; i < this._lineBreaks.length; i++) {\n      if (modIndex < total + this._lineBreaks[i]) {\n        // TODO: What is the right offset here?\n        let offset = ZERO;\n        if (modIndex > total) {\n          const cursor = new CycleCursor(this.cycle, beat.barIndex, beat.beatIndex, beat.instance);\n          let [, duration] = cursor.prev;\n          for (let i = total; i < modIndex; i++) {\n            [, duration] = cursor.prev;\n            offset = offset.plus(duration.timesNum(this.beatDuration));\n          }\n        }\n        return [i, modIndex - total, offset];\n      }\n      total += this._lineBreaks[i];\n    }\n    throw new Error(\"Invalid beat index: \" + beat.index);\n    return [-1, -1, ZERO];\n  }\n\n  /**\n   * Gets the line layout pattern - i.e., number of beats in each line - as a\n   * repeating pattern.\n   *\n   * For example 4,2,4 indicates that the notes in our song should be\n   * laid out 4 beats in line 1, 2 beats in line 2, 4 beats in line 3 and\n   * 4 beats in line 4 and so on as long as there are more notes available\n   * in this line.\n   */\n  get lineBreaks(): number[] {\n    if (!this._lineBreaks || this._lineBreaks.length == 0) {\n      // trigger a refresh\n      this.lineBreaks = [this.cycle.beatCount];\n    }\n    return this._lineBreaks;\n  }\n\n  /**\n   * Sets the line layout pattern.\n   */\n  set lineBreaks(val: number[]) {\n    this._lineBreaks = val;\n    this.refreshLayout();\n  }\n\n  /**\n   * Returns the number of beats in each line based on the line layout\n   * after taking beatDuration into account.\n   */\n  get beatLayouts(): ReadonlyArray<ReadonlyArray<[CyclePosition, Fraction]>> {\n    if (!this._beatLayouts || this._beatLayouts.length < this.lineBreaks.length) {\n      this.refreshLayout();\n    }\n    return this._beatLayouts;\n  }\n\n  /**\n   * Gets the total number of beats across all lines in the layout pattern.\n   */\n  get totalBeats(): number {\n    this.beatLayouts;\n    return this._totalBeats;\n  }\n\n  /**\n   * Gets the total duration of all beats across all lines in the layout pattern.\n   */\n  get totalLayoutDuration(): Fraction {\n    this.beatLayouts;\n    return this._totalLayoutDuration;\n  }\n\n  /**\n   * Refreshes the layout calculations based on the current cycle and line breaks.\n   * This rebuilds the beat layouts, row durations, and offset information.\n   */\n  protected refreshLayout(): void {\n    const cycleIter = this.cycle.iterateBeats();\n    const akb = this.beatDuration;\n    this._beatLayouts = this.lineBreaks.map((numBeats, index) => {\n      const beats: [CyclePosition, Fraction][] = [];\n      // see what the beat lengths are here\n      for (let i = 0; i < numBeats; i++) {\n        const nextCP = cycleIter.next().value;\n        nextCP[1] = nextCP[1].timesNum(akb);\n        beats.push(nextCP);\n      }\n      return beats;\n    });\n    this._totalBeats = this.lineBreaks.reduce((a, b) => a + b, 0);\n    this._rowDurations = this._beatLayouts.map((beats) => beats.reduce((x, y) => x.plus(y[1]), ZERO));\n    this._rowDurations.forEach((rd, index) => {\n      this._rowStartOffsets[index] = index == 0 ? ZERO : this._rowStartOffsets[index - 1].plus(rd);\n    });\n    this._rowEndOffsets = this._rowDurations.map((rd, index) => {\n      return this._rowStartOffsets[index].plus(rd);\n    });\n    this._totalLayoutDuration = this._rowDurations.reduce((x, y) => x.plus(y), ZERO);\n  }\n}\n","import * as TSU from \"@panyam/tsutils\";\nimport { ZERO, Atom, LeafAtom, Group, AtomType } from \"./core\";\n\n/**\n * Represents an item to be positioned in collision-based layout.\n */\nexport interface CollisionLayoutItem {\n  /** Time offset as a fraction (numerator/denominator) */\n  timeOffset: TSU.Num.Fraction;\n  /** Duration of this item */\n  duration: TSU.Num.Fraction;\n  /** Width of pre-embellishments (extends left from glyph position) */\n  glyphOffset: number;\n  /** Minimum width of the item (includes all embellishments and glyph) */\n  minWidth: number;\n}\n\n/**\n * Result of collision-based layout for a single item.\n */\nexport interface CollisionLayoutResult {\n  /** The calculated x position for the item */\n  x: number;\n  /** Whether the item was pushed right due to collision */\n  wasCollision: boolean;\n}\n\n/**\n * Computes collision-based positions for a sequence of items within a container.\n *\n * ## Algorithm\n *\n * 1. Calculate ideal glyph position: `glyphX = (timeOffset / totalDuration) * containerWidth`\n * 2. Pre-embellishments extend left: `realX = glyphX - glyphOffset`\n * 3. Collision check: if `realX < prevItemEndX`, then `realX = prevItemEndX`\n * 4. Track: `prevItemEndX = realX + minWidth`\n *\n * @param items Items to position (must be in time order)\n * @param totalDuration Total duration of all items\n * @param containerWidth Width of the container to position items within\n * @returns Array of positions for each item\n */\nexport function computeCollisionLayout(\n  items: CollisionLayoutItem[],\n  totalDuration: TSU.Num.Fraction,\n  containerWidth: number,\n): CollisionLayoutResult[] {\n  const results: CollisionLayoutResult[] = [];\n  let prevItemEndX = 0;\n  let currTime = ZERO;\n\n  for (const item of items) {\n    // 1. Calculate ideal glyph position based on time offset\n    const glyphX = totalDuration.isZero ? 0 : currTime.timesNum(containerWidth).divby(totalDuration).floor;\n\n    // 2. Pre-embellishments extend left from glyph position\n    let realX = glyphX - item.glyphOffset;\n\n    // 3. Collision check: push right if overlapping previous item\n    const wasCollision = realX < prevItemEndX;\n    if (wasCollision) {\n      realX = prevItemEndX;\n    }\n\n    results.push({ x: realX, wasCollision });\n\n    // 4. Track end position for next collision check\n    prevItemEndX = realX + item.minWidth;\n\n    currTime = currTime.plus(item.duration);\n  }\n\n  return results;\n}\n\n/**\n * Base class for all renderable objects.\n *\n * Shape caches properties like bounding boxes to improve performance,\n * since bounding box calculations can be expensive. This also allows\n * testing layouts and positioning without worrying about implementation details.\n */\nexport abstract class Shape {\n  private static idCounter = 0;\n  readonly shapeId: number = Shape.idCounter++;\n\n  /**\n   * Note that x and y coordinates are not always the x and y coordinates\n   * of the bounding box.\n   * E.g., a circle's x and y coordinates are its center point and not the\n   * top left corner.\n   * These \"main\" coordinates are referred to as control coordinates.\n   */\n  protected _x: number | null = null;\n  protected _y: number | null = null;\n  protected _width: number | null = null;\n  protected _height: number | null = null;\n  protected _bbox: TSU.Geom.Rect;\n  protected _minSize: TSU.Geom.Size;\n  protected parentShape: Shape | null = null;\n  /** Child shapes contained within this shape */\n  children: Shape[] = [];\n\n  /**\n   * Gets the bounding box of this shape.\n   * Calculates it if it hasn't been calculated yet.\n   */\n  get bbox(): TSU.Geom.Rect {\n    if (!this._bbox) {\n      this._bbox = this.refreshBBox();\n    }\n    return this._bbox;\n  }\n\n  /**\n   * Gets the minimum size of this shape.\n   * This is usually the size of the bounding box.\n   */\n  get minSize(): TSU.Geom.Size {\n    if (!this._minSize) {\n      this._minSize = this.refreshMinSize();\n    }\n    return this._minSize;\n  }\n\n  /**\n   * Refreshes the bounding box of this shape.\n   * Called when the shape knows the bbox it is tracking cannot be trusted\n   * and has to be refreshed by calling native methods.\n   * @returns The refreshed bounding box\n   */\n  protected abstract refreshBBox(): TSU.Geom.Rect;\n\n  /**\n   * Refreshes the minimum size of this shape.\n   * @returns The refreshed minimum size\n   */\n  protected abstract refreshMinSize(): TSU.Geom.Size;\n\n  /**\n   * Updates the bounds of this shape.\n   * @param x New x coordinate, or null to keep current value\n   * @param y New y coordinate, or null to keep current value\n   * @param w New width, or null to keep current value\n   * @param h New height, or null to keep current value\n   * @returns The updated bounds values\n   */\n  protected abstract updateBounds(\n    x: null | number,\n    y: null | number,\n    w: null | number,\n    h: null | number,\n  ): [number | null, number | null, number | null, number | null];\n\n  /**\n   * Invalidates the cached bounds of this shape.\n   * Forces recalculation of bounding box and minimum size.\n   */\n  invalidateBounds(): void {\n    this._minSize = null as unknown as TSU.Geom.Size;\n    this._bbox = null as unknown as TSU.Geom.Rect;\n  }\n\n  /**\n   * Sets the bounds of this shape.\n   *\n   * Note that null and NaN are valid values and mean the following:\n   * - null: Don't change the value\n   * - NaN: Set the value to null (use the bounding box's value)\n   *\n   * @param x New x coordinate, or null to keep current value\n   * @param y New y coordinate, or null to keep current value\n   * @param w New width, or null to keep current value\n   * @param h New height, or null to keep current value\n   * @param applyLayout Whether to apply layout immediately\n   * @returns The updated bounds values\n   */\n  setBounds(\n    x: number | null,\n    y: number | null,\n    w: number | null,\n    h: number | null,\n    applyLayout = false,\n  ): [number | null, number | null, number | null, number | null] {\n    if (x != null) {\n      if (isNaN(x)) {\n        this._x = null;\n      } else {\n        this._x = x;\n      }\n    }\n    if (y != null) {\n      if (isNaN(y)) {\n        this._y = null;\n      } else {\n        this._y = y;\n      }\n    }\n    if (w != null) {\n      if (isNaN(w)) {\n        this._width = null;\n      } else {\n        this._width = w;\n      }\n    }\n    if (h != null) {\n      if (isNaN(h)) {\n        this._height = null;\n      } else {\n        this._height = h;\n      }\n    }\n    const [nx, ny, nw, nh] = this.updateBounds(x, y, w, h);\n    if (nx != null) {\n      if (isNaN(nx)) {\n        this._x = null;\n      } else {\n        this._x = nx;\n      }\n    }\n    if (ny != null) {\n      if (isNaN(ny)) {\n        this._y = null;\n      } else {\n        this._y = ny;\n      }\n    }\n    if (nw != null) {\n      if (isNaN(nw)) {\n        this._width = null;\n      } else {\n        this._width = nw;\n      }\n    }\n    if (nh != null) {\n      if (isNaN(nh)) {\n        this._height = null;\n      } else {\n        this._height = nh;\n      }\n    }\n    if (applyLayout) this.refreshLayout();\n    // this.resetBBox();\n    return [nx, ny, nw, nh];\n  }\n\n  /**\n   * Checks if this shape has an explicit x coordinate.\n   */\n  get hasX(): boolean {\n    return this._x != null && !isNaN(this._x);\n  }\n\n  /**\n   * Checks if this shape has an explicit y coordinate.\n   */\n  get hasY(): boolean {\n    return this._y != null && !isNaN(this._y);\n  }\n\n  /**\n   * Checks if this shape has an explicit width.\n   */\n  get hasWidth(): boolean {\n    return this._width != null && !isNaN(this._width);\n  }\n\n  /**\n   * Checks if this shape has an explicit height.\n   */\n  get hasHeight(): boolean {\n    return this._height != null && !isNaN(this._height);\n  }\n\n  /**\n   * Gets the x coordinate within the parent's coordinate system.\n   */\n  get x(): number {\n    return this._x || 0;\n  }\n\n  /**\n   * Sets the x coordinate within the parent's coordinate system.\n   */\n  set x(x: number | null) {\n    // Here a manual x is being set - how does this interfere with the bounding box?\n    // We should _x to the new value to indicate a manual value was set.\n    // and reset bbox so that based on this x a new bbox may need to be calculated\n    this.setBounds(x == null ? NaN : x, null, null, null);\n  }\n\n  /**\n   * Gets the y coordinate within the parent's coordinate system.\n   */\n  get y(): number {\n    if (this._y != null) return this._y;\n    return 0; // this.bbox.y;\n  }\n\n  /**\n   * Sets the y coordinate within the parent's coordinate system.\n   */\n  set y(y: number | null) {\n    this.setBounds(null, y == null ? NaN : y, null, null);\n  }\n\n  /**\n   * Gets the width of this shape.\n   */\n  get width(): number {\n    if (this._width != null) return this._width;\n    return 0; // this.bbox.width;\n  }\n\n  /**\n   * Sets the width of this shape.\n   */\n  set width(w: number | null) {\n    this.setBounds(null, null, w == null ? NaN : w, null);\n  }\n\n  /**\n   * Gets the height of this shape.\n   */\n  get height(): number {\n    if (this._height != null) return this._height;\n    return 0; // this.bbox.height;\n  }\n\n  /**\n   * Sets the height of this shape.\n   */\n  set height(h: number | null) {\n    this.setBounds(null, null, null, h == null ? NaN : h);\n  }\n\n  /**\n   * Refreshes the layout of this shape.\n   * Called when bounds or other properties have changed to give the shape an\n   * opportunity to layout its children. For shapes with no children this is a no-op.\n   */\n  refreshLayout(): void {\n    // throw new Error(\"Implement this\");\n  }\n}\n\n/**\n * Represents an embellishment applied to a musical element.\n */\nexport abstract class Embelishment extends Shape {}\n\n/**\n * A shape that wraps an SVG element.\n * ElementShape provides the base class for all shapes that are rendered as SVG elements.\n */\nexport class ElementShape<T extends SVGGraphicsElement = SVGGraphicsElement> extends Shape {\n  /**\n   * Creates a new ElementShape.\n   * @param element The SVG element this shape wraps\n   */\n  constructor(public readonly element: T) {\n    super();\n  }\n\n  /**\n   * Refreshes the bounding box of this element.\n   * @returns The refreshed bounding box\n   */\n  protected refreshBBox(): TSU.Geom.Rect {\n    return TSU.DOM.svgBBox(this.element);\n  }\n\n  /**\n   * Refreshes the minimum size of this element.\n   * @returns The refreshed minimum size\n   */\n  protected refreshMinSize(): TSU.Geom.Size {\n    return TSU.DOM.svgBBox(this.element);\n  }\n\n  /**\n   * Updates the bounds of this element.\n   * @param x New x coordinate, or null to keep current value\n   * @param y New y coordinate, or null to keep current value\n   * @param w New width, or null to keep current value\n   * @param h New height, or null to keep current value\n   * @returns The updated bounds values\n   */\n  protected updateBounds(\n    x: null | number,\n    y: null | number,\n    w: null | number,\n    h: null | number,\n  ): [number | null, number | null, number | null, number | null] {\n    return [x, y, w, h];\n  }\n\n  /**\n   * Refreshes the layout of this element.\n   * Updates the element's attributes based on the shape's properties.\n   */\n  refreshLayout(): void {\n    if (this.hasX) this.element.setAttribute(\"x\", \"\" + this._x);\n    if (this.hasY) this.element.setAttribute(\"y\", \"\" + this._y);\n  }\n}\n\n/**\n * Base class for views that represent atoms in the notation.\n * AtomView provides the visual representation of an atom.\n */\nexport abstract class AtomView extends Shape {\n  /** Nesting depth of this atom in the structure */\n  depth = 0;\n  /** Index of the role containing this atom */\n  roleIndex = 0;\n\n  // LayoutMetrics for the AtomView so all atomviews laid out on the\n  // same baseline will show up aligned vertically\n  /** Baseline position for vertical alignment */\n  baseline: number;\n  /** Ascent (space above baseline) */\n  ascent: number;\n  /** Descent (space below baseline) */\n  descent: number;\n  /** Height of capital letters */\n  capHeight: number;\n  /** Space between lines */\n  leading: number;\n\n  /**\n   * Checks if this atom view represents a leaf atom.\n   */\n  abstract isLeaf(): boolean;\n\n  abstract get totalDuration(): TSU.Num.Fraction;\n\n  /**\n   * Returns the horizontal offset from the atom's origin to where the note glyph starts.\n   * This accounts for left embellishments that appear before the note.\n   * Used by GroupView to align note glyphs at their correct time positions.\n   *\n   * Default is 0 (glyph starts at origin). Subclasses with left embellishments\n   * should override to return the width of left-side decorations.\n   */\n  get glyphOffset(): number {\n    return 0;\n  }\n\n  /**\n   * Creates the SVG elements needed for this atom view.\n   * @param parent The parent SVG element to attach to\n   */\n  abstract createElements(parent: SVGGraphicsElement): void;\n}\n\n/**\n * A view for leaf atoms (those that cannot contain other atoms).\n */\nexport abstract class LeafAtomView extends AtomView {\n  /**\n   * Creates a new LeafAtomView.\n   * @param leafAtom The leaf atom this view represents\n   */\n  constructor(public leafAtom: LeafAtom) {\n    super();\n  }\n\n  /**\n   * Leaf atom views always return true for isLeaf().\n   */\n  isLeaf(): boolean {\n    return true;\n  }\n\n  /**\n   * Gets a unique identifier for this view based on the atom's UUID.\n   */\n  get viewId(): number {\n    return this.leafAtom.uuid;\n  }\n\n  /**\n   * Returns the total duration of the atom rendered by this view.\n   */\n  get totalDuration(): TSU.Num.Fraction {\n    return this.leafAtom.duration;\n  }\n}\n\n/**\n * A view for group atoms that contain multiple child atoms.\n */\nexport abstract class GroupView extends AtomView {\n  /** Space between atoms in this group */\n  protected atomSpacing: number;\n  /** The SVG group element for this view */\n  groupElement: SVGGElement;\n  /** Views for the atoms in this group */\n  protected atomViews: AtomView[] = [];\n  private _embelishments: Embelishment[];\n  /** Whether this group represents notes by default */\n  defaultToNotes = true;\n  /** Whether this view needs layout */\n  needsLayout = true;\n  /** Scale factor for this group */\n  scaleFactor = 1.0;\n  /**\n   * When true, shows continuation markers (\",\") for atoms with duration > 1\n   * instead of just leaving empty space.\n   * Disabled by default as group bracket lines provide clearer visual boundaries.\n   */\n  showContinuationMarkers = false;\n  /** SVG elements for continuation markers */\n  protected continuationMarkerElements: SVGTextElement[] = [];\n  /** Actual content width after layout (position of last atom + its width) */\n  contentWidth = 0;\n\n  /**\n   * Creates a new GroupView.\n   * @param group The group atom this view represents\n   * @param config Optional configuration object\n   */\n  constructor(\n    public group: Group,\n    config?: any,\n  ) {\n    super();\n    this.atomSpacing = 2;\n    this.setStyles(config || {});\n  }\n\n  /**\n   * Returns the total duration of the group rendered by this view.\n   * This returns the group's actual duration (accounting for scaling),\n   * not the raw sum of child durations.\n   */\n  get totalDuration(): TSU.Num.Fraction {\n    return this.group.duration;\n  }\n\n  /**\n   * Creates the SVG elements needed for this group view.\n   * @param parent The parent SVG element to attach to\n   */\n  createElements(parent: SVGGraphicsElement): void {\n    this.groupElement = TSU.DOM.createSVGNode(\"g\", {\n      parent: parent,\n      attrs: {\n        class: \"groupViewRoot\",\n        id: \"groupViewRoot\" + this.group.uuid,\n      },\n    });\n\n    // now create child atom views for each atom in this Group\n    // Skip markers - they're rendered in separate pre/post marker columns\n    for (const atom of this.group.atoms.values()) {\n      if (atom.TYPE === AtomType.MARKER) continue;\n      const atomView = this.createAtomView(atom);\n      this.atomViews.push(atomView);\n    }\n    this.invalidateBounds();\n  }\n\n  /**\n   * Group views always return false for isLeaf().\n   */\n  isLeaf(): boolean {\n    return false;\n  }\n\n  /**\n   * Refreshes the bounding box of this group.\n   * @returns The refreshed bounding box\n   */\n  protected refreshBBox(): TSU.Geom.Rect {\n    return TSU.DOM.svgBBox(this.groupElement);\n  }\n\n  /**\n   * Refreshes the minimum size of this group using duration-based width calculation.\n   *\n   * ## Duration-Based Width Algorithm\n   *\n   * This algorithm ensures atoms with extended durations receive proportionally\n   * more horizontal space. For example, with `\\beatDuration(4)` and input `S 2 R G M`:\n   * - S has duration 1, R has duration 2, G has duration 1\n   * - R should visually occupy twice the horizontal space of S or G\n   *\n   * ### Algorithm Steps:\n   *\n   * 1. **Calculate width per duration unit**: For each atom, compute the visual width\n   *    needed per unit of duration: `(visualWidth + spacing) / duration`\n   *\n   * 2. **Find maximum**: Take the maximum width-per-duration across all atoms.\n   *    This ensures every atom has enough space for its visual content.\n   *\n   * 3. **Scale by total duration**: Multiply the max width-per-duration by the\n   *    group's total duration to get the final group width.\n   *\n   * ### Example:\n   * ```\n   * Atoms: S(dur=1, width=10px), R(dur=2, width=10px), G(dur=1, width=10px)\n   * Spacing: 5px\n   *\n   * Width per duration:\n   *   S: (10 + 5) / 1 = 15 px/unit\n   *   R: (10 + 5) / 2 = 7.5 px/unit\n   *   G: (10 + 5) / 1 = 15 px/unit\n   *\n   * Max width per duration: 15 px/unit\n   * Total duration: 1 + 2 + 1 = 4 units\n   * Group width: 15 * 4 = 60px\n   *\n   * Positioning:\n   *   S at x=0 (time 0/4 * 60 = 0)\n   *   R at x=15 (time 1/4 * 60 = 15)\n   *   G at x=45 (time 3/4 * 60 = 45)\n   * ```\n   *\n   * @returns The refreshed minimum size\n   */\n  protected refreshMinSize(): TSU.Geom.Size {\n    let maxHeight = 0;\n\n    // Step 1: Calculate width per duration unit for each atom\n    let minWidthPerDuration = 0;\n    this.atomViews.forEach((av) => {\n      const ms = av.minSize;\n      const dur = av.totalDuration;\n      if (!dur.isZero) {\n        const durValue = dur.num / dur.den;\n        const widthPerDur = (ms.width + this.atomSpacing) / durValue;\n        // Step 2: Track maximum width per duration\n        minWidthPerDuration = Math.max(minWidthPerDuration, widthPerDur);\n      }\n      maxHeight = Math.max(maxHeight, ms.height);\n    });\n\n    // Step 3: Scale by total duration\n    const totalDuration = this.group.totalChildDuration;\n    const totalDurValue = totalDuration.num / totalDuration.den;\n    // Subtract one atomSpacing since we don't need spacing after the last atom\n    const totalWidth = Math.max(0, minWidthPerDuration * totalDurValue - this.atomSpacing);\n\n    return new TSU.Geom.Size(totalWidth * this.scaleFactor, maxHeight * this.scaleFactor);\n  }\n\n  /**\n   * Creates an atom view for a specific atom.\n   * @param atom The atom to create a view for\n   * @returns The created atom view\n   */\n  abstract createAtomView(atom: Atom): AtomView;\n\n  /**\n   * Updates the bounds of this group.\n   * @param x New x coordinate, or null to keep current value\n   * @param y New y coordinate, or null to keep current value\n   * @param w New width, or null to keep current value\n   * @param h New height, or null to keep current value\n   * @returns The updated bounds values\n   */\n  protected updateBounds(\n    x: null | number,\n    y: null | number,\n    w: null | number,\n    h: null | number,\n  ): [number | null, number | null, number | null, number | null] {\n    return [x, y, w, h];\n  }\n\n  /**\n   * Refreshes the layout of this group using collision-based positioning.\n   *\n   * ## Collision-Based Layout Algorithm\n   *\n   * Atoms are positioned using time-based positioning with collision avoidance.\n   * Each atom starts at its ideal time-based position, but is pushed right if\n   * it would overlap with the previous atom (including embellishments).\n   *\n   * ### Algorithm:\n   * ```\n   * 1. Calculate ideal glyph position: glyphX = (time / totalDuration) * groupWidth\n   * 2. Pre-embellishments extend left: realX = glyphX - preEmbellishmentWidth\n   * 3. Collision check: if (realX < prevNoteEndX) realX = prevNoteEndX\n   * 4. Position the atom at realX\n   * 5. Track: prevNoteEndX = realX + atom.minSize.width\n   * ```\n   *\n   * ### Width Source Priority:\n   *\n   * 1. **Column width** (preferred): If width was set via `setBounds()` from the\n   *    grid layout system (ColAlign), use that width. This enables global alignment\n   *    across all beats in the same column.\n   *\n   * 2. **Minimum size**: Fall back to `minSize.width` calculated by `refreshMinSize()`.\n   *\n   * ### Continuation Markers:\n   *\n   * When `showContinuationMarkers` is true (default), atoms with duration > 1\n   * will have \",\" markers rendered at each additional time slot. For example,\n   * an atom with duration 2 will show \"R ,\" instead of \"R   \".\n   *\n   * ### Example (no collisions):\n   * ```\n   * Input: S R G M (equal duration, no embellishments)\n   * Group width: 60px, Total duration: 4 units\n   *\n   * Positioning:\n   *   S at x=0   (time 0/4 * 60 = 0)\n   *   R at x=15  (time 1/4 * 60 = 15)\n   *   G at x=30  (time 2/4 * 60 = 30)\n   *   M at x=45  (time 3/4 * 60 = 45)\n   * ```\n   *\n   * ### Example (with collision):\n   * ```\n   * Input: [Jaaru+S] R (S has 10px pre-embellishment, each atom 15px wide)\n   * Group width: 60px, Total duration: 2 units\n   *\n   * Without collision avoidance:\n   *   S.glyphX = 0, S.realX = 0 - 10 = -10 (clamped to 0)\n   *   R.glyphX = 30, R overlaps with S\n   *\n   * With collision avoidance:\n   *   S at x=0 (prevNoteEndX becomes 15)\n   *   R.glyphX = 30, R.realX = 30 - 0 = 30\n   *   30 >= 15, no collision, R at x=30\n   * ```\n   */\n  refreshLayout(): void {\n    let transform = \"translate(\" + this.x + \",\" + this.y + \")\";\n    if (this.scaleFactor < 1) {\n      transform += \" scale(\" + this.scaleFactor + \")\";\n    }\n    this.groupElement.setAttribute(\"transform\", transform);\n\n    // BASELINE ALIGNMENT: Position atoms at bottom of allocated height.\n    // This ensures atoms align across beats with different bracket heights.\n    // When beats in the same row have different content heights (e.g., due to\n    // nested group brackets), all beats get the same allocated height from the\n    // grid. By positioning content at the bottom, atom baselines align.\n    const unscaledContentHeight = this.minSize.height / this.scaleFactor;\n    const unscaledAllocatedHeight = this.hasHeight ? this.height / this.scaleFactor : unscaledContentHeight;\n    const currY = unscaledAllocatedHeight - unscaledContentHeight;\n\n    const totalDur = this.group.totalChildDuration;\n\n    // Width source priority: column width (for global alignment) > minSize\n    const unscaledMinWidth = this.minSize.width / this.scaleFactor;\n    const groupWidth = this.hasWidth ? this.width / this.scaleFactor : unscaledMinWidth;\n\n    // Clear existing continuation markers before re-rendering\n    this.clearContinuationMarkers();\n\n    // Position each atom using collision-based layout\n    // Atoms start at their time-based position, but are pushed right if they would\n    // overlap with the previous atom (including embellishments)\n    let currTime = ZERO;\n    let prevNoteEndX = 0;\n    this.atomViews.forEach((av, index) => {\n      // 1. Calculate ideal glyph position based on time offset\n      const glyphX = totalDur.isZero ? 0 : currTime.timesNum(groupWidth).divby(totalDur).floor;\n\n      // 2. Pre-embellishments extend left from glyph position\n      //    realX is where the atom origin should be placed\n      let realX = glyphX - av.glyphOffset;\n\n      // 3. Collision check: push right if overlapping previous atom\n      if (realX < prevNoteEndX) {\n        realX = prevNoteEndX;\n      }\n\n      // 4. Position the atom\n      av.setBounds(realX, currY, null, null, true);\n\n      // 5. Track end position for next collision check\n      // For groups, use contentWidth (actual content) instead of bbox.width (which may include extra space).\n      // For leaf atoms, use bbox.width.\n      const avWidth = (av as any).contentWidth || av.bbox.width;\n      prevNoteEndX = realX + avWidth;\n\n      // Render continuation markers for atoms with duration > 1\n      if (this.showContinuationMarkers && !totalDur.isZero) {\n        const atomDur = av.totalDuration;\n        const durValue = atomDur.num / atomDur.den;\n        if (durValue > 1) {\n          // Render one marker at each additional time slot within the atom's duration\n          const numMarkers = Math.floor(durValue) - 1;\n          for (let i = 1; i <= numMarkers; i++) {\n            // Marker time = currTime + (atomDuration * i / floor(duration))\n            const markerTime = currTime.plus(atomDur.timesNum(i).divbyNum(Math.floor(durValue)));\n            const markerX = markerTime.timesNum(groupWidth).divby(totalDur).floor;\n            this.renderContinuationMarker(markerX, currY);\n          }\n        }\n      }\n\n      currTime = currTime.plus(av.totalDuration);\n    });\n\n    // Track actual content width for bracket sizing\n    this.contentWidth = prevNoteEndX;\n\n    this.invalidateBounds();\n    for (const e of this.embelishments) e.refreshLayout();\n    this.invalidateBounds();\n  }\n\n  /**\n   * Clears all continuation marker elements.\n   */\n  protected clearContinuationMarkers(): void {\n    for (const el of this.continuationMarkerElements) {\n      el.remove();\n    }\n    this.continuationMarkerElements = [];\n  }\n\n  /**\n   * Renders a continuation marker (\",\") at the specified position.\n   * @param x X position for the marker\n   * @param y Y position for the marker\n   */\n  protected renderContinuationMarker(x: number, y: number): void {\n    const marker = TSU.DOM.createSVGNode(\"text\", {\n      parent: this.groupElement,\n      attrs: {\n        class: \"continuationMarker\",\n        x: x.toString(),\n        y: y.toString(),\n      },\n      text: \",\",\n    }) as SVGTextElement;\n    this.continuationMarkerElements.push(marker);\n  }\n\n  /**\n   * Gets the embellishments for this group.\n   */\n  get embelishments(): Embelishment[] {\n    if (!this._embelishments) {\n      this._embelishments = this.createEmbelishments();\n    }\n    return this._embelishments;\n  }\n\n  /**\n   * Creates the embellishments for this group.\n   * @returns An array of embellishments\n   */\n  protected createEmbelishments(): Embelishment[] {\n    return [];\n  }\n\n  /**\n   * Sets the styles for this group.\n   * @param config Style configuration object\n   */\n  setStyles(config: any): void {\n    if (\"atomSpacing\" in config) this.atomSpacing = config.atomSpacing;\n    if (\"showContinuationMarkers\" in config) this.showContinuationMarkers = config.showContinuationMarkers;\n    this.needsLayout = true;\n  }\n}\n","\n      import API from \"!../node_modules/.pnpm/style-loader@4.0.0_webpack@5.104.1/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n      import domAPI from \"!../node_modules/.pnpm/style-loader@4.0.0_webpack@5.104.1/node_modules/style-loader/dist/runtime/styleDomAPI.js\";\n      import insertFn from \"!../node_modules/.pnpm/style-loader@4.0.0_webpack@5.104.1/node_modules/style-loader/dist/runtime/insertBySelector.js\";\n      import setAttributes from \"!../node_modules/.pnpm/style-loader@4.0.0_webpack@5.104.1/node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\";\n      import insertStyleElement from \"!../node_modules/.pnpm/style-loader@4.0.0_webpack@5.104.1/node_modules/style-loader/dist/runtime/insertStyleElement.js\";\n      import styleTagTransformFn from \"!../node_modules/.pnpm/style-loader@4.0.0_webpack@5.104.1/node_modules/style-loader/dist/runtime/styleTagTransform.js\";\n      import content, * as namedExport from \"!!../node_modules/.pnpm/css-loader@7.1.2_webpack@5.104.1/node_modules/css-loader/dist/cjs.js!../node_modules/.pnpm/sass-loader@16.0.6_sass@1.97.2_webpack@5.104.1/node_modules/sass-loader/dist/cjs.js!./NotationView.scss\";\n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = styleTagTransformFn;\noptions.setAttributes = setAttributes;\noptions.insert = insertFn.bind(null, \"head\");\noptions.domAPI = domAPI;\noptions.insertStyleElement = insertStyleElement;\n\nvar update = API(content, options);\n\n\n\nexport * from \"!!../node_modules/.pnpm/css-loader@7.1.2_webpack@5.104.1/node_modules/css-loader/dist/cjs.js!../node_modules/.pnpm/sass-loader@16.0.6_sass@1.97.2_webpack@5.104.1/node_modules/sass-loader/dist/cjs.js!./NotationView.scss\";\n       export default content && content.locals ? content.locals : undefined;\n","import * as TSU from \"@panyam/tsutils\";\nimport { AtomView, Embelishment, ElementShape } from \"./shapes\";\nimport { GridCell, GridCellView } from \"./grids\";\nimport { Cycle } from \"./cycle\";\nimport { Beat } from \"./beats\";\n\n/**\n * Abstract base class for views that represent beats in the notation.\n * BeatView provides the visual representation of a beat and implements the GridCellView\n * interface to support placement in a grid.\n */\nexport abstract class BeatView extends ElementShape<SVGGElement> implements GridCellView {\n  /** Embellishments applied to this beat view */\n  private _embelishments: Embelishment[];\n\n  /** View for the atom contained in this beat (null if beat has only markers) */\n  atomView: AtomView | null;\n\n  /** Whether this view needs layout */\n  needsLayout = true;\n\n  /**\n   * Creates a new BeatView.\n   * @param cell The grid cell this beat view belongs to\n   * @param beat The beat this view represents\n   * @param rootElement The root SVG element to attach to\n   * @param cycle The cycle this beat belongs to\n   * @param config Optional configuration object\n   */\n  constructor(\n    public readonly cell: GridCell,\n    public readonly beat: Beat,\n    public readonly rootElement: SVGGraphicsElement,\n    public readonly cycle: Cycle,\n    config?: any,\n  ) {\n    super(\n      TSU.DOM.createSVGNode(\"g\", {\n        parent: rootElement,\n        attrs: {\n          class: `beatView role_${beat.role.name}`,\n          beatId: \"\" + beat.uuid,\n          id: \"\" + beat.uuid,\n          roleName: beat.role.name,\n          beatIndex: \"\" + beat.index,\n          gridRow: cell.rowIndex,\n          gridCol: cell.colIndex,\n        },\n      }),\n    );\n    this.atomView = this.createAtomView();\n    if (this.atomView) {\n      this.atomView.refreshLayout();\n    }\n  }\n\n  /**\n   * Gets the embellishments for this beat view.\n   */\n  get embelishments(): Embelishment[] {\n    if (!this._embelishments) {\n      this._embelishments = this.createEmbelishments();\n    }\n    return this._embelishments;\n  }\n\n  /**\n   * Sets the styles for this beat view.\n   * @param config Style configuration object\n   */\n  setStyles(config: any): void {\n    this.needsLayout = true;\n  }\n\n  /**\n   * Creates the embellishments for this beat view.\n   * @returns An array of embellishments\n   */\n  protected abstract createEmbelishments(): Embelishment[];\n\n  /**\n   * Creates the atom view for this beat view.\n   * @returns The created atom view, or null if the beat has no renderable content\n   */\n  protected abstract createAtomView(): AtomView | null;\n}\n","import * as TSU from \"@panyam/tsutils\";\nimport { Embelishment } from \"../shapes\";\nimport { GridCell, GridCellView } from \"../grids\";\nimport { ElementShape } from \"../shapes\";\nimport { createAtomView } from \"./atomviews\";\nimport { Marker } from \"../core\";\nimport { Beat } from \"../beats\";\nimport { BeatView as BeatViewBase } from \"../beatview\";\nimport { BeatStartLines, BeatEndLines } from \"./embelishments\";\n\n/**\n * View for rendering markers in dedicated grid columns.\n * MarkerView displays the text content of label markers in pre/post columns\n * adjacent to beat cells, separate from the main beat content.\n *\n * This is used by the grid layout system to render `\\@label()` markers in\n * their own columns, ensuring proper alignment across rows.\n */\nexport class MarkerView extends ElementShape<SVGGElement> implements GridCellView {\n  needsLayout = true;\n  rootGroup: SVGGElement;\n  textElement: SVGTextElement;\n  constructor(\n    public readonly cell: GridCell,\n    public readonly beat: Beat,\n    public readonly markers: Marker[],\n    public readonly isPreMarker: boolean,\n    public readonly rootElement: SVGGraphicsElement,\n    config?: any,\n  ) {\n    const rootGroup = TSU.DOM.createSVGNode(\"g\", {\n      parent: rootElement,\n      attrs: {\n        class: \"markerView\",\n        pre: isPreMarker,\n        roleName: beat.role.name,\n        beatIndex: \"\" + beat.index,\n        gridRow: cell.rowIndex,\n        gridCol: cell.colIndex,\n      },\n    });\n    super(rootGroup);\n    this.rootGroup = rootGroup as SVGGElement;\n    this.textElement = TSU.DOM.createSVGNode(\"text\", {\n      parent: rootGroup,\n      attrs: {\n        class: \"markerText\",\n        pre: isPreMarker,\n        dx: isPreMarker ? 0 : 15,\n      },\n      text: this.markers[0].text,\n    });\n  }\n\n  protected refreshMinSize(): TSU.Geom.Size {\n    const ts = TSU.DOM.svgBBox(this.textElement);\n    const totalWidth = ts.width;\n    const maxHeight = ts.height;\n    return new TSU.Geom.Size(totalWidth + 5, maxHeight + 5);\n  }\n\n  refreshLayout(): void {\n    // TODO - move this code out to refreshLayout?\n    // set the glyphs Y first so we can layout others\n    this.rootGroup.setAttribute(\"transform\", \"translate(\" + this.x + \",\" + this.y + \")\");\n  }\n\n  protected updateBounds(\n    x: null | number,\n    y: null | number,\n    w: null | number,\n    h: null | number,\n  ): [number | null, number | null, number | null, number | null] {\n    return [x, y, NaN, NaN];\n  }\n}\n\nexport class BeatView extends BeatViewBase {\n  createAtomView() {\n    // Use contentAtom to exclude markers (they're rendered in separate pre/post columns)\n    const atom = this.beat.contentAtom;\n    if (!atom) return null;\n    return createAtomView(this.element, atom, this.beat.role.defaultToNotes);\n  }\n\n  /**\n   * Refreshes the layout of this beat view.\n   *\n   * This method propagates the column width from the grid layout system to\n   * the atomView, enabling duration-based positioning within beats to use\n   * consistent widths across the entire column.\n   *\n   * ### Width Propagation Flow:\n   * ```\n   * ColAlign.setOffset()  BeatView.setBounds(width)  atomView.setBounds(width)\n   *                                                   atomView.refreshLayout()\n   * ```\n   *\n   * This ensures that atoms within different beats of the same column are\n   * aligned based on their time offset, creating a visually consistent grid.\n   */\n  refreshLayout(): void {\n    const newX = this.hasX ? this._x : 0;\n    const newY = this.hasY ? this._y : 0;\n    this.element.setAttribute(\"transform\", \"translate(\" + newX + \",\" + newY + \")\");\n\n    // Propagate column width to atomView for duration-based layout\n    // This enables global alignment across beats in the same column\n    // atomView may be null if beat contains only markers\n    if (this.hasWidth && this.atomView) {\n      this.atomView.setBounds(0, 0, this.width, null, false);\n      this.atomView.refreshLayout();\n    }\n\n    this.invalidateBounds();\n    for (const e of this.embelishments) e.refreshLayout();\n    this.invalidateBounds();\n  }\n\n  protected createEmbelishments(): Embelishment[] {\n    let embelishments: Embelishment[] = [];\n    const beat = this.beat;\n    // TODO - Should this be the group's parent element?\n    const rootElement = this.rootElement;\n    if (beat.beatIndex == 0 && beat.barIndex == 0 && beat.instance == 0) {\n      // first beat in bar - Do a BarStart\n      const emb = new BeatStartLines(this, rootElement);\n      embelishments = [emb];\n    } else {\n      const cycle = this.cycle;\n      const bar = cycle.bars[beat.barIndex];\n      if (beat.beatIndex == bar.beatCount - 1) {\n        // It is important that we are not just looking at the last beat of the bar\n        // but also in the last \"instance\" of the beat in this bar to account for\n        // kalais\n        if (beat.instance == bar.instanceCount(beat.beatIndex) - 1) {\n          if (beat.barIndex == cycle.bars.length - 1) {\n            // last beat in last bar so - do a thalam end (2 lines)\n            const emb = new BeatEndLines(this, rootElement, 2);\n            embelishments = [emb];\n          } else {\n            // end of a bar so single line end\n            const emb = new BeatEndLines(this, rootElement);\n            embelishments = [emb];\n          }\n        }\n      }\n    }\n    return embelishments;\n  }\n}\n","import * as TSU from \"@panyam/tsutils\";\nimport { AtomType, Marker, Group, Line, Atom, Space, Role } from \"./\";\nimport { CycleIterator, CyclePosition } from \"./cycle\";\nimport { WindowIterator } from \"./iterators\";\nimport { LayoutParams } from \"./layouts\";\nimport { GridModel, GridRow, GridCell, ColAlign, GridLayoutGroup } from \"./grids\";\nimport { Block, BlockItem, isLine, isBlock } from \"./notation\";\n\ntype Fraction = TSU.Num.Fraction;\nconst ZERO = TSU.Num.Fraction.ZERO;\nconst ONE = TSU.Num.Fraction.ONE;\n\n/**\n * Represents a single beat in the notation.\n * A beat contains one or more atoms and has a specific position in a bar.\n */\nexport class Beat {\n  private static idCounter = 0;\n  readonly uuid = Beat.idCounter++;\n  // Should this be as flat Atoms or should we keep it as atoms and breakdown later?\n\n  /** The atom contained in this beat */\n  atom: Atom;\n  protected atomIsPlaceholder = false;\n\n  /**\n   * Creates a new Beat.\n   * @param index The index of this beat in the sequence\n   * @param role The role this beat belongs to\n   * @param offset The time offset of this beat from the start\n   * @param duration The duration of this beat\n   * @param barIndex The index of the bar containing this beat\n   * @param beatIndex The index of this beat within its bar\n   * @param instance The instance number of this beat\n   * @param prevBeat The previous beat in the sequence, if any\n   * @param nextBeat The next beat in the sequence, if any\n   */\n  constructor(\n    public readonly index: number,\n    public readonly role: Role,\n    public readonly offset: Fraction,\n    public readonly duration: Fraction,\n    public readonly barIndex: number,\n    public readonly beatIndex: number,\n    public readonly instance: number,\n    public readonly prevBeat: null | Beat,\n    public nextBeat: null | Beat,\n  ) {}\n\n  /**\n   * Returns a debug-friendly representation of this Beat.\n   * @returns An object containing debug information\n   */\n  debugValue(): any {\n    return {\n      index: this.index,\n      role: this.role.name,\n      offset: this.offset.toString(),\n      duration: this.duration.toString(),\n      barIndex: this.barIndex,\n      beatIndex: this.beatIndex,\n      instance: this.instance,\n      atom: this.atom.debugValue(),\n    };\n  }\n\n  /**\n   * Gets the end offset of this beat (offset + duration).\n   */\n  get endOffset(): Fraction {\n    return this.offset.plus(this.duration);\n  }\n\n  /**\n   * Checks if this beat is filled completely (no remaining space).\n   */\n  get filled(): boolean {\n    return this.remaining.isZero;\n  }\n\n  /**\n   * Gets the remaining duration available in this beat.\n   */\n  get remaining(): Fraction {\n    return this.atom ? this.duration.minus(this.atom.duration, true) : this.duration;\n  }\n\n  /**\n   * Adds an atom to this beat.\n   * @param atom The atom to add\n   * @returns True if the atom was added successfully, false if there's not enough space\n   */\n  add(atom: Atom): boolean {\n    if (this.remaining.cmp(atom.duration) < 0) {\n      return false;\n    }\n    if (!this.atom) {\n      this.atom = atom;\n    } else {\n      if (!this.atomIsPlaceholder) {\n        this.atomIsPlaceholder = true;\n        this.atom = new Group(this.atom).setDuration(ONE, true);\n      }\n      (this.atom as Group).addAtoms(true, atom);\n    }\n    return true;\n  }\n\n  /**\n   * Gets all markers that should be displayed before this beat.\n   * Extracts Marker atoms with position=\"before\" from the beat's content.\n   * @returns An array of Marker objects with position=\"before\"\n   */\n  get preMarkers(): Marker[] {\n    return this.getMarkersWithPosition(\"before\");\n  }\n\n  /**\n   * Gets all markers that should be displayed after this beat.\n   * Extracts Marker atoms with position=\"after\" from the beat's content.\n   * @returns An array of Marker objects with position=\"after\"\n   */\n  get postMarkers(): Marker[] {\n    return this.getMarkersWithPosition(\"after\");\n  }\n\n  /**\n   * Extracts Marker atoms with the specified position from the beat's content.\n   * @param position The position to filter by (\"before\" or \"after\")\n   * @returns An array of matching Marker objects\n   */\n  private getMarkersWithPosition(position: \"before\" | \"after\"): Marker[] {\n    const out: Marker[] = [];\n    if (!this.atom) return out;\n\n    // If the atom is a Group, iterate through its children\n    if (this.atom.TYPE === AtomType.GROUP) {\n      const group = this.atom as Group;\n      for (const child of group.atoms.values()) {\n        if (child.TYPE === AtomType.MARKER) {\n          const marker = child as Marker;\n          if (marker.position === position) {\n            out.push(marker);\n          }\n        }\n      }\n    } else if (this.atom.TYPE === AtomType.MARKER) {\n      // Single marker atom\n      const marker = this.atom as Marker;\n      if (marker.position === position) {\n        out.push(marker);\n      }\n    }\n\n    return out;\n  }\n\n  /**\n   * Gets the content atom for rendering, with markers filtered out.\n   * If the beat contains only markers, returns null.\n   * Otherwise returns the original atom (views should skip markers during rendering).\n   * @returns The content atom, or null if only markers exist\n   */\n  get contentAtom(): Atom | null {\n    if (!this.atom) return null;\n\n    // Single marker atom - no content to render\n    if (this.atom.TYPE === AtomType.MARKER) {\n      return null;\n    }\n\n    // Not a group - return as-is (it's not a marker at this point)\n    if (this.atom.TYPE !== AtomType.GROUP) {\n      return this.atom;\n    }\n\n    // Group - check if it has any non-marker content\n    const group = this.atom as Group;\n    let hasNonMarkerContent = false;\n    for (const child of group.atoms.values()) {\n      if (child.TYPE !== AtomType.MARKER) {\n        hasNonMarkerContent = true;\n        break;\n      }\n    }\n\n    // If all atoms are markers, return null\n    // Otherwise return the original group (view will skip markers during iteration)\n    return hasNonMarkerContent ? this.atom : null;\n  }\n}\n\n/**\n * Builds a sequence of beats from atoms according to layout parameters.\n * Used to convert a flat sequence of atoms into structured beats for display.\n */\nexport class BeatsBuilder {\n  /** All atoms divided into beats */\n  readonly beats: Beat[] = [];\n  readonly startIndex: number;\n  readonly beatOffset: Fraction;\n  cycleIter: CycleIterator;\n  windowIter: WindowIterator;\n\n  /** Callback for when an atom is added to this role */\n  onAtomAdded: (atom: Atom, beat: Beat) => void;\n\n  /** Callback for when a new beat is added */\n  onBeatAdded: (beat: Beat) => void;\n\n  /** Callback for when a beat has been filled */\n  onBeatFilled: (beat: Beat) => void;\n\n  /**\n   * Creates a new BeatsBuilder.\n   * @param role The role containing the atoms\n   * @param layoutParams Layout parameters for structuring beats\n   * @param startOffset The starting offset for the first beat, defaults to ZERO\n   * @param atoms Initial atoms to add to the beats\n   */\n  constructor(\n    public readonly role: Role,\n    public readonly layoutParams: LayoutParams,\n    public readonly startOffset: Fraction = ZERO,\n    ...atoms: Atom[]\n  ) {\n    const [, [bar, beat, instance], beatOffset, index] = layoutParams.cycle.getPosition(startOffset);\n    this.cycleIter = layoutParams.cycle.iterateBeats(bar, beat, instance);\n    this.windowIter = new WindowIterator();\n    this.beatOffset = beatOffset;\n\n    // evaluate the start beatindex - typically it would be 0 if things start\n    // at beginning of a cycle.  But if the start offset is < 0 then the\n    // startIndex should also shift accordingly\n    this.startIndex = index;\n    this.addAtoms(...atoms);\n  }\n\n  /**\n   * Adds atoms to be processed into beats.\n   * @param atoms The atoms to add\n   */\n  addAtoms(...atoms: Atom[]): void {\n    // First add all atoms to the atom Iterator so we can\n    // fetch them as FlatAtoms.  This is needed because atoms\n    // passed here could be unflatted (via groups) or much larger\n    // than what can fit in the given role/bar etc.  So this\n    // flattening and windowing is needed before we add them\n    // to the views - and this is done by the durationIterators.\n    this.windowIter.push(...atoms);\n    while (this.windowIter.hasMore) {\n      // get the last/current row and add a new one if it is full\n      let currBeat = this.beats[this.beats.length - 1];\n\n      // First add a row if last row is filled\n      if (this.beats.length == 0 || currBeat.filled) {\n        // what should be the beatlengths be here?\n        currBeat = this.addBeat();\n      }\n\n      // For this beat get symbols in all roles\n      const [remAtoms, filled] = this.windowIter.get(currBeat.remaining);\n      TSU.assert(remAtoms.length > 0, \"Atleast one element should have been available here\");\n      // render the atoms now\n      for (const atom of remAtoms) {\n        // console.log(\"Adding FA: \", flatAtom.debugValue(), flatAtom.atom);\n        TSU.assert(currBeat.add(atom), \"Should return true as we are already using a duration iterator here\");\n        if (this.onAtomAdded) this.onAtomAdded(atom, currBeat);\n      }\n      if (currBeat.filled) {\n        if (this.onBeatFilled) this.onBeatFilled(currBeat);\n      }\n    }\n  }\n\n  /**\n   * Adds a new beat to the sequence.\n   * @returns The newly created beat\n   */\n  protected addBeat(): Beat {\n    const numBeats = this.beats.length;\n    const lastBeat = numBeats == 0 ? null : this.beats[numBeats - 1];\n    const nextCP: [CyclePosition, Fraction] = this.cycleIter.next().value;\n    const apb = this.layoutParams.beatDuration;\n    const newBeat = new Beat(\n      lastBeat == null ? this.startIndex : lastBeat.index + 1,\n      this.role,\n      lastBeat == null ? this.startOffset.minus(this.beatOffset).timesNum(apb, true) : lastBeat.endOffset,\n      nextCP[1].timesNum(apb),\n      nextCP[0][0],\n      nextCP[0][1],\n      nextCP[0][2],\n      lastBeat,\n      null,\n    );\n    if (lastBeat == null && this.beatOffset.isGT(ZERO)) {\n      // Add spaces to fill up empty beats\n      newBeat.add(new Space(this.beatOffset.timesNum(apb)));\n    }\n    if (lastBeat) lastBeat.nextBeat = newBeat;\n    this.beats.push(newBeat);\n    if (this.onBeatAdded) this.onBeatAdded(newBeat);\n    return newBeat;\n  }\n}\n\n/**\n * Represents a column of beats in a layout grid.\n * Used for aligning beats vertically in the notation.\n */\nexport class BeatColumn extends ColAlign {\n  /** Spacing between atoms in this column */\n  atomSpacing = 2;\n  /** Unique key for this column */\n  readonly key: string;\n\n  /**\n   * Creates a new BeatColumn.\n   * @param offset The starting offset of this column\n   * @param endOffset The ending offset of this column\n   * @param markerType The type of marker for this column (negative: before, positive: after, zero: normal)\n   */\n  constructor(\n    public readonly offset: Fraction,\n    public readonly endOffset: Fraction,\n    public readonly markerType: number,\n  ) {\n    super();\n    offset = offset.factorized;\n    endOffset = endOffset.factorized;\n    this.key = BeatColumn.keyFor(offset, endOffset, markerType);\n  }\n\n  /**\n   * Generates a key for identifying columns with the same offsets and marker type.\n   * @param offset The starting offset\n   * @param endOffset The ending offset\n   * @param markerType The type of marker (negative: before, positive: after, zero: normal)\n   * @returns A string key\n   */\n  static keyFor(offset: Fraction, endOffset: Fraction, markerType = 0): string {\n    offset = offset.factorized;\n    endOffset = endOffset.factorized;\n    if (markerType < 0) {\n      // return the column for the marker \"before\" this col\n      // int his case only the \"start offset\" is needed and length doesnt matter\n      return \":\" + offset.toString();\n    } else if (markerType > 0) {\n      // return the column for the marker \"after\" this col\n      // in this case only thd end offset matters\n      return endOffset.toString() + \":\";\n    } else {\n      return offset.toString() + \":\" + endOffset.toString();\n    }\n  }\n}\n\n/**\n * Manages the organization of beats into columns based on their offsets.\n * Used to create a directed acyclic graph (DAG) of beat columns for layout purposes.\n *\n * Grouping of beats by their column based on the layout params.\n * The confusion is we have beats broken up and saved in columns\n * but we are loosing how a line is supposed to access it in its own way\n * we have beatsByRole for getting all beats for a role (in a line)\n * sequentially we have beatColumns for getting all beats in a particular\n * column across all lines and roles globally.\n *\n * What we want here is for a given line get all roles, their beats\n * in zipped way.  eg for a Line with 3 roles and say 10 beats each\n * (with the breaks of 4, 1) we need:\n *\n * R1 B1 R1 B2 R1 B3 R1 B4\n * R2 B1 R2 B2 R2 B3 R2 B4\n * R3 B1 R3 B2 R3 B3 R3 B4\n *\n * R1 B5\n * R2 B5\n * R3 B5\n *\n * R1 B6 R1 B7 R1 B8 R1 B9\n * R2 B6 R2 B7 R2 B8 R2 B9\n * R3 B6 R3 B7 R3 B8 R3 B9\n *\n * R1 B10\n * R2 B10\n * R3 B10\n *\n *\n * Here we have 5 distinct beat columns:\n *\n * 1: R1B1, R2B1, R3B1, R1B6, R2B6, R3B6,\n * 2: R1B2, R2B2, R3B2, R1B7, R2B7, R3B7,\n * 3: R1B3, R2B3, R3B3, R1B8, R2B8, R3B8,\n * 4: R1B4, R2B4, R3B4, R1B9, R2B9, R3B9,\n * 5: R1B5, R2B5, R3B5, R1B10, R2B10, R3B10,\n *\n */\nexport class BeatColDAG {\n  /** Map of column keys to BeatColumn objects */\n  beatColumns = new Map<string, BeatColumn>();\n\n  /**\n   * Creates a new BeatColDAG.\n   * @param layoutGroup The layout group to associate with this DAG\n   */\n  constructor(public readonly layoutGroup: GridLayoutGroup) {\n    //\n  }\n\n  /**\n   * Gets the beat column for a given duration at the specified offset.\n   * Creates a new column if none exists.\n   * @param offset The starting offset\n   * @param endOffset The ending offset\n   * @param markerType The type of marker\n   * @returns The BeatColumn for the specified parameters\n   */\n  getBeatColumn(offset: Fraction, endOffset: Fraction, markerType = 0): BeatColumn {\n    const [bcol, newcreated] = this.ensureBeatColumn(offset, endOffset, markerType);\n    if (newcreated) {\n      if (markerType == 0) {\n        const [prevcol] = this.ensureBeatColumn(offset, endOffset, -1);\n        const [nextcol] = this.ensureBeatColumn(offset, endOffset, 1);\n        prevcol.addSuccessor(bcol);\n        bcol.addSuccessor(nextcol);\n        for (const other of this.beatColumns.values()) {\n          // only join the \"marker\" columns\n          if (other.markerType == -1 && endOffset.equals(other.offset)) {\n            // our next col is a preecessor of other\n            nextcol.addSuccessor(other);\n          } else if (other.markerType == 1 && other.endOffset.equals(offset)) {\n            // our prev col is a predecessor of other\n            other.addSuccessor(prevcol);\n          }\n        }\n      }\n    }\n    return bcol;\n  }\n\n  /**\n   * Ensures a beat column exists for the given parameters.\n   * @param offset The starting offset\n   * @param endOffset The ending offset\n   * @param markerType The type of marker\n   * @returns A tuple containing the column and whether it was newly created\n   */\n  protected ensureBeatColumn(offset: Fraction, endOffset: Fraction, markerType = 0): [BeatColumn, boolean] {\n    const key = BeatColumn.keyFor(offset, endOffset, markerType);\n    let bcol = this.beatColumns.get(key) || null;\n    const newcreated = bcol == null;\n    if (!bcol) {\n      bcol = new BeatColumn(offset, endOffset, markerType);\n      this.beatColumns.set(key, bcol);\n    }\n    return [bcol, newcreated];\n  }\n}\n\n/** Type alias for line IDs */\ntype LineId = number;\n/** Type alias for layout parameter IDs */\ntype LPID = number;\n\n/**\n * Manages the beat layouts for all lines in a notation.\n * Handles the creation of grid models, positioning of beats, and alignment of beats across lines.\n */\nexport class GlobalBeatLayout {\n  /** Map of line IDs to grid models */\n  gridModelsForLine = new Map<LineId, GridModel>();\n  /** Map of line IDs to arrays of beats for each role */\n  roleBeatsForLine = new Map<LineId, Beat[][]>();\n  /** Map of layout parameter IDs to beat column DAGs */\n  beatColDAGsByLP = new Map<LPID, BeatColDAG>();\n  /** The global layout group for all grid models */\n  readonly gridLayoutGroup: GridLayoutGroup;\n\n  /**\n   * Creates a new GlobalBeatLayout.\n   * @param sharedGridLayoutGroup Optional shared GridLayoutGroup for column alignment across multiple views.\n   *                               If not provided, a new GridLayoutGroup is created internally.\n   */\n  constructor(sharedGridLayoutGroup?: GridLayoutGroup) {\n    this.gridLayoutGroup = sharedGridLayoutGroup ?? new GridLayoutGroup();\n  }\n\n  /**\n   * Gets the GridModel associated with a particular line, creating one if it doesn't exist.\n   * @param lineid The ID of the line\n   * @returns The GridModel for the line\n   */\n  getGridModelForLine(lineid: LineId): GridModel {\n    let out = this.gridModelsForLine.get(lineid) || null;\n    if (!out) {\n      out = new GridModel();\n      this.gridLayoutGroup.addGridModel(out);\n      this.gridModelsForLine.set(lineid, out);\n    }\n    return out;\n  }\n\n  /**\n   * Gets the BeatColDAG for a specific layout parameter ID, creating one if it doesn't exist.\n   * @param lpid The layout parameter ID\n   * @returns The BeatColDAG for the layout parameters\n   */\n  protected beatColDAGForLP(lpid: LPID): BeatColDAG {\n    let out = this.beatColDAGsByLP.get(lpid) || null;\n    if (!out) {\n      out = new BeatColDAG(this.gridLayoutGroup);\n      this.beatColDAGsByLP.set(lpid, out);\n    }\n    return out;\n  }\n\n  /**\n   * Adds a line to the beat layout.\n   * This ensures that a line is broken down into beats and added into a dedicated GridModel.\n   *\n   * A line must also be given the layout params by which the beat breakdown will happen.\n   * This LayoutParams object does not have to be unique per line (this non-constraint allows\n   * beats to be aligned across lines).\n   *\n   * @param line The line to add\n   */\n  addLine(line: Line): void {\n    const gridModel = this.getGridModelForLine(line.uuid) as GridModel;\n    gridModel.eventHub?.startBatchMode();\n    this.lineToRoleBeats(line, gridModel);\n    gridModel.eventHub?.commitBatch();\n  }\n\n  /**\n   * Recursively processes a block and its children to build beat layouts.\n   * Uses block.children() to get expanded children (e.g., RepeatBlock expands to N copies).\n   *\n   * @param block The block to process\n   */\n  processBlock(block: Block): void {\n    for (const child of block.children()) {\n      this.processBlockItem(child);\n    }\n  }\n\n  /**\n   * Processes a single block item (Block, Line, or RawBlock).\n   *\n   * @param item The item to process\n   */\n  protected processBlockItem(item: BlockItem): void {\n    if (isLine(item)) {\n      const line = item as Line;\n      if (!line.isEmpty && line.layoutParams != null) {\n        this.addLine(line);\n      }\n    } else if (isBlock(item)) {\n      this.processBlock(item as Block);\n    }\n    // RawBlocks are ignored (no beat layout for raw content)\n  }\n\n  /**\n   * Converts a line into a series of beats for each role.\n   * @param line The line to convert\n   * @param gridModel The grid model to use\n   * @returns Arrays of beats for each role\n   */\n  protected lineToRoleBeats(line: Line, gridModel: GridModel): Beat[][] {\n    const lp = line.layoutParams;\n    const roleBeats = [] as Beat[][];\n    this.roleBeatsForLine.set(line.uuid, roleBeats);\n    const lineOffset = line.offset.divbyNum(lp.beatDuration);\n    for (const role of line.roles) {\n      const bb = new BeatsBuilder(role, lp, lineOffset, ...role.atoms);\n      roleBeats.push(bb.beats);\n\n      // Add these to the beat layout too\n      for (const beat of bb.beats) {\n        // beat.ensureUniformSpaces(layoutParams.beatDuration);\n        this.addBeat(beat, gridModel);\n      }\n    }\n    return roleBeats;\n  }\n\n  /**\n   * Adds a beat to the layout.\n   * @param beat The beat to add\n   * @param gridModel The grid model to add the beat to\n   * @returns The grid cell containing the beat\n   */\n  protected addBeat(beat: Beat, gridModel: GridModel): GridCell {\n    // Get the beat column at this index (and line) and add to it.\n    const line = beat.role.line;\n    const lp = line.layoutParams;\n    const beatColDAG = this.beatColDAGForLP(lp.uuid);\n    const [layoutLine, layoutColumn, rowOffset] = lp.getBeatLocation(beat);\n    const colEnd = rowOffset.plus(beat.duration, true);\n    const bcol = beatColDAG.getBeatColumn(rowOffset, colEnd, 0);\n\n    // Since a beat's column has a \"pre\" and \"post\" col to, each\n    // beat has 3 columns for it\n    const roleIndex = beat.role.line.indexOfRole(beat.role.name);\n    const nthLine = Math.floor(beat.index / lp.totalBeats);\n    const realLine = lp.lineBreaks.length * nthLine + layoutLine;\n    const realRow = line.roles.length * realLine + roleIndex;\n    // pre marker goes on realCol - 1, post marker goes on realCol + 1\n    const realCol = 1 + layoutColumn * 3;\n    const preMarkers = beat.preMarkers;\n    if (preMarkers.length > 0) {\n      const val = {\n        beat: beat,\n        markers: preMarkers,\n      };\n      const precol = beatColDAG.getBeatColumn(rowOffset, colEnd, -1);\n      gridModel.setValue(realRow, realCol - 1, val, (gridRow: GridRow, col: number) => {\n        const cell = new GridCell(gridRow, col);\n        cell.colAlign = precol;\n        return cell;\n      });\n    }\n    const postMarkers = beat.postMarkers;\n    if (postMarkers.length > 0) {\n      const val = {\n        beat: beat,\n        markers: postMarkers,\n      };\n      const postcol = beatColDAG.getBeatColumn(rowOffset, colEnd, 1);\n      gridModel.setValue(realRow, realCol + 1, val, (gridRow: GridRow, col: number) => {\n        const cell = new GridCell(gridRow, col);\n        cell.colAlign = postcol;\n        return cell;\n      });\n    }\n    return gridModel.setValue(realRow, realCol, beat, (gridRow: GridRow, col: number) => {\n      const cell = new GridCell(gridRow, col);\n      cell.colAlign = bcol;\n      return cell;\n    });\n  }\n}\n","import * as TSU from \"@panyam/tsutils\";\nimport { Entity, TimedEntity, CmdParam, ParamsMixin } from \"./entity\";\nimport { LayoutParams } from \"./layouts\";\nimport { AtomChangeType, GroupObserver, RoleObserver, LineObserver } from \"./events\";\n\n/**\n * Alias to TSU.Num.Fraction in tsutils.\n */\ntype Fraction = TSU.Num.Fraction;\nexport const ZERO = TSU.Num.Fraction.ZERO;\nexport const ONE = TSU.Num.Fraction.ONE;\n\n/**\n * AtomType enums are used to denote specific Atoms\n * Each type represents a specific musical or notational element.\n * @enum\n */\nexport enum AtomType {\n  NOTE = \"Note\",\n  LITERAL = \"Literal\",\n  SYLLABLE = \"Syllable\",\n  SPACE = \"Space\",\n  GROUP = \"Group\",\n  LABEL = \"Label\",\n  REST = \"Rest\",\n  MARKER = \"Marker\",\n}\n\n/**\n * Atoms are the base class for all timed entities that can appear in a Notation.\n * An Atom represents the fundamental building block of the notation system.\n */\nexport abstract class Atom extends TimedEntity {\n  readonly TYPE: string = \"Atom\";\n\n  protected _duration: Fraction;\n  /** Next atom in the sequence */\n  nextSibling: TSU.Nullable<Atom> = null;\n  /** Previous atom in the sequence */\n  prevSibling: TSU.Nullable<Atom> = null;\n  /** The Group this Atom belongs to, if any */\n  parentGroup: TSU.Nullable<Group> = null;\n\n  /** Indicates if this Atom is a continuation from a previous atom */\n  isContinuation = false;\n\n  /**\n   * Creates a new Atom with the specified duration.\n   * @param duration The duration of the atom, defaults to ONE (1/1)\n   */\n  constructor(duration = ONE) {\n    super();\n    this._duration = duration || ONE;\n  }\n\n  /**\n   * Whether this atom participates in timing calculations.\n   * Most atoms (notes, spaces) participate in timing.\n   * Markers do not - they exist at a point but don't advance time.\n   */\n  get participatesInTiming(): boolean {\n    return true;\n  }\n\n  /**\n   * Splits this atom at the specified duration.\n   * @param requiredDuration The duration at which to split the atom\n   * @returns A new atom representing the portion beyond the split point, or null if no split is needed\n   */\n  abstract splitAt(requiredDuration: Fraction): TSU.Nullable<Atom>;\n\n  /**\n   * Returns a debug-friendly representation of this Atom.\n   * @returns An object containing debug information\n   */\n  debugValue(): any {\n    const out = super.debugValue();\n    if (!this.duration.isOne) {\n      out.duration = this.duration.factorized.toString();\n    }\n    if (this.isContinuation) {\n      out.isContinuation = true;\n    }\n    return out;\n  }\n\n  /**\n   * Copies the properties of this atom to another atom.\n   * @param another The target atom to copy properties to\n   */\n  copyTo(another: this): void {\n    super.copyTo(another);\n    another._duration = new TSU.Num.Fraction(this.duration.num, this.duration.den);\n  }\n\n  /**\n   * Gets the duration of this atom.\n   */\n  get duration(): Fraction {\n    return this._duration;\n  }\n\n  /**\n   * Sets the duration of this atom.\n   */\n  set duration(d: Fraction) {\n    this._duration = d;\n  }\n}\n\n/**\n * Base class for atoms that cannot contain other atoms.\n * LeafAtom represents atomic elements that can't be further subdivided.\n */\nexport abstract class LeafAtom extends Atom {\n  readonly TYPE: string = \"LeafAtom\";\n\n  /** Indicates if this atom is followed by a rest */\n  beforeRest = false;\n\n  /**\n   * Splits this atom at a certain duration.\n   * If this atom's duration is longer than the given duration, it's truncated\n   * to the given duration and a continuation space is returned.\n   *\n   * @param duration The duration at which to split the atom\n   * @returns A new Space atom representing the spillover if needed, otherwise null\n   */\n  splitAt(duration: Fraction): TSU.Nullable<Atom> {\n    if (this.duration.cmp(duration) > 0) {\n      const spillOver = this.createSpilloverSpace(this.duration.minus(duration));\n      spillOver.isContinuation = true;\n      this.duration = duration;\n      // TODO - Here we need to move the markersAfter to the spill-over as it doesnt belong to this any more\n      return spillOver;\n    }\n    return null;\n  }\n\n  /**\n   * Creates a Space atom to represent spillover duration when splitting.\n   * @param duration The duration of the spillover\n   * @returns A new Space atom\n   */\n  protected createSpilloverSpace(duration: Fraction): Space {\n    return new Space(duration);\n  }\n\n  /**\n   * Returns a debug-friendly representation of this LeafAtom.\n   * @returns An object containing debug information\n   */\n  debugValue(): any {\n    return this.beforeRest ? { ...super.debugValue(), beforeRest: true } : super.debugValue();\n  }\n}\n\n// Apply ParamsMixin to LeafAtom for Marker base class\nconst LeafAtomWithParams = ParamsMixin(LeafAtom);\n\n/**\n * Represents a marker or annotation in the notation.\n * Markers are standalone atoms that exist at a point in the timeline\n * but do not participate in timing calculations.\n *\n * Syntax: \\@markerName(params...)\n * Examples:\n *   \\@label(\"Variation 1\")\n *   \\@label(\"End\", position=\"after\")\n *   \\@slide(duration=2)\n */\nexport class Marker extends LeafAtomWithParams {\n  readonly TYPE = \"Marker\";\n\n  /**\n   * Creates a new Marker with the specified name and parameters.\n   * @param name The marker type name (e.g., \"label\", \"slide\"), normalized to lowercase\n   * @param params The parameters for this marker (same structure as command params)\n   */\n  constructor(\n    public name: string,\n    params: CmdParam[] = [],\n  ) {\n    super(ZERO); // Markers have zero duration by default\n    this.name = name.toLowerCase();\n    this.params = params;\n  }\n\n  /**\n   * Markers do not participate in timing calculations.\n   * They exist at a point in the timeline but don't advance time.\n   */\n  get participatesInTiming(): boolean {\n    return false;\n  }\n\n  /**\n   * Convenience accessor for the text/label of the marker.\n   * Typically the first positional parameter.\n   */\n  get text(): string {\n    // First positional param is typically the text\n    const firstParam = this.params.find((p) => p.key === null);\n    return firstParam?.value ?? \"\";\n  }\n\n  /**\n   * Convenience accessor for the position hint.\n   * @returns \"before\" or \"after\", defaults to \"before\"\n   */\n  get position(): \"before\" | \"after\" {\n    const pos = this.getParam(\"position\");\n    return pos === \"after\" ? \"after\" : \"before\";\n  }\n\n  /**\n   * Returns a debug-friendly representation of this Marker.\n   * @returns An object containing debug information\n   */\n  debugValue(): any {\n    return {\n      type: this.TYPE,\n      name: this.name,\n      params: this.params,\n    };\n  }\n\n  /**\n   * Returns a string representation of this Marker.\n   * @returns A string representation\n   */\n  toString(): string {\n    return `Marker(@${this.name}, ${JSON.stringify(this.params)})`;\n  }\n}\n\n/**\n * Represents a rest (silence) in the notation.\n * Rests are zero-length atoms that indicate a pause.\n */\nexport class Rest extends LeafAtom {\n  readonly TYPE = \"Rest\";\n\n  /**\n   * Creates a new Rest.\n   * Rests are zero length by default.\n   */\n  constructor() {\n    super(ZERO);\n  }\n}\n\n/**\n * Represents a space or silence in the notation.\n * Spaces can be used to denote either silence or continuations of previous notes.\n */\nexport class Space extends LeafAtom {\n  readonly TYPE = \"Space\";\n\n  /**\n   * Indicates whether this is a silent space or a continuation of the previous note.\n   */\n  isSilent = false;\n\n  /**\n   * Creates a new Space with the specified duration and silence property.\n   * @param duration The duration of the space, defaults to ONE (1/1)\n   * @param isSilent Whether the space represents silence (true) or a continuation (false)\n   */\n  constructor(duration = ONE, isSilent = false) {\n    super(duration);\n    this.isSilent = isSilent;\n  }\n\n  /**\n   * Returns a debug-friendly representation of this Space.\n   * @returns An object containing debug information\n   */\n  debugValue(): any {\n    return { ...super.debugValue(), isSilent: this.isSilent };\n  }\n\n  /**\n   * Returns a string representation of this Space.\n   * @returns A string representation\n   */\n  toString(): string {\n    return `Space(${this.duration}-${this.isSilent})`;\n  }\n\n  /**\n   * Copies the properties of this Space to another Space.\n   * @param another The target Space to copy properties to\n   */\n  copyTo(another: this): void {\n    super.copyTo(another);\n    another.isSilent = this.isSilent;\n  }\n\n  /**\n   * Checks if this Space is equal to another Space.\n   * @param another The Space to compare with\n   * @returns True if the Spaces are equal, false otherwise\n   */\n  equals(another: this): boolean {\n    return super.equals(another) && this.isSilent == another.isSilent;\n  }\n\n  /**\n   * Creates a Space atom to represent spillover duration when splitting.\n   * @param duration The duration of the spillover\n   * @returns A new Space atom with the same silence property as this Space\n   */\n  protected createSpilloverSpace(duration: Fraction): Space {\n    const out = super.createSpilloverSpace(duration);\n    out.isSilent = this.isSilent;\n    return out;\n  }\n}\n\n/**\n * Represents a literal value in the notation.\n * Literals are the basic building blocks for notes and syllables.\n */\nexport class Literal extends LeafAtom {\n  readonly TYPE: string = \"Literal\";\n\n  /**\n   * The embellishments applied to this Literal.\n   */\n  embelishments: any[] = [];\n\n  /**\n   * Creates a new Literal with the specified value and duration.\n   * @param value The string value of the literal\n   * @param duration The duration of the literal, defaults to ONE (1/1)\n   */\n  constructor(\n    public value: string,\n    duration = ONE,\n  ) {\n    super(duration);\n  }\n\n  /**\n   * Returns a debug-friendly representation of this Literal.\n   * @returns An object containing debug information\n   */\n  debugValue(): any {\n    const out = { ...super.debugValue(), value: this.value };\n    if (this.embelishments.length > 0) {\n      out.embs = this.embelishments.map((e) => (\"debugValue\" in e ? e.debugValue() : e));\n    }\n    return out;\n  }\n\n  /**\n   * Returns a string representation of this Literal.\n   * @returns A string representation\n   */\n  toString(): string {\n    return `Lit(${this.duration}-${this.value})`;\n  }\n\n  /**\n   * Checks if this Literal is equal to another Literal.\n   * @param another The Literal to compare with\n   * @returns True if the Literals are equal, false otherwise\n   */\n  equals(another: this): boolean {\n    return super.equals(another) && this.value == another.value;\n  }\n\n  /**\n   * Copies the properties of this Literal to another Literal.\n   * @param another The target Literal to copy properties to\n   */\n  copyTo(another: this): void {\n    super.copyTo(another);\n    another.value = this.value;\n  }\n}\n\n/**\n * Represents a syllable in lyrics or text to be sung.\n * Extends Literal to provide specialized handling for sung text.\n */\nexport class Syllable extends Literal {\n  readonly TYPE = \"Syllable\";\n\n  /**\n   * Creates a Syllable from a Literal.\n   * @param lit The Literal to convert to a Syllable\n   * @returns A new Syllable with the properties of the Literal\n   */\n  static fromLit(lit: Literal): Syllable {\n    if (lit.TYPE == AtomType.SYLLABLE) return lit as Syllable;\n    const out = new Syllable(lit.value, lit.duration);\n    out.embelishments = lit.embelishments;\n    out.beforeRest = lit.beforeRest;\n    return out;\n  }\n\n  /**\n   * Returns a string representation of this Syllable.\n   * @returns A string representation\n   */\n  toString(): string {\n    return `Syll(${this.duration}-${this.value})`;\n  }\n}\n\n/**\n * Represents a musical note in the notation.\n * Extends Literal to add properties specific to musical notes.\n */\nexport class Note extends Literal {\n  readonly TYPE = \"Note\";\n\n  /**\n   * Which octave the note is in. Can be positive or negative to indicate higher or lower octaves.\n   */\n  octave = 0;\n\n  /**\n   * How the note is shifted - i.e., shifted towards major or minor by # of semi-tones.\n   */\n  shift: number | boolean = 0;\n\n  /**\n   * Creates a new Note with the specified properties.\n   * @param value The string value of the note\n   * @param duration The duration of the note, defaults to ONE (1/1)\n   * @param octave The octave of the note, defaults to 0\n   * @param shift The shift of the note, defaults to 0\n   */\n  constructor(value: string, duration = ONE, octave = 0, shift = 0) {\n    super(value, duration);\n    this.octave = octave;\n    this.shift = shift;\n  }\n\n  /**\n   * Creates a Note from a Literal.\n   * @param lit The Literal to convert to a Note\n   * @returns A new Note with the properties of the Literal\n   */\n  static fromLit(lit: Literal): Note {\n    if (lit.TYPE == AtomType.NOTE) return lit as Note;\n    const out = new Note(lit.value, lit.duration);\n    out.embelishments = lit.embelishments;\n    out.beforeRest = lit.beforeRest;\n    return out;\n  }\n\n  /**\n   * Returns a debug-friendly representation of this Note.\n   * @returns An object containing debug information\n   */\n  debugValue(): any {\n    const out = { ...super.debugValue() };\n    if (this.octave != 0) out.octave = this.octave;\n    if (this.shift != 0) out.shift = this.shift;\n    return out;\n  }\n\n  /**\n   * Returns a string representation of this Note.\n   * @returns A string representation\n   */\n  toString(): string {\n    return `Note(${this.duration}-${this.value}-${this.octave})`;\n  }\n\n  /**\n   * Checks if this Note is equal to another Note.\n   * @param another The Note to compare with\n   * @returns True if the Notes are equal, false otherwise\n   */\n  equals(another: this): boolean {\n    return super.equals(another) && this.octave == another.octave && this.shift == another.shift;\n  }\n\n  /**\n   * Copies the properties of this Note to another Note.\n   * @param another The target Note to copy properties to\n   */\n  copyTo(another: this): void {\n    super.copyTo(another);\n    another.octave = this.octave;\n    another.shift = this.shift;\n  }\n}\n\n/**\n * Represents a group of atoms that are treated as a single unit.\n * Groups can contain any number of atoms, including other groups.\n */\nexport class Group extends Atom {\n  readonly TYPE = \"Group\";\n\n  /**\n   * Indicates whether the duration is static or linear to the number of atoms in this group.\n   * When true, the duration is used as a multiplier for the total child duration.\n   * When false, the duration is absolute.\n   */\n  durationIsSpeedMultiplier = false;\n\n  /**\n   * The list of atoms in this group.\n   */\n  readonly atoms = new TSU.Lists.ValueList<Atom>();\n\n  /**\n   * Observers that receive notifications when atoms change.\n   */\n  private _observers: GroupObserver<Atom, Group>[] = [];\n\n  /**\n   * Creates a new Group containing the specified atoms.\n   * @param atoms The atoms to include in this group\n   */\n  constructor(...atoms: Atom[]) {\n    super(atoms.length == 0 ? ZERO : ONE);\n    this.addAtoms(false, ...atoms);\n  }\n\n  /**\n   * Adds an observer to receive atom change notifications.\n   * @param observer The observer to add\n   * @returns A function to remove the observer\n   */\n  addObserver(observer: GroupObserver<Atom, Group>): () => void {\n    this._observers.push(observer);\n    return () => this.removeObserver(observer);\n  }\n\n  /**\n   * Removes an observer.\n   * @param observer The observer to remove\n   */\n  removeObserver(observer: GroupObserver<Atom, Group>): void {\n    const index = this._observers.indexOf(observer);\n    if (index >= 0) {\n      this._observers.splice(index, 1);\n    }\n  }\n\n  /**\n   * Notifies observers of atom changes.\n   */\n  private notifyObservers(type: AtomChangeType, atoms: Atom[], index: number): void {\n    if (!this._eventsEnabled) return;\n    for (const observer of this._observers) {\n      switch (type) {\n        case AtomChangeType.ADD:\n          observer.onAtomsAdded?.(this, atoms, index);\n          break;\n        case AtomChangeType.INSERT:\n          observer.onAtomsInserted?.(this, atoms, index);\n          break;\n        case AtomChangeType.REMOVE:\n          observer.onAtomsRemoved?.(this, atoms);\n          break;\n      }\n    }\n  }\n\n  /**\n   * Checks if this Group is equal to another Group.\n   * @param another The Group to compare with\n   * @param expect Optional parameter\n   * @returns True if the Groups are equal, false otherwise\n   */\n  equals(another: this, expect = false): boolean {\n    if (!super.equals(another)) return false;\n    return this.atoms.equals(another.atoms, (a1, a2) => a1.equals(a2));\n  }\n\n  /**\n   * Copies the properties of this Group to another Group.\n   * @param another The target Group to copy properties to\n   */\n  copyTo(another: this): void {\n    super.copyTo(another);\n    another.durationIsSpeedMultiplier = this.durationIsSpeedMultiplier;\n    for (const atom of this.atoms.values()) {\n      another.atoms.add(atom.clone());\n    }\n  }\n\n  /**\n   * Gets the duration of this group.\n   * If durationIsSpeedMultiplier is true, returns the total child duration divided by the multiplier.\n   * Otherwise, returns the absolute duration.\n   */\n  get duration(): Fraction {\n    if (this.durationIsSpeedMultiplier) {\n      return this.totalChildDuration.divby(this._duration);\n    } else {\n      return this._duration;\n    }\n  }\n\n  /**\n   * Sets this group to use a multiplier for duration calculations.\n   * @param asSpeedMultiplier Whether to use the duration as a speed multiplier.  Eg If our duration was 2 and this was\n   *                          set then since the speed is doubled - then the actual duration is halved.\n   * @returns This Group instance for method chaining\n   */\n  setDurationAsMultiplier(asSpeedMultiplier = true): this {\n    this.durationIsSpeedMultiplier = asSpeedMultiplier;\n    return this;\n  }\n\n  /**\n   * Sets the duration of this group.\n   * @param d The new duration\n   * @param asSpeedMultiplier Whether to use the duration as a speed multiplier.  Eg If our duration was 2 and this was\n   *                          set then since the speed is doubled - then the actual duration is halved.\n   * @returns This Group instance for method chaining\n   */\n  setDuration(d: Fraction, asSpeedMultiplier = false): this {\n    this._duration = d;\n    this.durationIsSpeedMultiplier = asSpeedMultiplier;\n    return this;\n  }\n\n  /**\n   * Returns a debug-friendly representation of this Group.\n   * @returns An object containing debug information\n   */\n  debugValue(): any {\n    const out = { ...super.debugValue(), atoms: Array.from(this.atoms.values(), (a) => a.debugValue()) };\n    if (this.durationIsSpeedMultiplier) out.durationIsSpeedMultiplier = true;\n    return out;\n  }\n\n  /**\n   * Splits this group into two parts.\n   * The first part (this group) fits within the given duration and everything else\n   * longer than the given duration is returned as a new Group.\n   *\n   * @param requiredDuration The duration at which to split the group\n   * @returns A new Group containing the atoms beyond the split point, or null if no split is needed\n   */\n  splitAt(requiredDuration: Fraction): TSU.Nullable<Group> {\n    if (this.duration.isLTE(requiredDuration) || requiredDuration.isLTE(ZERO)) {\n      return null;\n    }\n    const targetGroup = new Group();\n    if (this.durationIsSpeedMultiplier) {\n      targetGroup.durationIsSpeedMultiplier = true;\n      targetGroup._duration = this._duration;\n    }\n\n    let remainingDur = this.duration;\n    const totalChildDuration = this.totalChildDuration;\n    const durationFactor = this.durationIsSpeedMultiplier\n      ? ONE.divby(this._duration)\n      : this._duration.divby(totalChildDuration, true);\n    while (remainingDur.isGT(requiredDuration) && this.atoms.last) {\n      const lastChild = this.atoms.last;\n      // Child's duration is absolute in its own \"system\"\n      // Its duration within the parent (this) group's frame of reference depends\n      // on whether the parent's duration is absolute or as a multiplier\n      //\n      // realChildDuration = case (group.durationIsMultiper) {\n      //  | true  => child.duration / this._duration\n      //  | false => child.duration * this._duration / total child duration\n      //  }\n      const childDuration = lastChild.duration.times(durationFactor);\n      const newDuration = remainingDur.minus(childDuration);\n      if (newDuration.isGTE(requiredDuration)) {\n        // remove ourselves and add to target\n        // in both cases duration will be adjusted if need be\n        this.removeAtoms(true, lastChild);\n        targetGroup.insertAtomsAt(targetGroup.atoms.first, true, lastChild);\n        if (newDuration.equals(requiredDuration)) {\n          // we have reached the end so return\n          return targetGroup;\n        }\n      } else {\n        // our scenario is now this:\n        //\n        // totalParentDuration = 10\n        // required = 8\n        // lastChildDuration (relative to parent) is 5\n        //\n        // durWithoutLast = 10 - 5\n        // newRequired = requiredDur - durWithoutLast = 3\n        //\n        // However 3 is a duration in the parent's frame of reference\n        // this has to be converted back to the child's FoR\n        const newRequiredDur = requiredDuration.minus(newDuration, true).divby(durationFactor, true);\n        // console.log( \"newRequiredDur: \", newRequiredDur, \"requiedDur: \", requiredDuration, \"remainingDur: \", remainingDur,);\n        // then the last item needs to be split, and by how much?\n        const spillOver = lastChild.splitAt(newRequiredDur);\n        if (spillOver == null) {\n          throw new Error(\"Spill over cannot be null here\");\n        }\n        if (!this.durationIsSpeedMultiplier) {\n          // Our own duration has also now changed\n          this._duration = requiredDuration;\n        } else {\n          if (this._duration.isZero) throw new Error(\"How can this be?\");\n        }\n        spillOver.isContinuation = true;\n        // Add spill over to the target\n        targetGroup.insertAtomsAt(targetGroup.atoms.first, true, spillOver);\n        return targetGroup;\n      }\n      remainingDur = newDuration;\n    }\n    return targetGroup;\n  }\n\n  /**\n   * Gets the total duration of all child atoms.\n   * @returns The sum of durations of all atoms in this group\n   */\n  get totalChildDuration(): Fraction {\n    let out = ZERO;\n    for (const atom of this.atoms.values()) {\n      out = out.plus(atom.duration);\n    }\n    return out;\n  }\n\n  /**\n   * Inserts atoms before a given cursor atom.\n   * If the cursor atom is null, the atoms are appended at the end.\n   *\n   * @param beforeAtom The atom before which to insert the new atoms, or null to append\n   * @param adjustDuration Whether to adjust this group's duration based on the new atoms\n   * @param atoms The atoms to insert\n   * @returns This Group instance for method chaining\n   */\n  insertAtomsAt(beforeAtom: TSU.Nullable<Atom>, adjustDuration = false, ...atoms: Atom[]): this {\n    adjustDuration = adjustDuration && !this.durationIsSpeedMultiplier;\n    const oldChildDuration = adjustDuration ? this.totalChildDuration : ONE;\n\n    // Calculate insertion index for event notification\n    let insertIndex: number;\n    if (beforeAtom) {\n      // Find index of beforeAtom using for loop\n      insertIndex = 0;\n      for (const a of this.atoms.values()) {\n        if (a === beforeAtom) break;\n        insertIndex++;\n      }\n    } else {\n      // Appending to end - use size property\n      insertIndex = this.atoms.size;\n    }\n\n    // Track which atoms were actually added (excluding REST atoms)\n    const addedAtoms: Atom[] = [];\n\n    // First form a chain of the given atoms\n    for (const atom of atoms) {\n      if (atom.parentGroup != null) {\n        if (atom.parentGroup != this) {\n          throw new Error(\"Atom belongs to another parent. Remove it first\");\n        }\n        atom.parentGroup.removeAtoms(false, atom);\n      }\n      if (atom.TYPE == AtomType.REST) {\n        const last = this.atoms.last;\n        if (last && last.TYPE != AtomType.GROUP && last.TYPE != AtomType.LABEL) {\n          (last as LeafAtom).beforeRest = true;\n        }\n      } else {\n        atom.parentGroup = this;\n        this.atoms.add(atom, beforeAtom);\n        addedAtoms.push(atom);\n      }\n    }\n    if (adjustDuration) {\n      if (this._duration.isZero) {\n        if (this.durationIsSpeedMultiplier) throw new Error(\"How can this be?\");\n        this._duration = this.totalChildDuration;\n      } else {\n        const scaleFactor = this.totalChildDuration.divby(oldChildDuration);\n        this._duration = this._duration.times(scaleFactor, true);\n      }\n    }\n\n    // Notify observers if atoms were added\n    if (addedAtoms.length > 0) {\n      const type = beforeAtom ? AtomChangeType.INSERT : AtomChangeType.ADD;\n      this.notifyObservers(type, addedAtoms, insertIndex);\n    }\n\n    return this;\n  }\n\n  /**\n   * Adds atoms to the end of this group's atom list.\n   *\n   * @param adjustDuration Whether to adjust this group's duration based on the new atoms\n   * @param atoms The atoms to add\n   * @returns This Group instance for method chaining\n   */\n  addAtoms(adjustDuration = false, ...atoms: Atom[]): this {\n    return this.insertAtomsAt(null, adjustDuration, ...atoms);\n  }\n\n  /**\n   * Removes atoms from this group's child list.\n   *\n   * @param adjustDuration Whether to adjust this group's duration after removing atoms\n   * @param atoms The atoms to remove\n   * @returns This Group instance for method chaining\n   */\n  removeAtoms(adjustDuration = false, ...atoms: Atom[]): this {\n    adjustDuration = adjustDuration && !this.durationIsSpeedMultiplier;\n    const oldChildDuration = adjustDuration ? this.totalChildDuration : ONE;\n\n    // Track which atoms were actually removed\n    const removedAtoms: Atom[] = [];\n\n    for (const atom of atoms) {\n      if (atom.parentGroup == this) {\n        this.atoms.remove(atom);\n        atom.parentGroup = null;\n        removedAtoms.push(atom);\n      } else if (atom.parentGroup != null) {\n        throw new Error(\"Atom cannot be removed as it does not belong to this group\");\n      }\n    }\n    if (adjustDuration) {\n      if (this._duration.isZero) {\n        if (this.durationIsSpeedMultiplier) throw new Error(\"How can this be?\");\n        this._duration = this.totalChildDuration;\n      } else {\n        const scaleFactor = this.totalChildDuration.divby(oldChildDuration);\n        this._duration = this._duration.times(scaleFactor, true);\n      }\n    }\n\n    // Notify observers if atoms were removed\n    if (removedAtoms.length > 0) {\n      this.notifyObservers(AtomChangeType.REMOVE, removedAtoms, -1);\n    }\n\n    return this;\n  }\n}\n\n/**\n * Represents a line of notation containing multiple roles.\n * A line can have atoms starting before or after the cycle.\n */\nexport class Line extends Entity {\n  readonly TYPE: string = \"Line\";\n\n  /**\n   * Offset tells how many notes before or after the cycle this line's atoms start at.\n   */\n  offset: Fraction = ZERO;\n\n  /**\n   * The roles contained in this line.\n   */\n  roles: Role[] = [];\n\n  /**\n   * Text to be displayed in the margin of the line.\n   * This is a hacky solution to doing left side pre-margin text typically\n   * found in notations - e.g., line X of a pallavi has this. This makes vertical\n   * space less wasteful.\n   *\n   * A better solution is inter-beat annotation but it is very complex for now.\n   */\n  marginText = \"\";\n\n  /**\n   * The LayoutParams associated with this line.\n   */\n  layoutParams: LayoutParams;\n\n  /**\n   * Observers that receive notifications when roles change.\n   */\n  private _observers: LineObserver<Role, Line>[] = [];\n\n  /**\n   * Adds an observer to receive role change notifications.\n   * @param observer The observer to add\n   * @returns A function to remove the observer\n   */\n  addObserver(observer: LineObserver<Role, Line>): () => void {\n    this._observers.push(observer);\n    return () => this.removeObserver(observer);\n  }\n\n  /**\n   * Removes an observer.\n   * @param observer The observer to remove\n   */\n  removeObserver(observer: LineObserver<Role, Line>): void {\n    const index = this._observers.indexOf(observer);\n    if (index >= 0) {\n      this._observers.splice(index, 1);\n    }\n  }\n\n  /**\n   * Finds the index of a role with the given name.\n   * @param name The name of the role to find\n   * @returns The index of the role, or -1 if not found\n   */\n  indexOfRole(name: string): number {\n    for (let i = 0; i < this.roles.length; i++) {\n      if (this.roles[i].name == name) return i;\n    }\n    return -1;\n  }\n\n  /**\n   * Checks if this line is empty (has no content in any role).\n   */\n  get isEmpty(): boolean {\n    for (const r of this.roles) if (!r.isEmpty) return false;\n    return true;\n  }\n\n  /**\n   * Returns a debug-friendly representation of this Line.\n   * @returns An object containing debug information\n   */\n  debugValue(): any {\n    const out = {\n      ...super.debugValue(),\n      roles: this.roles.map((r) => r.debugValue()),\n    };\n    if (!this.offset.isZero) {\n      out.offset = this.offset.toString();\n    }\n    return out;\n  }\n\n  /**\n   * Copies the properties of this Line to another Line.\n   * @param another The target Line to copy properties to\n   */\n  copyTo(another: this): void {\n    super.copyTo(another);\n    another.roles = this.roles.map((r) => r.clone());\n  }\n\n  /**\n   * Adds atoms to a role in this line.\n   * @param roleName The name of the role to add atoms to\n   * @param defaultToNotes Whether to default to notes for this role\n   * @param atoms The atoms to add\n   * @returns This Line instance for method chaining\n   */\n  addAtoms(roleName: string, defaultToNotes: boolean, ...atoms: Atom[]): this {\n    const role = this.ensureRole(roleName, defaultToNotes);\n    role.addAtoms(...atoms);\n    return this;\n  }\n\n  /**\n   * Ensures a role with the given name exists in this line, creating it if needed.\n   * @param roleName The name of the role to ensure\n   * @param defaultToNotes Whether to default to notes for this role\n   * @returns The role with the specified name\n   */\n  ensureRole(roleName: string, defaultToNotes: boolean): Role {\n    // Ensure we have this many roles\n    let ri = this.roles.findIndex((r) => r.name == roleName);\n    if (ri < 0) {\n      ri = this.roles.length;\n      const role = new Role(this, roleName);\n      role.defaultToNotes = defaultToNotes;\n      this.roles.push(role);\n\n      // Notify observers of new role\n      if (this._eventsEnabled) {\n        for (const observer of this._observers) {\n          observer.onRoleAdded?.(this, roleName, role);\n        }\n      }\n    }\n    return this.roles[ri];\n  }\n\n  /**\n   * Removes a role from this line.\n   * @param roleName The name of the role to remove\n   * @returns True if the role was removed, false if not found\n   */\n  removeRole(roleName: string): boolean {\n    const ri = this.roles.findIndex((r) => r.name == roleName);\n    if (ri >= 0) {\n      this.roles.splice(ri, 1);\n\n      // Notify observers of removed role\n      if (this._eventsEnabled) {\n        for (const observer of this._observers) {\n          observer.onRoleRemoved?.(this, roleName);\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Gets the maximum duration across all roles in this line.\n   */\n  get duration(): Fraction {\n    let max = ZERO;\n    for (const role of this.roles) {\n      max = TSU.Num.Fraction.max(role.duration, max);\n    }\n    return max;\n  }\n}\n\n/**\n * Represents a specific role or voice in a line of notation.\n * Each role contains a sequence of atoms.\n */\nexport class Role extends Entity {\n  readonly TYPE = \"Role\";\n\n  /**\n   * Whether this role represents notes by default.\n   */\n  defaultToNotes = true;\n\n  /**\n   * The atoms in this role.\n   */\n  atoms: Atom[] = [];\n\n  /**\n   * Observers that receive notifications when atoms change.\n   */\n  private _observers: RoleObserver<Atom, Role>[] = [];\n\n  /**\n   * Creates a new Role with the specified line and name.\n   * @param line The line this role belongs to\n   * @param name The name of the role\n   */\n  constructor(\n    public readonly line: Line,\n    public readonly name: string,\n  ) {\n    super();\n  }\n\n  /**\n   * Adds an observer to receive atom change notifications.\n   * @param observer The observer to add\n   * @returns A function to remove the observer\n   */\n  addObserver(observer: RoleObserver<Atom, Role>): () => void {\n    this._observers.push(observer);\n    return () => this.removeObserver(observer);\n  }\n\n  /**\n   * Removes an observer.\n   * @param observer The observer to remove\n   */\n  removeObserver(observer: RoleObserver<Atom, Role>): void {\n    const index = this._observers.indexOf(observer);\n    if (index >= 0) {\n      this._observers.splice(index, 1);\n    }\n  }\n\n  /**\n   * Notifies observers of atom changes.\n   */\n  private notifyObservers(type: AtomChangeType, atoms: Atom[], index: number): void {\n    if (!this._eventsEnabled) return;\n    for (const observer of this._observers) {\n      switch (type) {\n        case AtomChangeType.ADD:\n          observer.onAtomsAdded?.(this, atoms, index);\n          break;\n        case AtomChangeType.INSERT:\n          observer.onAtomsInserted?.(this, atoms, index);\n          break;\n        case AtomChangeType.REMOVE:\n          observer.onAtomsRemoved?.(this, atoms);\n          break;\n      }\n    }\n  }\n\n  /**\n   * Checks if this role is empty (has no atoms).\n   */\n  get isEmpty(): boolean {\n    return this.atoms.length == 0;\n  }\n\n  /**\n   * Returns a debug-friendly representation of this Role.\n   * @returns An object containing debug information\n   */\n  debugValue(): any {\n    return { name: this.name, atoms: this.atoms.map((a) => a.debugValue()) };\n  }\n\n  /**\n   * Adds atoms to the end of this role.\n   * @param atoms The atoms to add\n   */\n  addAtoms(...atoms: Atom[]): void {\n    this.insertAtomsAt(this.atoms.length, ...atoms);\n  }\n\n  /**\n   * Inserts atoms at a specific index in this role.\n   * @param index The index at which to insert\n   * @param atoms The atoms to insert\n   */\n  insertAtomsAt(index: number, ...atoms: Atom[]): void {\n    // Track which atoms were actually added (excluding REST atoms)\n    const addedAtoms: Atom[] = [];\n    let last: null | Atom = index > 0 ? this.atoms[index - 1] : null;\n\n    for (const atom of atoms) {\n      if (atom.TYPE == AtomType.REST) {\n        if (last && last.TYPE != AtomType.GROUP && last.TYPE != AtomType.LABEL) {\n          (last as LeafAtom).beforeRest = true;\n        }\n      } else {\n        this.atoms.splice(index + addedAtoms.length, 0, atom);\n        addedAtoms.push(atom);\n      }\n      last = atom;\n    }\n\n    // Notify observers if atoms were added\n    if (addedAtoms.length > 0) {\n      const isAppend = index >= this.atoms.length - addedAtoms.length;\n      const type = isAppend ? AtomChangeType.ADD : AtomChangeType.INSERT;\n      this.notifyObservers(type, addedAtoms, index);\n    }\n  }\n\n  /**\n   * Removes atoms from this role.\n   * @param atoms The atoms to remove\n   */\n  removeAtoms(...atoms: Atom[]): void {\n    const removedAtoms: Atom[] = [];\n\n    for (const atom of atoms) {\n      const idx = this.atoms.indexOf(atom);\n      if (idx >= 0) {\n        this.atoms.splice(idx, 1);\n        removedAtoms.push(atom);\n      }\n    }\n\n    // Notify observers if atoms were removed\n    if (removedAtoms.length > 0) {\n      this.notifyObservers(AtomChangeType.REMOVE, removedAtoms, -1);\n    }\n  }\n\n  /**\n   * Copies the properties of this Role to another Role.\n   * @param another The target Role to copy properties to\n   */\n  copyTo(another: Role): void {\n    another.addAtoms(...this.atoms);\n  }\n\n  /**\n   * Gets the total duration of all atoms in this role.\n   */\n  get duration(): Fraction {\n    return this.atoms.reduce((a, b) => a.plus(b.duration), ZERO);\n  }\n}\n","import * as TSU from \"@panyam/tsutils\";\nimport { Atom, Space, Group, Syllable } from \"./core\";\nimport { Cycle, Bar } from \"./cycle\";\nconst ONE = TSU.Num.Fraction.ONE;\n\n/**\n * Converts a cycle string into an array of bar strings.\n *\n * A cycle is specified by a \"|\" delimited string in the format:\n * <bar1>|<bar2>|<bar3>....|<barN>\n *\n * Empty bars are ignored.\n *\n * @param cycleStr The cycle string to convert\n * @returns An array of bar strings\n */\nexport function cycleStrToBarsStrs(cycleStr: string): string[] {\n  return cycleStr\n    .replace(/\\|+/g, \"|\")\n    .split(\"|\")\n    .map((x) => x.trim())\n    .filter((x) => x.length > 0);\n}\n\n/**\n * Parses a tala pattern string into a Cycle object.\n *\n * @param cycleStr The cycle string to parse\n * @returns A new Cycle object\n */\nexport function parseCycle(cycleStr: string): Cycle {\n  return new Cycle({\n    bars: cycleStrToBarsStrs(cycleStr).map(parseBar),\n  });\n}\n\n/**\n * Parses a bar string into a Bar object.\n *\n * A bar string is a space delimited string in the following format:\n * \"<beat1> <spaces> <beat2> .... <beatN>\"\n *\n * beatX substring cannot contain \"|\" or spaces.\n *\n * Each Beat string is in the following format:\n * \"<length>(:<count>)?\"  or \"<length>?:<count>\"\n *\n * Both length and count are optional but at least one of them must be specified.\n * When not specified the other defaults to 1.\n * Length can also be a fraction of the form <num>\"/\"<den> (without spaces).\n *\n * @param barStr The bar string to parse\n * @returns A new Bar object\n */\nexport function parseBar(barStr: string): Bar {\n  const bars = barStr.replace(/\\s+/g, \" \").split(\" \");\n  const cp = new Bar();\n  if (bars.length == 1) {\n    for (let i = 0; i < barStr.length; i++) {\n      let count = 0;\n      const ch = barStr[i];\n      if (ch == \",\") {\n        count = 1;\n      } else {\n        const num = parseInt(ch);\n        if (num) {\n          count = num;\n        }\n      }\n      while (count > 0) {\n        cp.beatLengths.push(ONE);\n        count--;\n      }\n    }\n  } else {\n    for (let i = 0; i < bars.length; i++) {\n      const comps = bars[i].split(\":\");\n      const length = comps[0];\n      const count = comps[1] || \"\";\n      if (length.length == 0) {\n        cp.beatLengths.push(TSU.Num.Frac(1));\n      } else if (/^,+$/.test(length)) {\n        cp.beatLengths.push(TSU.Num.Frac(length.length));\n      } else {\n        // parse length as a number or as a fraction\n        cp.beatLengths.push(TSU.Num.Fraction.parse(length));\n      }\n\n      // Now the count\n      const beatCount = parseInt(count);\n      if (isNaN(beatCount)) {\n        cp.beatCounts.push(1);\n      } else {\n        cp.beatCounts.push(beatCount);\n      }\n    }\n  }\n  return cp;\n}\n\n/**\n * Parses a string into a syllable atom structure.\n *\n * @param value The string to parse\n * @returns An atom representing the syllable structure\n */\nexport function parseSyllable(value: string): Atom {\n  const notes = [] as Atom[];\n  // Only \"_\" make a difference here\n  for (let i = 0; i < value.length; ) {\n    let ch = value[i];\n    if (ch == \"_\") {\n      notes.push(new Space(ONE, true));\n      i++;\n    } else if (ch == \",\") {\n      notes.push(new Space(ONE, false));\n      i++;\n    } else {\n      let syll = \"\";\n      while (i < value.length && ch != \",\" && ch != \"_\") {\n        syll += ch;\n        i++;\n        ch = value[i];\n      }\n      notes.push(new Syllable(syll));\n    }\n  }\n  if (notes.length == 1) return notes[0];\n  return new Group(...notes);\n}\n\n/**\n * Parses a property string in the format \"key = value\".\n *\n * @param line The property string to parse\n * @returns A tuple containing the key and value\n * @throws Error if the property string is invalid\n */\nexport function parseProperty(line: string): [string, string] {\n  const bars = line.split(\"=\").map((x) => x.trim());\n  if (bars.length < 2) {\n    throw new Error(\"Properties must be of type <key> = <value>\");\n  }\n  const key = bars[0];\n  const value = bars[1];\n  return [key, value];\n}\n\n/**\n * NOT YET IMPLEMENTED\n * A sparse array type which is optimized for \"holes\" while not penalizing\n * runs of values.\n */\nexport class SparseArray<T> {\n  runs: [number, T[]][] = [];\n\n  /**\n   * Gets the total length of this sparse array.\n   */\n  get length(): number {\n    let out = 0;\n    for (const [, vals] of this.runs) {\n      out += vals.length;\n    }\n    return out;\n  }\n\n  /**\n   * Returns the value at a given index.\n   * If the value does not exist an optional creator method can be passed\n   * to ensure that this value is also created and set at the given index.\n   *\n   * @param index The index to get the value at\n   * @param creator Optional function to create a value if none exists\n   * @returns The value at the index\n   */\n  valueAt(index: number, creator?: () => any): any {\n    let out = null;\n    if (out == null && creator) {\n      // wasnt found\n      out = creator();\n      this.setAt(index, out);\n    }\n    return out;\n  }\n\n  /**\n   * Sets values at a specific index.\n   *\n   * @param index The index to set values at\n   * @param values The values to set\n   * @returns This array instance for method chaining\n   */\n  setAt(index: number, ...values: (T | null)[]): this {\n    return this.splice(index, values.length, ...values);\n  }\n\n  /**\n   * Removes values at a specific index.\n   *\n   * @param index The index to remove values at\n   * @param count The number of values to remove, defaults to 1\n   * @returns This array instance for method chaining\n   */\n  removeAt(index: number, count = 1): this {\n    return this.splice(index, count);\n  }\n\n  /**\n   * Splices values at a specific index.\n   *\n   * @param index The index to splice at\n   * @param numToDelete The number of values to delete\n   * @param valuesToInsert The values to insert\n   * @returns This array instance for method chaining\n   */\n  splice(index: number, numToDelete: number, ...valuesToInsert: (T | null)[]) {\n    //\n    return this;\n  }\n}\n","import * as TSU from \"@panyam/tsutils\";\nimport { Atom } from \"./core\";\nimport { parseCycle } from \"./utils\";\nimport { Command, RawBlock, Notation, MetaData as Meta, BlockItem, Block } from \"./notation\";\n\n/**\n * Command for embedding raw content in the notation.\n * This allows including arbitrary raw text blocks (like markdown or HTML) within the notation.\n */\nexport class RawEmbedding extends Command {\n  /**\n   * Gets the raw content of this embedding.\n   */\n  get rawContents(): string {\n    return this.getParamAt(0);\n  }\n\n  /**\n   * Applies this command to a block.\n   * Adds a raw block to the container and resets the current line\n   * so subsequent notation starts a new line.\n   */\n  applyToBlock(container: Block): void {\n    const raw = new RawBlock(this.rawContents);\n    container.addBlockItem(raw);\n    // Reset the current line so subsequent notation starts fresh\n    container.resetLine();\n  }\n}\n\n/**\n * Command for adding metadata to the notation.\n */\nexport class MetaData extends Command {\n  /**\n   * Applies this command to a block.\n   * Only works on Notation (metadata is a Notation-specific feature).\n   */\n  applyToBlock(container: Block): void {\n    if (container instanceof Notation) {\n      container.addMetaData(this.meta);\n    }\n    // No-op for non-Notation blocks\n  }\n\n  /**\n   * Gets the metadata object for this command.\n   */\n  get meta(): Meta {\n    const out = new Meta(this.key, this.value);\n    return out;\n  }\n\n  /**\n   * Gets the key for this metadata.\n   */\n  get key(): string {\n    return this.getParamAt(0);\n  }\n\n  /**\n   * Gets the value for this metadata.\n   */\n  get value(): string {\n    return this.getParamAt(1);\n  }\n}\n\n/**\n * Command for activating (selecting) a specific role.\n */\nexport class ActivateRole extends Command {\n  /**\n   * Applies this command to a block.\n   * Sets the current role in the container.\n   */\n  applyToBlock(container: Block): void {\n    container.setCurrRole(this.roleName);\n  }\n\n  /**\n   * Gets the name of the role to activate.\n   */\n  get roleName(): string {\n    return this.getParamAt(0);\n  }\n}\n\n/**\n * Command for adding atoms to the current role.\n */\nexport class AddAtoms extends Command {\n  /** Index of this command in the sequence */\n  index: number;\n  /** Atoms to add */\n  atoms: Atom[];\n\n  /**\n   * Creates a new AddAtoms command.\n   * @param atoms Atoms to add\n   */\n  constructor(...atoms: Atom[]) {\n    super();\n    this.atoms = atoms;\n    this.index = 0;\n  }\n\n  /**\n   * Returns a debug-friendly representation of this command.\n   * @returns An object containing debug information\n   */\n  debugValue(): any {\n    return {\n      name: this.name,\n      index: this.index,\n      atoms: this.atoms.map((a) => a.debugValue()),\n    };\n  }\n\n  /**\n   * Applies this command to a block.\n   * Adds atoms to the current line in the container.\n   */\n  applyToBlock(container: Block): void {\n    let roleDef = container.currRoleDef;\n    if (roleDef == null) {\n      // By default create a role for swaras\n      roleDef = container.newRoleDef(\"Sw\", true);\n    }\n    // Get or create the current line\n    const line = container.currentLine;\n    // Set layoutParams from the container's scope (Block or Notation)\n    const lpForLine = line.layoutParams;\n    if (lpForLine == null) {\n      line.layoutParams = container.layoutParams;\n    } else {\n      TSU.assert(\n        lpForLine == container.layoutParams,\n        \"Layout parameters have changed so a new line should have been started\",\n      );\n    }\n    // Add atoms to the line\n    line.addAtoms(roleDef.name, roleDef.notesOnly, ...this.atoms);\n  }\n}\n\n/**\n * Command for creating a new line in the notation.\n */\nexport class CreateLine extends Command {\n  /**\n   * Applies this command to a block.\n   * Creates a new line in the container.\n   */\n  applyToBlock(container: Block): void {\n    const line = container.newLine();\n    line.offset = this.offset;\n    line.marginText = this.marginText;\n  }\n\n  /**\n   * Gets the offset for the new line.\n   */\n  get offset(): TSU.Num.Fraction {\n    let offset = this.getParam(\"offset\") || TSU.Num.Fraction.ZERO;\n    if (typeof offset === \"number\") offset = new TSU.Num.Fraction(offset);\n    return offset;\n  }\n\n  /**\n   * Gets the margin text for the new line.\n   */\n  get marginText(): string {\n    if (this.params.length > 0) {\n      if (this.params[0].key == null && typeof this.params[0].value === \"string\") {\n        return this.params[0].value.trim();\n      }\n    }\n    return this.getParam(\"marginText\") || \"\";\n  }\n}\n\n/**\n * Command for creating a new role in the notation.\n */\nexport class CreateRole extends Command {\n  /**\n   * Applies this command to a block.\n   * Creates a role definition local to the container.\n   */\n  applyToBlock(container: Block): void {\n    const name = this.getParamAt(0);\n    container.newRoleDef(name, this.notesOnly);\n  }\n\n  /**\n   * Gets whether this role should contain only notes (true) or also syllables/text (false).\n   */\n  get notesOnly(): boolean {\n    const notesOnly = this.getParam(\"notes\");\n    return notesOnly == \"true\" || notesOnly == \"yes\" || notesOnly == true;\n  }\n}\n\n/**\n * Base class for commands that modify layout parameters.\n */\nexport abstract class LayoutParamCommand extends Command {}\n\n/**\n * Command for applying a named layout to the notation.\n *\n * Saves the current layout with the given name.\n * Typically users can change layout params (currently cycle, APB and line layout)\n * with the \\cycle, \\layout and \\beatDuration commands. Each time these are\n * changed, the current layout params is set to null. So the next time layout\n * params are needed we look at saved layout params and search by the unique\n * combination of cycle, apb and line layout. This prevents users from creating\n * too many layouts with the same config. Each layout is associated with an\n * AtomLayout instance.\n *\n * For example consider this:\n *\n * \\apb(4)\n * \\breaks(4)\n * \\cycle(\"|4|2|2|\")\n * \\apb(5)\n * \\breaks(3)\n *\n * In all these cases LayoutParams are *not* created.  Instead they are reset to null.\n *\n *\n * When we do an AddAtoms command, this is where a LineView is created and along with this\n * a layoutParams is created taking the latest state of the layout params resulting an\n * LP (instance id = 1) of (layout = 3, cycle = \"4|2|2\", apb = 5)\n *\n * Now after this say we had the following commands:\n *\n * \\cycle(x)\n * \\cycle(|4|2|2)\n * \\apb(10)\n * \\apb(5)\n *\n * Sw: a b c\n *\n * Here again since the LP was set to null, \"creating\" layout params results in returning\n * the LP created previously (at the end of these commands the cycle, apb and layout params\n * are the same).\n *\n * eg doing\n *\n * \\layout(\"layout1\")\n *\n * This ensures that a *new* LP instance is created (even if another one exists with the same\n * apb, cycle, layout combo).  This allows us to group different sectiosn that are identical\n * in layout but to be processed by different atom layouts.\n *\n * To use a saved layout simply do:\n *\n * \\layout(\"layout\")\n *\n * Note the use and saving commands are same - as we cannot override existing\n * layouts so referring to it the first time creates and saves it too\n */\nexport class ApplyLayout extends Command {\n  /**\n   * Validates the parameters for this command.\n   * @throws Error if parameters are invalid\n   */\n  validateParams(): void {\n    if (this.params.length != 1 || typeof this.params[0].value !== \"string\") {\n      throw new Error(\"layout command must contain one string argument\");\n    }\n  }\n\n  /**\n   * Applies this command to a block.\n   * Named layouts are Notation-specific; no-op for other blocks.\n   */\n  applyToBlock(container: Block): void {\n    if (container instanceof Notation) {\n      const value = this.params[0].value;\n      container.ensureNamedLayoutParams(value);\n    }\n    // No-op for non-Notation blocks (named layouts are Notation-specific)\n  }\n}\n\n/**\n * Command for setting line breaks in the layout.\n */\nexport class SetBreaks extends LayoutParamCommand {\n  /**\n   * Gets the line breaks pattern.\n   */\n  get pattern(): number[] {\n    return this.params.map((cmd) => cmd.value as number);\n  }\n\n  /**\n   * Validates the parameters for this command.\n   * @throws Error if parameters are invalid\n   */\n  validateParams(): void {\n    for (const param of this.params) {\n      if (param.key != null) {\n        throw new Error(\"Breaks command cannot have keyword params\");\n      }\n      if (typeof param.value !== \"number\") {\n        throw new Error(\"Breaks command must be a list of integers\");\n      }\n    }\n  }\n\n  /**\n   * Applies this command to a block.\n   * Sets the local breaks on the container.\n   */\n  applyToBlock(container: Block): void {\n    container.localBreaks = this.pattern;\n    if (container instanceof Notation) {\n      container.resetLayoutParams();\n    }\n  }\n}\n\n/**\n * Command for setting the cycle pattern in the layout.\n */\nexport class SetCycle extends LayoutParamCommand {\n  /**\n   * Applies this command to a block.\n   * Sets the local cycle on the container.\n   */\n  applyToBlock(container: Block): void {\n    const value = this.params[0].value;\n    // TODO - move the parsing to validation\n    const cycle = parseCycle(value);\n    container.localCycle = cycle;\n    if (container instanceof Notation) {\n      container.resetLayoutParams();\n    }\n  }\n}\n\n/**\n * Command for setting the beat duration in the layout.\n */\nexport class SetBeatDuration extends LayoutParamCommand {\n  /**\n   * Validates the parameters for this command.\n   * @throws Error if parameters are invalid\n   */\n  validateParams(): void {\n    if (this.params.length != 1 || typeof this.params[0].value !== \"number\") {\n      throw new Error(\"beatDuration command must contain one number\");\n    }\n  }\n\n  /**\n   * Gets the beat duration value.\n   */\n  get beatDuration(): number {\n    return this.params[0].value;\n  }\n\n  /**\n   * Applies this command to a block.\n   * Sets the local atoms per beat on the container.\n   */\n  applyToBlock(container: Block): void {\n    container.localAtomsPerBeat = this.beatDuration;\n    if (container instanceof Notation) {\n      container.resetLayoutParams();\n    }\n  }\n}\n\n/**\n * Command for creating a named section in the notation.\n * Sections are organizational blocks with a name that can be displayed as headers.\n *\n * Usage: \\section(\"Pallavi\") { ... }\n */\nexport class Section extends Command {\n  /**\n   * Gets the name of the section.\n   */\n  get sectionName(): string {\n    return this.getParamAt(0) || \"\";\n  }\n\n  /**\n   * Validates the parameters for this command.\n   * @throws Error if parameters are invalid\n   */\n  validateParams(): void {\n    if (this.params.length < 1 || typeof this.params[0].value !== \"string\") {\n      throw new Error(\"section command must contain a string name\");\n    }\n  }\n\n  /**\n   * Applies this command to a block.\n   * No-op: SectionBlock handles the section behavior.\n   */\n  applyToBlock(_container: Block): void {\n    // SectionBlock handles section semantics\n  }\n}\n\n/**\n * Command for creating a grouping/scope block without specific semantics.\n * Groups are useful for visually organizing notation or applying shared properties.\n *\n * Usage: \\group(\"optional-name\") { ... }\n */\nexport class ScopedGroup extends Command {\n  /**\n   * Gets the optional name of the group.\n   */\n  get groupName(): string {\n    return this.getParamAt(0) || \"\";\n  }\n\n  /**\n   * Applies this command to a block.\n   * No additional properties to set for basic groups.\n   */\n  applyToBlock(_container: Block): void {\n    // No additional properties\n  }\n}\n\n/**\n * Command for creating a repeated section in the notation.\n * Repeats can specify a count for how many times the content should repeat.\n *\n * Usage: \\repeat(2) { ... } or \\repeat() { ... } for visual repeat markers\n */\nexport class Repeat extends Command {\n  /**\n   * Gets the number of times to repeat.\n   * Returns 0 if not specified (meaning visual repeat markers only).\n   */\n  get count(): number {\n    const count = this.getParamAt(0);\n    if (typeof count === \"number\") {\n      return count;\n    }\n    return 0;\n  }\n\n  /**\n   * Validates the parameters for this command.\n   * @throws Error if parameters are invalid\n   */\n  validateParams(): void {\n    if (this.params.length > 0) {\n      const count = this.params[0].value;\n      if (typeof count !== \"number\" || count < 0) {\n        throw new Error(\"repeat command count must be a non-negative number\");\n      }\n    }\n  }\n\n  /**\n   * Applies this command to a block.\n   * No-op: RepeatBlock handles the repeat behavior.\n   */\n  applyToBlock(_container: Block): void {\n    // RepeatBlock handles repeat semantics\n  }\n}\n","import * as TSU from \"@panyam/tsutils\";\nimport * as G from \"galore\";\nimport * as TLEX from \"tlex\";\nimport YAML from \"yaml\";\nimport { Literal, AtomType, Note, Atom, Rest, Space, Syllable, Group, Marker } from \"./core\";\nimport { Notation, MetaData as Meta, Command, CmdParam } from \"./notation\";\nimport {\n  RawEmbedding,\n  ApplyLayout,\n  AddAtoms,\n  SetCycle,\n  SetBeatDuration,\n  SetBreaks,\n  ActivateRole,\n  CreateRole,\n  CreateLine,\n  Section,\n  ScopedGroup,\n  Repeat,\n} from \"./commands\";\n\n// TODO - Make this plugable from the client instead of hard coded\nimport * as carnatic from \"./carnatic\";\n\nconst ONE = TSU.Num.Fraction.ONE;\nconst TWO = ONE.timesNum(2);\n\n/**\n * V4 of our parser builds on V3 and has the following improvements:\n *\n * 1. Embedding Headings to demarcate sections so users dont have to use\n *    explicit MD for headings.\n * 2. Unlike V3 here users break out *of* song instead instead break out \"into\"\n * song.  So users spend more time writing notation and less worrying about\n * other things like headings etc.\n */\nconst [parser /*itemGraph*/] = G.newParser(\n  String.raw`\n    %define IdentChar     /[^%!@$#&\\^|\\[\\]={}()<>+\\-,;~: \\t\\f\\r\\n\\v\\\\\\.\\'\\\"]/\n\n    %token  BSLASH        \"\\\\\"\n    %token  OPEN_SQ       \"[\"\n    %token  CLOSE_SQ      \"]\"\n    %token  EQUALS        \"=\"\n    %token  OPEN_PAREN    \"(\"\n    %token  CLOSE_PAREN   \")\"\n    %token  OPEN_BRACE    \"{\"\n    %token  CLOSE_BRACE   \"}\"\n    %token  SLASH         \"/\"\n    %token  STAR          \"*\"\n    %token  CARET         \"^\"\n    // %skip \"-\"\n    %token  COMMA         \",\"\n    %token  SEMI_COLON    \";\"\n    %token  COLON         \":\"\n\n    %token  FRONT_MATTER                 /^---$/m    { toFrontMatter }\n    %token  SINGLE_LINE_RAW_STRING       />(.*)$/m    { toSingleLineRawString }\n    %token  MULTI_LINE_RAW_STRING        /r(#{0,})\"/  { toMultiLineRawString }\n\n    %token  EMBELISHMENT  /~[^\\s]*/                 { toEmbelishment }\n    %token  NUMBER        /-?\\d+/                   { toNumber }\n    %token  BOOLEAN       /true|false/              { toBoolean }\n    %token  STRING        /\"([^\"\\\\\\n]|\\\\.|\\\\\\n)*\"/  { toString }\n    %token  STRING        /'([^'\\\\\\n]|\\\\.|\\\\\\n)*'/  { toString }\n    %token  MARKER_NAME   /\\\\@{IDENT}/              { toMarkerName }\n    %token  DOTS_IDENT    /(\\.+)({IdentChar}+)/     { toOctavedNote   }\n    %token  IDENT_DOTS    /({IdentChar}+)(\\.+)/     { toOctavedNote   }\n    %token  IDENT_COLON   /{IdentChar}+:/           { toRoleSelector  }\n    %token  IDENT         /{IdentChar}+/\n    %token  BSLASH_IDENT  /\\\\{IDENT}/               { toCommandName   }\n    %token  BSLASH_NUMBER /\\\\{NUMBER}/\n    %token  HYPHEN        /-/\n    %skip                 /[ \\t\\n\\f\\r]+/\n    %skip_flex            \"//.*$\"\n    %skip                 /\\/\\*.*?\\*\\//\n\n    Document -> Elements\n              | FRONT_MATTER Elements { prependFrontMatter }\n              ;\n\n    Elements -> Elements Command Atoms { appendCommand } \n              | Elements RoleSelector Atoms { appendRoleSelector } \n              | Elements Embedding  Atoms { insertEmbedding }\n              | Atoms { appendAtoms }\n              ;\n\n    Embedding -> SINGLE_LINE_RAW_STRING | MULTI_LINE_RAW_STRING ;\n\n    Command -> BSLASH_IDENT CommandParams ? OptBlock { newCommandWithBlock } ;\n    CommandParams -> OPEN_PAREN ParamList ? CLOSE_PAREN { $2 } ;\n    OptBlock -> Block\n             | { nullBlock }\n             ;\n    Block -> BlockStart Elements CLOSE_BRACE { endBlock } ;\n    BlockStart -> OPEN_BRACE { beginBlock } ;\n\n    ParamList -> ParamList COMMA Param { concatParamList } ;\n    ParamList -> Param { newParamList };\n    Param -> ParamValue { newParam } ;\n    Param -> ParamKey EQUALS ParamValue { newParam } ;\n    ParamKey  -> IDENT ;\n    ParamValue -> ( STRING | Fraction | NUMBER | BOOLEAN ) ;\n\n    RoleSelector -> IDENT_COLON ;\n\n    Atoms -> Atoms Atom { concatAtoms } ;\n    Atoms -> { newArray } ;\n\n    Atom -> Leaf ;\n\n    Leaf -> Space | Lit | Group | Rest | Marker ;\n    Marker -> MARKER_NAME CommandParams { newMarker } ;\n    Leaf -> Duration Leaf { applyDuration } ;\n    Rest -> HYPHEN { newRest };\n    Space -> COMMA { newSpace } \n          | SEMI_COLON { newDoubleSpace } \n          | UNDER_SCORE { newSilentSpace } \n          ;\n\n    /* - An alternative representation to support both pre and\n     *   post embelishment operators.   Here PRE_EMBs have a higher\n     *   associativity over POST_EMBs\n     */\n     Lit -> Lit POST_EMB  { litWithPostEmb }\n         | PreEmbLit\n         ;\n\n     PreEmbLit -> LitToken \n                | LitToken CARET NUMBER { litWithCaret }\n                | LitToken CARET STAR   { litWithCaret }\n                | PRE_EMB PreEmbLit     { litWithPreEmb }\n                ;\n      \n     LitToken -> DOTS_IDENT { litToAtom }\n              | IDENT { litToAtom }\n              | IDENT_DOTS { litToAtom }\n              | STRING  { litToAtom }\n              ;\n\n    Group -> OPEN_SQ Atoms CLOSE_SQ { newGroup };\n\n    Duration -> Fraction | NUMBER;\n    Fraction -> NUMBER SLASH NUMBER { newFraction } ;\n    `,\n  {\n    debug: \"\",\n    type: \"lalr\",\n    leftRecursive: true,\n    tokenHandlers: {\n      toEmbelishment: (token: TLEX.Token, tape: TLEX.TapeInterface, owner: any) => {\n        const [emb, pre] = owner.parseEmbelishment(token.value);\n        if (emb == null) {\n          console.log(\"Skipping Embelishment: \", token.value);\n          owner.errors.push(\n            new TLEX.TokenizerError(\n              `Invalid embelishment: ${token.value}`,\n              token.start,\n              1 + token.end - token.start,\n              \"InvalidEmbelishment\",\n              token.value,\n            ),\n          );\n          return null;\n        }\n        token.value = emb;\n        token.tag = pre ? \"PRE_EMB\" : \"POST_EMB\";\n        return token;\n      },\n      toCommandName: (token: TLEX.Token, _tape: TLEX.TapeInterface, _owner: any) => {\n        token.value = token.value.substring(1);\n        return token;\n      },\n      toBoolean: (token: TLEX.Token, _tape: TLEX.TapeInterface, _owner: any) => {\n        token.value = token.value == \"true\";\n        return token;\n      },\n      toNumber: (token: TLEX.Token, _tape: TLEX.TapeInterface, _owner: any) => {\n        token.value = parseInt(token.value);\n        return token;\n      },\n      toString: (token: TLEX.Token, _tape: TLEX.TapeInterface, _owner: any) => {\n        token.value = token.value.substring(1, token.value.length - 1);\n        return token;\n      },\n      toMarkerName: (token: TLEX.Token, _tape: TLEX.TapeInterface, _owner: any) => {\n        // Extract marker name from \\@markerName - skip the \\@\n        token.value = token.value.substring(2);\n        return token;\n      },\n      toOctavedNote: (token: TLEX.Token, _tape: TLEX.TapeInterface, _owner: any) => {\n        if (token.tag == \"DOTS_IDENT\") {\n          const octave = token.positions[1][1] - token.positions[1][0];\n          const note = token.value.substring(octave);\n          token.value = new Note(note, ONE, -octave);\n        } else if (token.tag == \"IDENT_DOTS\") {\n          const octave = token.positions[2][1] - token.positions[2][0];\n          const note = token.value.substring(0, token.value.length - octave);\n          token.value = new Note(note, ONE, octave);\n        } else {\n          throw new Error(\"Invalid token for converting to note: \" + token.tag);\n        }\n        return token;\n      },\n      toRoleSelector: (token: TLEX.Token, _tape: TLEX.TapeInterface, _owner: any) => {\n        token.value = token.value.substring(0, token.value.length - 1);\n        return token;\n      },\n      toLineAnnotation: (token: TLEX.Token, _tape: TLEX.TapeInterface, _owner: any) => {\n        // skip the initial \"!\"\n        token.value = token.value.substring(1);\n        return token;\n      },\n      toSingleLineRawString: (token: TLEX.Token, _tape: TLEX.TapeInterface, _owner: any) => {\n        // skip the initial \">\"\n        token.value = token.value.substring(1);\n        return token;\n      },\n      toMultiLineRawString: (token: TLEX.Token, tape: TLEX.TapeInterface, _owner: any) => {\n        // consume everything until \"#<N times> as start\n        const hashes = tape.substring(token.positions[1][0], token.positions[1][1]);\n        const endPat = '\"' + hashes;\n        const startPos = tape.index;\n        const endPos = TLEX.TapeHelper.advanceAfter(tape, endPat) - endPat.length;\n        if (endPos < 0) {\n          throw new Error(\"EOF expected while finding end of Raw String Literal: '\" + endPat + \"'\");\n        }\n        token.value = tape.substring(startPos, endPos);\n        return token;\n      },\n      toFrontMatter: (token: TLEX.Token, tape: TLEX.TapeInterface, _owner: any) => {\n        // skip the initial \">\"\n        const endPat = \"\\n---\";\n        const startPos = tape.index;\n        const endPos = TLEX.TapeHelper.advanceAfter(tape, endPat) - endPat.length;\n        if (endPos < 0) {\n          throw new Error(\"EOF expected while finding end of front matter\");\n        }\n        token.value = tape.substring(startPos, endPos);\n        // console.log(\"Found FM: \", token.value);\n        return token;\n      },\n    },\n  },\n);\n\n/**\n * A notation doc is a list of lines that are found in a single document.\n *\n * Since our document (md or html etc) can contain multiple snippets\n * all these snippets are related\n */\nimport {\n  Block,\n  SectionBlock,\n  RepeatBlock,\n  CycleBlock,\n  BeatDurationBlock,\n  BreaksBlock,\n  RoleBlock,\n  GroupBlock,\n} from \"./block\";\nimport { parseCycle } from \"./utils\";\n\n/**\n * Wrapper for a command that has a block of child commands.\n * When applied, it creates the appropriate Block subclass and applies child commands to it.\n */\nexport class BlockCommand extends Command {\n  readonly innerCommand: Command;\n  readonly blockCommands: Command[];\n\n  constructor(innerCommand: Command, blockCommands: Command[]) {\n    super(innerCommand.params);\n    this.innerCommand = innerCommand;\n    this.blockCommands = blockCommands;\n  }\n\n  get name(): string {\n    return `Block(${this.innerCommand.name})`;\n  }\n\n  /**\n   * Creates the appropriate Block subclass based on the inner command type.\n   */\n  private createBlock(parent: Block): Block {\n    const cmd = this.innerCommand;\n\n    if (cmd instanceof Section) {\n      return new SectionBlock(cmd.sectionName, parent);\n    } else if (cmd instanceof Repeat) {\n      return new RepeatBlock(cmd.count, parent);\n    } else if (cmd instanceof SetCycle) {\n      const cycle = parseCycle(cmd.getParamAt(0));\n      return new CycleBlock(cycle, parent);\n    } else if (cmd instanceof SetBeatDuration) {\n      return new BeatDurationBlock(cmd.beatDuration, parent);\n    } else if (cmd instanceof SetBreaks) {\n      return new BreaksBlock(cmd.pattern, parent);\n    } else if (cmd instanceof CreateRole) {\n      const roleName = cmd.getParamAt(0);\n      return new RoleBlock(roleName, cmd.notesOnly, parent);\n    } else if (cmd instanceof ScopedGroup) {\n      return new GroupBlock(cmd.groupName || null, parent);\n    } else {\n      // Generic block for other commands\n      return new Block(cmd.name.toLowerCase(), parent);\n    }\n  }\n\n  debugValue(): any {\n    return {\n      name: this.name,\n      index: this.index,\n      innerCommand: this.innerCommand.debugValue(),\n      blockCommands: this.blockCommands.map((cmd) => cmd.debugValue()),\n    };\n  }\n\n  applyToNotation(notation: Notation): void {\n    // Create the appropriate Block subclass\n    // Cast notation as Block since Notation will extend Block\n    const block = this.createBlock(notation as unknown as Block);\n\n    // Apply all child commands to the block\n    for (const cmd of this.blockCommands) {\n      cmd.applyToBlock(block);\n    }\n\n    // Add the block to the notation\n    notation.addBlockItem(block);\n  }\n\n  applyToBlock(container: Block): void {\n    // Create the appropriate Block subclass\n    const block = this.createBlock(container);\n\n    // Apply all child commands to the block\n    for (const cmd of this.blockCommands) {\n      cmd.applyToBlock(block);\n    }\n\n    // Add the block to the container\n    container.addBlockItem(block);\n  }\n}\n\nexport class Parser {\n  errors: (TLEX.TokenizerError | G.ParseError)[] = [];\n  metadata: any = {};\n  readonly commands: Command[] = [];\n  // Stack to track command indices when entering blocks\n  private blockStartStack: number[] = [];\n\n  protected ruleHandlers = {\n    newFraction: (rule: G.Rule, parent: G.PTNode, ...children: G.PTNode[]) => {\n      if (children.length == 1) {\n        return new TSU.Num.Fraction(children[0].value);\n      } else {\n        return new TSU.Num.Fraction(children[0].value, children[2].value);\n      }\n    },\n    newGroup: (rule: G.Rule, parent: G.PTNode, ...children: G.PTNode[]) => {\n      const out = new Group(...children[1].value).setDuration(TWO, true);\n      return out;\n    },\n    litWithCaret: (rule: G.Rule, parent: G.PTNode, ...children: G.PTNode[]) => {\n      const lit = Note.fromLit(children[0].value as Literal);\n      const opnode = children[2];\n      const shiftValue = opnode.sym.label == \"STAR\" ? true : opnode.value;\n      lit.shift = shiftValue;\n      return lit;\n    },\n    litWithPreEmb: (rule: G.Rule, parent: G.PTNode, ...children: G.PTNode[]) => {\n      const emb = children[0];\n      const lit = children[1].value as Literal;\n      lit.embelishments.splice(0, 0, emb.value);\n      return lit;\n    },\n    litWithPostEmb: (rule: G.Rule, parent: G.PTNode, ...children: G.PTNode[]) => {\n      const lit = children[0].value as Literal;\n      const emb = children[1];\n      lit.embelishments.push(emb);\n      return lit;\n    },\n    litToAtom: (rule: G.Rule, parent: G.PTNode, ...children: G.PTNode[]) => {\n      const lit = children[0];\n      if (lit.sym.label == \"DOTS_IDENT\" || lit.sym.label == \"IDENT_DOTS\") {\n        return lit.value;\n      } else if (lit.sym.label == \"IDENT\") {\n        // Mark this as a Literal to be processed later\n        return new Literal(lit.value);\n        // return role.notesOnly ? new Note(lit.value) : new Syllable(lit.value);\n      } else if (lit.sym.label == \"STRING\") {\n        // const role = this.snippet.currRole;\n        // if (role.notesOnly) throw new Error(\"Strings cannot appear in notes only mode\");\n        return new Syllable(lit.value);\n      } else {\n        throw new Error(\"Invalid lit: \" + lit);\n      }\n    },\n    newSpace: (_rule: G.Rule, _parent: G.PTNode, ..._children: G.PTNode[]) => {\n      return new Space();\n    },\n    newRest: (_rule: G.Rule, _parent: G.PTNode, ..._children: G.PTNode[]) => {\n      return new Rest();\n    },\n    newDoubleSpace: (_rule: G.Rule, _parent: G.PTNode, ..._children: G.PTNode[]) => {\n      return new Space(ONE.timesNum(2));\n    },\n    newSilentSpace: (_rule: G.Rule, _parent: G.PTNode, ..._children: G.PTNode[]) => {\n      return new Space(ONE, true);\n    },\n    newMarker: (rule: G.Rule, parent: G.PTNode, ...children: G.PTNode[]) => {\n      const name = children[0].value as string;\n      const params = children[1].value || [];\n      return new Marker(name, params);\n    },\n    applyDuration: (rule: G.Rule, parent: G.PTNode, ...children: G.PTNode[]) => {\n      let dur = children[0].value as TSU.Num.Fraction | number;\n      const leaf = children[1].value as Atom;\n      if (typeof dur === \"number\") {\n        dur = ONE.timesNum(dur);\n      }\n      if (leaf.TYPE == AtomType.GROUP) {\n        (leaf as Group).setDuration(dur, true);\n      } else {\n        leaf.duration = dur;\n      }\n      return leaf;\n    },\n    newArray: (rule: G.Rule, parent: G.PTNode, ...children: G.PTNode[]) => {\n      // create an array of values from all the values of child nodes\n      return children.map((c) => c.value);\n    },\n    concatAtoms: (rule: G.Rule, parent: G.PTNode, ...children: G.PTNode[]) => {\n      const atoms = children[0].value;\n      const atom = children[1].value;\n      atoms.push(atom);\n      return atoms;\n    },\n    newParam: (rule: G.Rule, parent: G.PTNode, ...children: G.PTNode[]) => {\n      if (children.length == 1) {\n        return { key: null, value: children[0].value };\n      } else {\n        return { key: children[0].value, value: children[2].value };\n      }\n    },\n    newParamList: (rule: G.Rule, parent: G.PTNode, ...children: G.PTNode[]) => {\n      return [children[0].value];\n    },\n    concatParamList: (rule: G.Rule, parent: G.PTNode, ...children: G.PTNode[]) => {\n      const params = children[0].value;\n      const newParam = children[2].value;\n      params.push(newParam);\n      return params;\n    },\n    // Block handling semantic actions\n    beginBlock: (_rule: G.Rule, _parent: G.PTNode, ..._children: G.PTNode[]) => {\n      // Push current command count to track where this block's commands start\n      this.blockStartStack.push(this.commands.length);\n      return null;\n    },\n    endBlock: (_rule: G.Rule, _parent: G.PTNode, ..._children: G.PTNode[]) => {\n      // Pop the start index and extract commands added since then\n      const startIndex = this.blockStartStack.pop()!;\n      const blockCommands = this.commands.splice(startIndex);\n      return blockCommands;\n    },\n    nullBlock: (_rule: G.Rule, _parent: G.PTNode, ..._children: G.PTNode[]) => {\n      // No block present\n      return null;\n    },\n    newCommandWithBlock: (rule: G.Rule, parent: G.PTNode, ...children: G.PTNode[]) => {\n      const name = children[0].value;\n      const params = children[1].value;\n      const blockCommands = children[2].value as Command[] | null;\n\n      const innerCommand = this.createCommand(name, params);\n\n      if (blockCommands !== null) {\n        // Wrap in BlockCommand\n        return new BlockCommand(innerCommand, blockCommands);\n      } else {\n        // No block, return regular command\n        return innerCommand;\n      }\n    },\n    appendAtoms: (rule: G.Rule, parent: G.PTNode, ...children: G.PTNode[]) => {\n      const atoms = children[0].value as Atom[];\n      if (atoms.length > 0) {\n        this.addCommand(new AddAtoms(...atoms));\n      }\n      return null;\n    },\n    prependFrontMatter: (rule: G.Rule, parent: G.PTNode, ...children: G.PTNode[]) => {\n      const fm = children[0].value;\n      // console.log(\"Child 0: \", fm);\n      // console.log(\"Child 1: \", children[1].value);\n      const data = YAML.parse(fm);\n      console.log(\"Parsed FM: \", data);\n      this.metadata = data;\n      return children[1].value;\n    },\n    appendCommand: (rule: G.Rule, parent: G.PTNode, ...children: G.PTNode[]) => {\n      const command = children[1].value as Command;\n      this.addCommand(command);\n\n      const atoms = children[2].value as Atom[];\n      if (atoms.length > 0) {\n        this.addCommand(new AddAtoms(...atoms));\n      }\n      return null;\n    },\n    appendRoleSelector: (rule: G.Rule, parent: G.PTNode, ...children: G.PTNode[]) => {\n      const roleName = children[1].value;\n      const lName = roleName.toLowerCase().trim();\n      this.addCommand(new ActivateRole([{ key: null, value: lName }]));\n\n      const atoms = children[2].value as Atom[];\n      if (atoms.length > 0) {\n        this.addCommand(new AddAtoms(...atoms));\n      }\n      return null;\n    },\n    insertEmbedding: (rule: G.Rule, parent: G.PTNode, ...children: G.PTNode[]) => {\n      // How to handle embeddings - these are just blocks\n      // to escape out of song (most likely for some rendering of html/md etc)\n      const rawVal = children[1].value;\n      this.addCommand(new RawEmbedding([{ key: null, value: rawVal }]));\n      const atoms = children[2].value as Atom[];\n      if (atoms.length > 0) {\n        this.addCommand(new AddAtoms(...atoms));\n      }\n      return null;\n    },\n  };\n\n  constructor(_config?: any) {\n    // config = config || {};\n  }\n\n  createCommand(name: string, params: CmdParam[]): Command {\n    const lName = name.trim().toLowerCase();\n    params = params || [];\n    if (lName == \"line\") {\n      return new CreateLine(params);\n      // } else if (lName == \"meta\") { return new MetaData(params);\n    } else if (lName == \"role\") {\n      return new CreateRole(params);\n    } else if (lName == \"layout\") {\n      return new ApplyLayout(params);\n    } else if (lName == \"beatduration\") {\n      return new SetBeatDuration(params);\n    } else if (lName == \"breaks\") {\n      return new SetBreaks(params);\n    } else if (lName == \"cycle\") {\n      return new SetCycle(params);\n    } else if (lName == \"section\") {\n      return new Section(params);\n    } else if (lName == \"group\") {\n      return new ScopedGroup(params);\n    } else if (lName == \"repeat\") {\n      return new Repeat(params);\n    } else {\n      // Try to set this as the current role\n      throw new Error(\"Invalid command: \" + lName);\n    }\n  }\n\n  addCommand(cmd: Command): void {\n    cmd.index = this.commands.length;\n    this.commands.push(cmd);\n  }\n\n  parse(input: string): any {\n    this.errors = [];\n    try {\n      const ptree = parser.parse(input, {\n        tokenizerContext: this,\n        ruleHandlers: this.ruleHandlers,\n        onTokenError: (err: TLEX.TokenizerError) => {\n          this.errors.push(err);\n          return true;\n        },\n      });\n      return ptree;\n    } catch (err) {\n      if (err instanceof G.ParseError) {\n        this.errors.push(err);\n      } else {\n        throw err;\n      }\n    }\n    return null;\n  }\n\n  parseAndBuild(input: string): [Notation, G.ParseError[]] {\n    this.parse(input);\n    const notation = new Notation();\n    const errors: G.ParseError[] = [];\n    errors.push(...this.errors);\n\n    // First add the metadata then we can set it\n    for (const key in this.metadata) notation.addMetaData(new Meta(key, this.metadata[key]));\n    for (const cmd of this.commands) cmd.applyToNotation(notation);\n    return [notation, errors];\n  }\n\n  parseEmbelishment(value: string): [any, boolean] {\n    return carnatic.parseEmbelishment(value);\n  }\n}\n"],"names":["EntityWithParams","Command","constructor","params","super","autoGenerated","prevSibling","nextSibling","this","index","validateParams","name","debugValue","applyToNotation","notation","applyToBlock","MetaData","key","value","Notation","TYPE","metadata","Map","onMissingRole","newRoleDef","_currRoleDef","_currentLine","localCycle","DEFAULT","localAtomsPerBeat","localBreaks","blocks","blockItems","currentAPB","currentCycle","currentBreaks","roles","Array","from","localRoles","values","setCurrRole","trim","toLowerCase","Error","roleDef","getRole","getRoleDef","length","get","notesOnly","has","rd","size","set","addLine","line","addBlockItem","removeLine","removeBlockItem","addRawBlock","raw","resetLine","addMetaData","meta","addBlock","map","b","uuid","currRoleDef","currentLine","newLine","isEmpty","LeafAtomViewEmbelishment","atomView","OctaveIndicator","noteView","note","dotRadius","dotSpacing","rootElem","embRoot","numDots","Math","abs","octave","dotsElem","doc","document","parent","attrs","width","height","source","leafAtom","cx","i","cy","r","class","refreshBBox","refreshMinSize","updateBounds","x","y","_w","_h","refreshLayout","setAttribute","LabelEmbelishment","label","labelElem","text","w","h","BeatStartLines","rootElement","barSpacing","bbox","BeatEndLines","nLines","lineSpacing","lines","push","updatePosition","currX","lx","_x","_y","Kampitham","Nokku","Prathyagatham","Spuritham","Raavi","Kandippu","Vaali","Odukkal","Orikkai","Jaaru","jaaru","pathElem","d","pathAttribute","avbbox","glyph","minSize","y2","h2","x2","ascending","join","GroupBracket","groupView","leftCircle","rightCircle","bracketGroup","lineOffset","circleRadius","lineExtension","positionMode","groupElement","group","String","groupWidth","contentWidth","x1","FlatAtom","atom","config","depth","duration","offset","ZERO","isContinuation","endOffset","plus","out","toString","AtomIterator","atoms","atomQueue","currOffset","peeked","add","next","peek","factorized","hasNext","nextAtom","nextDepth","nextDuration","popFront","first","GROUP","child","reversedValues","pushFront","times","divby","totalChildDuration","getMin","iterators","currRole","currAtom","ri","flatAtom","cmp","WindowIterator","participatesInTiming","hasMore","remaining","isGTNum","spillOver","splitAt","minus","isZero","DurationIterator","atomIterator","iter","AtomChangeType","RoleChangeType","BlockItemChangeType","ModelEvents","ATOMS_CHANGED","ROLES_CHANGED","ITEMS_CHANGED","DURATION_CHANGED","ONE","CycleCursor","cycle","barIndex","beatIndex","instance","currBar","bars","result","beatLengths","beatCounts","prev","beatCount","Bar","bl","bc","equals","another","copyTo","instanceCount","totalBeatCount","total","timesNum","Cycle","p","children","getAtIndex","globalIndex","floor","bar","beatLength","getPosition","globalOffset","cycleNum","isLT","isGTE","realOffset","mod","isWhole","barDuration","iterateBeats","startBar","startBeat","startInstance","instanceIndex","clone","reduce","LineView","roleSpacing","rowSpacing","gElem","id","wrapToSize","getBBox","prefSize","GroupView","createAtomView","defaultToNotes","createEmbelishments","embelishments","baseSize","BRACKET_HEIGHT","scaleFactor","LeafAtomView","leftSlot","topSlot","rightSlot","bottomSlot","rootGroup","element","rootText","totalWidth","a","totalHeight","glyphOffset","NaN","layoutElements","currY","hasY","emb","textX","gminSize","glyphX","glyphY","bb","setBounds","invalidateBounds","addEmbelishment","slot","orderEmbelishments","SYLLABLE","NOTE","lit","type","Aahaatam_Raavi","Aahaatam_Kandippu","Jaaru_Eetra","Jaaru_Irakka","needsRootElement","createElements","createGlyphRoot","createGlyphElement","createPostSpacingElement","atomid","glyphLabel","beforeRest","postSpacingSpan","SpaceView","space","isSilent","isOne","cmpNum","NoteView","shift","shiftElement","moveGlyphToRoot","appendChild","SyllableView","syllable","MarkerView","marker","UnknownAtomView","litDefaultsToNote","groupViewScale","SPACE","LITERAL","fromLit","MARKER","console","warn","ParamsMixin","Base","getParam","find","getParamAt","Entity","counter","_parent","_eventsEnabled","enableEvents","disableEvents","eventsEnabled","setParent","expect","newInstance","TimedEntity","GamakaType","Gamaka","JaaruGamaka","startingNote","parseEmbelishment","substring","endsWith","___CSS_LOADER_EXPORT___","module","NotationView","lineViews","currentSVGElement","layoutChangeUnsubscribe","beatViews","markerViews","loadChildViews","markdownParser","content","beatLayout","_beatLayout","gridLayoutGroup","getCellView","cell","viewForBeat","tableElement","renderNotation","startTime","performance","now","layoutTime","log","addNewRow","prefix","withAnnotation","tr","td1","colspan","newLineRoot","td2","marginText","innerHTML","style","ensureLineView","lineView","getLineView","layoutParams","svgElem","gridModel","getGridModelForLine","l","currentLineView","clear","processBlock","lastUpdatedAt","block","processBlockItem","item","renderBlock","contentType","indexOf","div","html","colIndex","beat","curr","role","lp","eagerlyPositionView","isPreMarker","markers","view","colAlign","coordOffset","rowAlign","maxLength","parse","input","parseAndBuild","load","codeText","errors","parseTime","buildTime","LayoutParams","beatDuration","_rowStartOffsets","_rowEndOffsets","_rowDurations","_totalLayoutDuration","_totalBeats","_beatLayouts","lineBreaks","layout","lineBreaksEqual","_lineBreaks","every","getBeatLocation","modIndex","totalBeats","cursor","val","beatLayouts","totalLayoutDuration","cycleIter","akb","numBeats","beats","nextCP","forEach","computeCollisionLayout","items","totalDuration","containerWidth","results","prevItemEndX","currTime","realX","wasCollision","minWidth","Shape","shapeId","idCounter","_width","_height","parentShape","_bbox","_minSize","applyLayout","isNaN","nx","ny","nw","nh","hasX","hasWidth","hasHeight","Embelishment","ElementShape","AtomView","roleIndex","isLeaf","viewId","atomViews","needsLayout","showContinuationMarkers","continuationMarkerElements","atomSpacing","setStyles","maxHeight","minWidthPerDuration","av","ms","dur","durValue","num","den","widthPerDur","max","totalDurValue","transform","unscaledContentHeight","totalDur","unscaledMinWidth","clearContinuationMarkers","prevNoteEndX","avWidth","atomDur","numMarkers","markerX","divbyNum","renderContinuationMarker","e","el","remove","_embelishments","options","styleTagTransform","setAttributes","insert","domAPI","insertStyleElement","locals","beatId","roleName","gridRow","rowIndex","gridCol","pre","textElement","dx","ts","BeatView","contentAtom","newX","newY","Beat","prevBeat","nextBeat","atomIsPlaceholder","filled","Group","setDuration","addAtoms","preMarkers","getMarkersWithPosition","postMarkers","position","AtomType","hasNonMarkerContent","BeatsBuilder","startOffset","beatOffset","windowIter","startIndex","currBeat","addBeat","remAtoms","onAtomAdded","onBeatFilled","lastBeat","apb","newBeat","isGT","Space","onBeatAdded","BeatColumn","markerType","keyFor","BeatColDAG","layoutGroup","beatColumns","getBeatColumn","bcol","newcreated","ensureBeatColumn","prevcol","nextcol","addSuccessor","other","GlobalBeatLayout","sharedGridLayoutGroup","gridModelsForLine","roleBeatsForLine","beatColDAGsByLP","lineid","addGridModel","beatColDAGForLP","lpid","eventHub","startBatchMode","lineToRoleBeats","commitBatch","roleBeats","beatColDAG","layoutLine","layoutColumn","rowOffset","colEnd","indexOfRole","nthLine","realLine","realRow","realCol","precol","setValue","col","postcol","Atom","parentGroup","_duration","LeafAtom","createSpilloverSpace","LeafAtomWithParams","Marker","firstParam","JSON","stringify","Rest","Literal","embs","Syllable","Note","durationIsSpeedMultiplier","_observers","addObserver","observer","removeObserver","splice","notifyObservers","ADD","onAtomsAdded","INSERT","onAtomsInserted","REMOVE","onAtomsRemoved","a1","a2","setDurationAsMultiplier","asSpeedMultiplier","requiredDuration","isLTE","targetGroup","remainingDur","durationFactor","last","lastChild","childDuration","newDuration","newRequiredDur","insertAtomsAt","removeAtoms","beforeAtom","adjustDuration","oldChildDuration","insertIndex","addedAtoms","REST","LABEL","removedAtoms","Line","ensureRole","findIndex","Role","onRoleAdded","removeRole","onRoleRemoved","idx","cycleStrToBarsStrs","cycleStr","replace","split","filter","parseCycle","parseBar","barStr","cp","count","ch","parseInt","comps","test","parseSyllable","notes","syll","parseProperty","SparseArray","runs","vals","valueAt","creator","setAt","removeAt","numToDelete","valuesToInsert","RawEmbedding","rawContents","container","ActivateRole","AddAtoms","lpForLine","CreateLine","CreateRole","LayoutParamCommand","ApplyLayout","ensureNamedLayoutParams","SetBreaks","pattern","cmd","param","resetLayoutParams","SetCycle","SetBeatDuration","Section","sectionName","_container","ScopedGroup","groupName","Repeat","TWO","parser","debug","leftRecursive","tokenHandlers","toEmbelishment","token","tape","owner","start","end","tag","toCommandName","_tape","_owner","toBoolean","toNumber","toMarkerName","toOctavedNote","positions","toRoleSelector","toLineAnnotation","toSingleLineRawString","toMultiLineRawString","endPat","startPos","endPos","advanceAfter","toFrontMatter","BlockCommand","innerCommand","blockCommands","createBlock","Parser","_config","commands","blockStartStack","ruleHandlers","newFraction","rule","newGroup","litWithCaret","opnode","shiftValue","sym","litWithPreEmb","litWithPostEmb","litToAtom","newSpace","_rule","_children","newRest","newDoubleSpace","newSilentSpace","newMarker","applyDuration","leaf","newArray","c","concatAtoms","newParam","newParamList","concatParamList","beginBlock","endBlock","pop","nullBlock","newCommandWithBlock","createCommand","appendAtoms","addCommand","prependFrontMatter","fm","data","appendCommand","command","appendRoleSelector","lName","insertEmbedding","rawVal","tokenizerContext","onTokenError","err","carnatic"],"ignoreList":[],"sourceRoot":""}