{"version":3,"file":"DocsPage.79625b3730fe414e66ad.js","mappings":"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","sources":["webpack://notations/webpack/universalModuleDefinition","webpack://notations/webpack/runtime/chunk loaded","webpack://notations/./src/grids.ts","webpack://notations/./src/block.ts","webpack://notations/./src/web/components/NotationBlock.ts","webpack://notations/./docs/components/NotationViewer.ts","webpack://notations/./docs/components/DocsPage.ts","webpack://notations/webpack/bootstrap","webpack://notations/webpack/runtime/compat get default export","webpack://notations/webpack/runtime/define property getters","webpack://notations/webpack/runtime/hasOwnProperty shorthand","webpack://notations/webpack/runtime/make namespace object","webpack://notations/webpack/runtime/jsonp chunk loading","webpack://notations/webpack/runtime/nonce","webpack://notations/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"notations\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"notations\"] = factory();\n\telse\n\t\troot[\"notations\"] = root[\"notations\"] || {}, root[\"notations\"][\"DocsPage\"] = factory();\n})(this, () => {\nreturn ","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","import * as TSU from \"@panyam/tsutils\";\n// import * as kiwi from \"@lume/kiwi\";\n\n/**\n * Event emitted when layout changes occur in a GridLayoutGroup.\n * Subscribers can use this to update their views incrementally.\n */\nexport interface LayoutChangeEvent {\n  /** The range of rows affected by the change */\n  affectedRowRange: { start: number; end: number } | null;\n  /** The range of columns affected by the change */\n  affectedColRange: { start: number; end: number } | null;\n  /** Whether column widths changed (requires horizontal re-layout) */\n  columnWidthsChanged: boolean;\n  /** Whether row heights changed (requires vertical re-layout) */\n  rowHeightsChanged: boolean;\n  /** The grid models that were affected */\n  affectedGridModels: GridModel[];\n}\n\n/**\n * Callback type for layout change subscribers.\n */\nexport type LayoutChangeCallback = (event: LayoutChangeEvent) => void;\n\n/**\n * A generic grid layout system for hosting child views (similar to GridBagLayout).\n * This provides a framework for hosting BeatViews in a structured grid arrangement,\n * with support for rows, columns, and alignment.\n *\n * Grid \"cells\" can be referred to by cell indexes. Additionally, grid rows and\n * columns can have names (like in spreadsheets) so that even when rows and columns\n * are inserted, though indexes may change, the \"addresses\" remain fixed and immovable.\n */\nexport class GridModel extends TSU.Events.EventEmitter {\n  private static idCounter = 0;\n  readonly uuid = GridModel.idCounter++;\n  /** Timestamp of the last update to this grid */\n  lastUpdatedAt = 0;\n  // cells = new SparseArray<SparseArray<GridCell>>();\n  /** The rows in this grid */\n  rows: GridRow[] = [];\n  /** Mapping of row indices to row alignment objects */\n  rowAligns = new Map<number, RowAlign>();\n  /** Mapping of column indices to column alignment objects */\n  colAligns = new Map<number, ColAlign>();\n\n  /**\n   * Returns a debug-friendly representation of this GridModel.\n   * @returns An object containing debug information\n   */\n  debugValue() {\n    const out = {\n      rows: this.rows.map((r) => r.debugValue()),\n      lastUpdatedAt: this.lastUpdatedAt,\n    } as any;\n    return out;\n  }\n\n  /**\n   * Gets the index of the first non-empty row.\n   * @returns The index of the first row containing cells, or -1 if none\n   */\n  get firstRow(): number {\n    for (const gr of this.rows) {\n      if (gr.numCells > 0) return gr.rowIndex;\n    }\n    return -1;\n  }\n\n  /**\n   * Gets the index of the leftmost column containing cells.\n   * @returns The index of the first column containing cells, or -1 if none\n   */\n  get firstCol(): number {\n    let minCol = -1;\n    for (const gr of this.rows) {\n      const fc = gr.firstCol;\n      if (fc >= 0) {\n        if (minCol < 0 || fc < minCol) {\n          minCol = fc;\n        }\n      }\n    }\n    return minCol;\n  }\n\n  /**\n   * Gets all non-empty cells in a specific row.\n   * @param row The index of the row\n   * @returns An array of cells in the row\n   */\n  cellsInRow(row: number): GridCell[] {\n    const out = [] as GridCell[];\n    const gr = this.rows[row];\n    if (gr) {\n      for (const cell of gr.cells) {\n        if (cell?.value) out.push(cell);\n      }\n    }\n    return out;\n  }\n\n  /**\n   * Gets all non-empty cells in a specific column.\n   * @param col The index of the column\n   * @returns An array of cells in the column\n   */\n  cellsInCol(col: number): GridCell[] {\n    const out = [] as GridCell[];\n    for (const gr of this.rows) {\n      const cell = gr.cellAt(col);\n      if (cell?.value) out.push(cell);\n    }\n    return out;\n  }\n\n  /**\n   * Adds a row alignment object to the grid.\n   * @param align The row alignment to add\n   */\n  addRowAlign(align: RowAlign): void {\n    this.rowAligns.set(align.uuid, align);\n  }\n\n  /**\n   * Adds a column alignment object to the grid.\n   * @param align The column alignment to add\n   */\n  addColAlign(align: ColAlign): void {\n    this.colAligns.set(align.uuid, align);\n  }\n\n  /**\n   * Adds rows to the grid.\n   * @param insertBefore The index before which to insert the rows, or -1 to append\n   * @param numRows The number of rows to add\n   * @returns This grid instance for method chaining\n   */\n  addRows(insertBefore = -1, numRows = 1): this {\n    if (insertBefore < 0) {\n      insertBefore = this.rows.length;\n    }\n    let next = this.rows[insertBefore] || null;\n    const prev = this.rows[insertBefore - 1] || null;\n    for (let i = numRows - 1; i >= 0; i--) {\n      const newRow = new GridRow(this, insertBefore + i);\n      this.rows.splice(insertBefore, 0, newRow);\n      if (next != null) {\n        newRow.defaultRowAlign.addSuccessor(next.defaultRowAlign);\n      }\n      if (i == 0 && insertBefore > 0) {\n        prev.defaultRowAlign.addSuccessor(newRow.defaultRowAlign);\n      }\n      next = newRow;\n    }\n    for (let i = insertBefore + numRows; i < this.rows.length; i++) {\n      this.rows[i].rowIndex += numRows;\n    }\n    return this;\n  }\n\n  /**\n   * Gets a row at the specified index, creating it if necessary.\n   * @param row The index of the row to get\n   * @returns The row at the specified index\n   */\n  getRow(row: number): GridRow {\n    if (row >= this.rows.length) {\n      this.addRows(-1, 1 + row - this.rows.length);\n    }\n    return this.rows[row];\n  }\n\n  /**\n   * Sets a value in a cell at the specified row and column.\n   * @param row The row index\n   * @param col The column index\n   * @param value The value to set\n   * @param cellCreator Optional function to create a custom cell\n   * @returns The previous value of the cell\n   */\n  setValue(row: number, col: number, value: any, cellCreator?: (row: GridRow, col: number) => GridCell): any {\n    const grow = this.getRow(row);\n    if (!cellCreator) {\n      cellCreator = (row: GridRow, col: number) => {\n        return new GridCell(row, col);\n      };\n    }\n    if (value == null) {\n      const out = grow.clearCellAt(col);\n      if (out != null) {\n        this.eventHub?.emit(GridCellEvent.CLEARED, this, {\n          loc: out.location,\n        });\n      }\n      return out;\n    } else {\n      const cell = grow.cellAt(col, cellCreator) as GridCell;\n      const oldValue = cell.value;\n      this.eventHub?.emit(GridCellEvent.UPDATED, this, {\n        loc: cell.location,\n        cell: cell,\n        oldValue: cell.value,\n      });\n      cell.value = value;\n      return oldValue;\n    }\n  }\n\n  /**\n   * Handles changes to the event hub.\n   */\n  protected eventHubChanged(): void {\n    console.log(\"Event Hub Changed for GridModel\");\n  }\n}\n\n/**\n * Interface for a view associated with a grid cell.\n * GridCellView defines the contract for views that can be placed in grid cells.\n */\nexport interface GridCellView {\n  /** The grid cell this view is associated with */\n  readonly cell: GridCell;\n  /** X-coordinate of the view */\n  x: number;\n  /** Y-coordinate of the view */\n  y: number;\n  /** Width of the view */\n  width: number;\n  /** Height of the view */\n  height: number;\n\n  /**\n   * Sets the bounds of the view.\n   * @param x New x-coordinate, or null to keep current value\n   * @param y New y-coordinate, or null to keep current value\n   * @param w New width, or null to keep current value\n   * @param h New height, or null to keep current value\n   * @param applyLayout Whether to apply layout immediately\n   * @returns The new bounds values\n   */\n  setBounds(\n    x: number | null,\n    y: number | null,\n    w: number | null,\n    h: number | null,\n    applyLayout: boolean,\n  ): [number | null, number | null, number | null, number | null];\n\n  /** Whether this view needs layout */\n  readonly needsLayout: boolean;\n\n  /** The minimum size this view requires */\n  readonly minSize: TSU.Geom.Size;\n\n  /** The bounding box of this view */\n  readonly bbox: TSU.Geom.Rect;\n}\n\n/**\n * Enum defining the events that can occur on grid cells.\n */\nexport enum GridCellEvent {\n  ADDED = \"CellAdded\",\n  CLEARED = \"CellCleared\",\n  REMOVED = \"CellRemoved\",\n  UPDATED = \"CellUpdated\",\n  MOVED = \"CellMoved\",\n}\n\n/**\n * Represents a cell in the grid.\n * GridCell holds a value and manages alignment with rows and columns.\n */\nexport class GridCell {\n  private static idCounter = 0;\n  readonly uuid = GridCell.idCounter++;\n  /** The view associated with this cell */\n  cellView: GridCellView | null;\n  private _rowAlign: RowAlign;\n  private _colAlign: ColAlign;\n\n  /**\n   * Creates a new GridCell.\n   * @param gridRow The row this cell belongs to\n   * @param colIndex The column index of this cell\n   * @param value Optional initial value for the cell\n   */\n  constructor(\n    public gridRow: GridRow,\n    public colIndex: number,\n    public value: any = null,\n  ) {\n    this.rowAlign = gridRow.defaultRowAlign;\n  }\n\n  /**\n   * Gets the row alignment for this cell.\n   */\n  get rowAlign(): RowAlign {\n    return this._rowAlign;\n  }\n\n  /**\n   * Sets the row alignment for this cell.\n   */\n  set rowAlign(val: RowAlign) {\n    val.addCell(this);\n    this._rowAlign = val;\n  }\n\n  /**\n   * Gets the column alignment for this cell.\n   */\n  get colAlign(): ColAlign {\n    return this._colAlign;\n  }\n\n  /**\n   * Sets the column alignment for this cell.\n   */\n  set colAlign(val: ColAlign) {\n    val.addCell(this);\n    this._colAlign = val;\n  }\n\n  /**\n   * Gets the location string for this cell (rowIndex:colIndex).\n   */\n  get location(): string {\n    return this.gridRow.rowIndex + \":\" + this.colIndex;\n  }\n\n  /**\n   * Gets the grid this cell belongs to.\n   */\n  get grid(): GridModel {\n    return this.gridRow.grid;\n  }\n\n  /**\n   * Gets the row index of this cell.\n   */\n  get rowIndex(): number {\n    return this.gridRow.rowIndex;\n  }\n\n  /**\n   * Returns a debug-friendly representation of this GridCell.\n   * @returns An object containing debug information\n   */\n  debugValue() {\n    const out = {\n      r: this.gridRow.rowIndex,\n      c: this.colIndex,\n      value: this.value,\n      y: this.rowAlign.coordOffset,\n      h: this.rowAlign.maxLength,\n    } as any;\n    if (this.colAlign) {\n      out.x = this.colAlign.coordOffset;\n      out.w = this.colAlign.maxLength;\n    }\n    return out;\n  }\n}\n\n/**\n * Represents a row of grid cells in a GridModel.\n */\nexport class GridRow {\n  /** The cells in this row */\n  cells: (null | GridCell)[] = [];\n  /** The default vertical alignment for all cells in this row */\n  defaultRowAlign: RowAlign;\n\n  /**\n   * Creates a new GridRow.\n   * @param grid The grid this row belongs to\n   * @param rowIndex The index of this row\n   */\n  constructor(\n    public grid: GridModel,\n    public rowIndex: number,\n  ) {\n    this.defaultRowAlign = new RowAlign();\n    this.grid.addRowAlign(this.defaultRowAlign);\n  }\n\n  /**\n   * Gets the index of the first non-empty column in this row.\n   */\n  get firstCol() {\n    for (let i = 0; i < this.cells.length; i++) {\n      if (this.cells[i]?.value) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Gets the number of columns in this row.\n   */\n  get numCols() {\n    return this.cells.length;\n  }\n\n  /**\n   * Gets the number of cells that contain values.\n   */\n  get numCells() {\n    let i = 0;\n    for (const cell of this.cells) {\n      if (cell != null && cell.value != null) i++;\n    }\n    return i;\n  }\n\n  /**\n   * Gets the cell at the specified column index, optionally creating it if it doesn't exist.\n   * @param col The column index\n   * @param creator Optional function to create the cell if it doesn't exist\n   * @returns The cell at the specified index, or null if it doesn't exist and no creator was provided\n   */\n  cellAt(col: number, creator?: (row: GridRow, col: number) => GridCell): GridCell | null {\n    let out = this.cells[col] || null;\n    if (!out && creator) {\n      this.cells[col] = out = creator(this, col);\n      out.gridRow = this;\n      out.colIndex = col;\n      if (out.rowAlign) {\n        this.grid.addRowAlign(out.rowAlign);\n      }\n      if (out.colAlign) {\n        this.grid.addColAlign(out.colAlign);\n      }\n    }\n    return out;\n  }\n\n  /**\n   * Clears the cell at the given column.\n   * Note this is not the same as \"removing\" a cell.\n   * Removing a cell would require all cells to the \"right\" to be shifted left.\n   * @param col The column index\n   * @returns The cell that was cleared, or null if none existed\n   */\n  clearCellAt(col: number): GridCell | null {\n    const out = this.cells[col] || null;\n    if (out) {\n      this.cells[col] = null;\n    }\n    return out;\n  }\n\n  /**\n   * Returns a debug-friendly representation of this GridRow.\n   * @returns An object containing debug information\n   */\n  debugValue() {\n    return {\n      r: this.rowIndex,\n      cells: this.cells.filter((c) => c).map((c) => c?.debugValue()),\n    };\n  }\n}\n\n/**\n * Base class for row and column alignment objects.\n * AlignedLine manages the alignment of cells along a line (row or column).\n */\nexport abstract class AlignedLine {\n  private static idCounter = 0;\n  readonly uuid = AlignedLine.idCounter++;\n  /** Whether this line needs layout */\n  needsLayout = false;\n  /** The coordinate offset of this line */\n  protected _coordOffset = 0;\n  /** The maximum length of this line */\n  protected _maxLength = 0;\n  /** Padding before this line */\n  paddingBefore = 5;\n  /** Padding after this line */\n  paddingAfter = 5;\n  /** The cells that belong to this line */\n  cells: GridCell[] = [];\n  /** Function to get a view for a cell value */\n  getCellView: (value: any) => GridCellView;\n\n  /**\n   * Sets the offset of this line.\n   * @param val The new offset value\n   */\n  abstract setOffset(val: number): void;\n\n  /**\n   * Evaluates the maximum length required for this line.\n   * @param changedCells Cells that have changed and need re-evaluation\n   * @returns The maximum length\n   */\n  abstract evalMaxLength(changedCells: GridCell[]): number;\n\n  /**\n   * Gets the coordinate offset of this line.\n   */\n  get coordOffset(): number {\n    return this._coordOffset;\n  }\n\n  /**\n   * Gets the maximum length of this line, including padding.\n   */\n  get maxLength(): number {\n    return this._maxLength + this.paddingBefore + this.paddingAfter;\n  }\n\n  /**\n   * Sets the maximum length of this line.\n   * @param length The new maximum length\n   */\n  setMaxLength(length: number) {\n    this._maxLength = length;\n  }\n\n  /**\n   * Sets the padding before and after this line.\n   * @param before Padding before the line\n   * @param after Padding after the line\n   */\n  setPadding(before: number, after: number): void {\n    if (before >= 0) {\n      this.paddingBefore = before;\n    }\n    if (after >= 0) {\n      this.paddingAfter = after;\n    }\n  }\n\n  /**\n   * Adds a cell to this line.\n   * @param cell The cell to add\n   * @returns This line instance for method chaining\n   */\n  addCell(cell: GridCell): this {\n    if (this.beforeAddingCell(cell)) {\n      this.cells.push(cell);\n    }\n    return this;\n  }\n\n  /**\n   * Called before adding a cell to perform validation or preparation.\n   * @param cell The cell to be added\n   * @returns Whether the cell should be added\n   */\n  protected abstract beforeAddingCell(cell: GridCell): boolean;\n\n  /**\n   * Removes a cell from this line.\n   * @param cell The cell to remove\n   * @returns This line instance for method chaining\n   */\n  removeCell(cell: GridCell): this {\n    if (this.beforeRemovingCell(cell)) {\n      for (let i = 0; i < this.cells.length; i++) {\n        if (this.cells[i].uuid == cell.uuid) {\n          this.cells.splice(i, 1);\n          break;\n        }\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Called before removing a cell to perform validation.\n   * @param cell The cell to be removed\n   * @returns Whether the cell should be removed\n   */\n  protected abstract beforeRemovingCell(cell: GridCell): boolean;\n\n  // The \"neighboring\" lines that depend on this line to be placed\n  // before they are placed\n  /** Lines that must be positioned before this line */\n  prevLines = [] as this[];\n  /** Lines that must be positioned after this line */\n  nextLines = [] as this[];\n\n  /**\n   * Adds a successor line to this line.\n   * @param next The line to add as a successor\n   */\n  addSuccessor(next: this): void {\n    // Set nextCol as a successor of this col\n    // TODO - Ensure no cycles\n    for (const c of this.nextLines) {\n      if (c == next) return;\n    }\n    this.nextLines.push(next);\n    next.prevLines.push(this);\n  }\n\n  /* TODO: Disabling only to improve test coverage as this method is\n   * not used.\n   * When we have mutable grids where we can insert/remove neighbors\n   * we can enable this again.\n   */\n  /*\n  removeSuccessor(next: this): void {\n    // Set nextCol as a successor of this col\n    // TODO - Ensure no cycles\n    for (let i = 0; i < this.nextLines.length; i++) {\n      if (this.nextLines[i] == next) {\n        this.nextLines.splice(i, 1);\n        break;\n      }\n    }\n    for (let i = 0; i < next.prevLines.length; i++) {\n      if (next.prevLines[i] == this) {\n        next.prevLines.splice(i, 1);\n        break;\n      }\n    }\n  }\n  */\n}\n\n/**\n * Manages the alignment of cells in a column.\n */\nexport class ColAlign extends AlignedLine {\n  paddingBefore = 10;\n  /** Padding after this line */\n  paddingAfter = 10;\n\n  /**\n   * Sets the offset of this column and updates all associated cells.\n   * @param val The new offset value\n   */\n  setOffset(val: number): void {\n    this._coordOffset = val;\n    for (const cell of this.cells) {\n      if (cell.value) {\n        const cellView = this.getCellView(cell);\n        if (this._maxLength <= 0) {\n          // this hasnt been evaluated yet so do it!\n          this.evalMaxLength();\n        }\n        cellView.setBounds(val, null, this.maxLength, null, true);\n      }\n    }\n  }\n\n  /**\n   * Evaluates the maximum width required for this column.\n   * @param changedCells Cells that have changed and need re-evaluation\n   * @returns The maximum width\n   */\n  evalMaxLength(changedCells: GridCell[] = []): number {\n    this._maxLength = 0;\n    for (const cell of this.cells) {\n      if (cell.value) {\n        const cellView = this.getCellView(cell);\n        this._maxLength = Math.max(cellView.minSize.width, this._maxLength);\n      }\n    }\n    return this._maxLength;\n  }\n\n  /**\n   * Called before adding a cell to perform validation or preparation.\n   * @param cell The cell to be added\n   * @returns Whether the cell should be added\n   */\n  protected beforeAddingCell(cell: GridCell): boolean {\n    if (cell.colAlign && cell.colAlign != this) {\n      cell.colAlign.removeCell(cell);\n    }\n    return cell.colAlign != this;\n  }\n\n  /**\n   * Called before removing a cell to perform validation.\n   * @param cell The cell to be removed\n   * @returns Whether the cell should be removed\n   */\n  beforeRemovingCell(cell: GridCell): boolean {\n    return cell.colAlign == this;\n  }\n}\n\n/**\n * Manages the alignment of cells in a row.\n */\nexport class RowAlign extends AlignedLine {\n  /**\n   * Sets the Y coordinate of all cells in this row.\n   * @param val The new Y coordinate\n   */\n  setOffset(val: number): void {\n    this._coordOffset = val;\n    for (const cell of this.cells) {\n      if (cell.value) {\n        const cellView = this.getCellView(cell);\n        if (this._maxLength <= 0) {\n          // this hasnt been evaluated yet so do it!\n          this.evalMaxLength();\n        }\n        cellView.setBounds(null, val, null, this.maxLength, true);\n      }\n    }\n  }\n\n  /**\n   * Evaluates the maximum height required for this row.\n   * @param changedCells Cells that have changed and need re-evaluation\n   * @returns The maximum height\n   */\n  evalMaxLength(changedCells: GridCell[] = []): number {\n    this._maxLength = 0;\n    for (const cell of this.cells) {\n      if (cell.value) {\n        const cellView = this.getCellView(cell);\n        this._maxLength = Math.max(cellView.minSize.height, this._maxLength);\n      }\n    }\n    return this._maxLength;\n  }\n\n  /**\n   * Called before adding a cell to perform validation or preparation.\n   * @param cell The cell to be added\n   * @returns Whether the cell should be added\n   */\n  protected beforeAddingCell(cell: GridCell): boolean {\n    if (cell.rowAlign && cell.rowAlign != this) {\n      cell.rowAlign.removeCell(cell);\n    }\n    return cell.rowAlign != this;\n  }\n\n  /**\n   * Called before removing a cell to perform validation.\n   * @param cell The cell to be removed\n   * @returns Whether the cell should be removed\n   */\n  beforeRemovingCell(cell: GridCell): boolean {\n    return cell.rowAlign == this;\n  }\n}\n\n/**\n * The layout manager for a collection of GridViews bound by common alignment objects.\n * Manages the layout of multiple grid models, ensuring proper alignment between them.\n */\nexport class GridLayoutGroup {\n  // rowAligns = new Map<number, RowAlign>();\n  // colAligns = new Map<number, ColAlign>();\n  /** The grid models managed by this layout group */\n  gridModels = [] as GridModel[];\n\n  /** Subscribers to layout change events */\n  private layoutChangeSubscribers = new Set<LayoutChangeCallback>();\n\n  /** Previous column widths by ColAlign uuid - for detecting actual changes */\n  private previousColumnWidths = new Map<number, number>();\n\n  /** Previous row heights by RowAlign uuid - for detecting actual changes */\n  private previousRowHeights = new Map<number, number>();\n\n  /**\n   * Subscribes to layout change events.\n   * @param callback Function to call when layout changes\n   * @returns Unsubscribe function\n   */\n  onLayoutChange(callback: LayoutChangeCallback): () => void {\n    this.layoutChangeSubscribers.add(callback);\n    return () => {\n      this.layoutChangeSubscribers.delete(callback);\n    };\n  }\n\n  /**\n   * Notifies all subscribers of a layout change.\n   * @param event The layout change event\n   */\n  protected notifyLayoutChange(event: LayoutChangeEvent): void {\n    for (const callback of this.layoutChangeSubscribers) {\n      try {\n        callback(event);\n      } catch (e) {\n        console.error(\"Error in layout change callback:\", e);\n      }\n    }\n  }\n\n  /**\n   * Gets the number of layout change subscribers.\n   */\n  get subscriberCount(): number {\n    return this.layoutChangeSubscribers.size;\n  }\n\n  /**\n   * Event handler for processing events from grid models.\n   */\n  private eventHandler = (event: TSU.Events.TEvent) => {\n    this.applyModelEvents(event.payload);\n  };\n\n  /**\n   * Adds a grid model to this layout group.\n   * @param gridModel The grid model to add\n   * @returns True if the model was added successfully\n   */\n  addGridModel(gridModel: GridModel): boolean {\n    gridModel.eventHub?.on(TSU.Events.EventHub.BATCH_EVENTS, this.eventHandler);\n    this.gridModels.push(gridModel);\n    return true;\n  }\n\n  /**\n   * Gets all row alignment objects that have no predecessors.\n   * @returns An array of starting row alignments\n   */\n  startingRowAligns(): RowAlign[] {\n    const out = [] as RowAlign[];\n    const visited = {} as any;\n    for (const gm of this.gridModels) {\n      for (const cell of gm.cellsInRow(gm.firstRow)) {\n        if (cell.rowAlign && !visited[cell.rowAlign.uuid]) {\n          visited[cell.rowAlign.uuid] = true;\n          out.push(cell.rowAlign);\n        }\n      }\n    }\n    return out;\n  }\n\n  /**\n   * Gets all column alignment objects that have no predecessors.\n   * @returns An array of starting column alignments\n   */\n  startingColAligns(): ColAlign[] {\n    const out = [] as ColAlign[];\n    const visited = {} as any;\n    for (const gm of this.gridModels) {\n      for (const cell of gm.cellsInCol(gm.firstCol)) {\n        if (cell.colAlign && !visited[cell.colAlign.uuid]) {\n          visited[cell.colAlign.uuid] = true;\n          out.push(cell.colAlign);\n        }\n      }\n    }\n    return out;\n  }\n\n  /**\n   * Removes a grid model from this layout group.\n   * @param gridModel The grid model to remove\n   */\n  removeGridModel(gridModel: GridModel): void {\n    gridModel.eventHub?.removeOn(TSU.Events.EventHub.BATCH_EVENTS, this.eventHandler);\n  }\n\n  /**\n   * Function to get a view for a cell value.\n   */\n  getCellView: (cell: GridCell) => GridCellView;\n\n  /**\n   * Gets the starting row alignments.\n   */\n  get startingRows(): RowAlign[] {\n    return this.startingRowAligns();\n  }\n\n  /**\n   * Gets the starting column alignments.\n   */\n  get startingCols(): ColAlign[] {\n    return this.startingColAligns();\n  }\n\n  /**\n   * Forces a full refresh of the layout.\n   * This recalculates all row and column sizes and positions.\n   * @param notify Whether to notify subscribers of the change (default: true)\n   */\n  refreshLayout(notify = true): void {\n    const changedRowAligns = {} as any;\n    const changedColAligns = {} as any;\n\n    for (const rowAlign of this.startingRowAligns()) {\n      if (!(rowAlign.uuid in changedRowAligns)) {\n        changedRowAligns[rowAlign.uuid] = {\n          align: rowAlign,\n          cells: [],\n        };\n      }\n    }\n\n    for (const colAlign of this.startingColAligns()) {\n      if (!(colAlign.uuid in changedColAligns)) {\n        changedColAligns[colAlign.uuid] = {\n          align: colAlign,\n          cells: [],\n        };\n      }\n    }\n\n    // Pass the previous dimension maps for O(1) inline change detection\n    const rowHeightsChanged = this.doBfsLayout(this.startingRows, changedRowAligns, this.previousRowHeights);\n    const columnWidthsChanged = this.doBfsLayout(this.startingCols, changedColAligns, this.previousColumnWidths);\n\n    // Notify subscribers of full refresh\n    if (notify && this.layoutChangeSubscribers.size > 0) {\n      this.notifyLayoutChange({\n        affectedRowRange: null, // null means all rows\n        affectedColRange: null, // null means all columns\n        columnWidthsChanged,\n        rowHeightsChanged,\n        affectedGridModels: this.gridModels,\n      });\n    }\n  }\n\n  /**\n   * Applies model events to update the layout.\n   * @param events The events to process\n   */\n  protected applyModelEvents(events: TSU.Events.TEvent[]): void {\n    // As the grid model changes (cell content changed, cleared etc) we need\n    // to refresh our layout based on this.\n    // As a first step the new height and width of all changed cells is\n    // evaluted to see which rows and/or columns are affected (and need to be\n    // resized/repositioned).\n    const [changedRowAligns, changedColAligns, affectedGridModels] = this.changesForEvents(events);\n    const hadRowChanges = Object.keys(changedRowAligns).length > 0;\n    const hadColChanges = Object.keys(changedColAligns).length > 0;\n\n    // Pass the previous dimension maps for O(1) inline change detection\n    const rowHeightsChanged = this.doBfsLayout(this.startingRows, changedRowAligns, this.previousRowHeights);\n    const columnWidthsChanged = this.doBfsLayout(this.startingCols, changedColAligns, this.previousColumnWidths);\n\n    // Notify subscribers of incremental changes\n    if (this.layoutChangeSubscribers.size > 0 && (hadRowChanges || hadColChanges)) {\n      // Calculate affected ranges from the changed alignments\n      const affectedRowRange = this.calculateAffectedRowRange(changedRowAligns);\n      const affectedColRange = this.calculateAffectedColRange(changedColAligns);\n\n      this.notifyLayoutChange({\n        affectedRowRange,\n        affectedColRange,\n        columnWidthsChanged,\n        rowHeightsChanged,\n        affectedGridModels: affectedGridModels,\n      });\n    }\n  }\n\n  /**\n   * Calculates the range of affected rows from changed row alignments.\n   * Returns null if no rows changed or range cannot be determined.\n   */\n  protected calculateAffectedRowRange(changedRowAligns: any): { start: number; end: number } | null {\n    let minRow = Infinity;\n    let maxRow = -Infinity;\n\n    for (const alignId in changedRowAligns) {\n      const { cells } = changedRowAligns[alignId];\n      for (const cell of cells) {\n        const rowIndex = cell.gridRow.rowIndex;\n        minRow = Math.min(minRow, rowIndex);\n        maxRow = Math.max(maxRow, rowIndex);\n      }\n    }\n\n    if (minRow === Infinity) return null;\n    return { start: minRow, end: maxRow };\n  }\n\n  /**\n   * Calculates the range of affected columns from changed column alignments.\n   * Returns null if no columns changed or range cannot be determined.\n   */\n  protected calculateAffectedColRange(changedColAligns: any): { start: number; end: number } | null {\n    let minCol = Infinity;\n    let maxCol = -Infinity;\n\n    for (const alignId in changedColAligns) {\n      const { cells } = changedColAligns[alignId];\n      for (const cell of cells) {\n        const colIndex = cell.colIndex;\n        minCol = Math.min(minCol, colIndex);\n        maxCol = Math.max(maxCol, colIndex);\n      }\n    }\n\n    if (minCol === Infinity) return null;\n    return { start: minCol, end: maxCol };\n  }\n\n  /**\n   * Checks if an alignment's maxLength changed from previous value.\n   * Updates the stored previous value. O(1) cost.\n   * @param align The alignment to check\n   * @param previousMap Map storing previous lengths\n   * @returns true if length changed (or is new)\n   */\n  private checkAndUpdateLength<T extends AlignedLine>(align: T, previousMap: Map<number, number>): boolean {\n    const previous = previousMap.get(align.uuid);\n    const current = align.maxLength;\n    previousMap.set(align.uuid, current);\n    return previous === undefined || previous !== current;\n  }\n\n  /**\n   * Determines which rows and columns need to be updated based on events.\n   * @param events The events to process\n   * @returns A tuple containing the changed row alignments, column alignments, and affected grid models\n   */\n  protected changesForEvents(events: TSU.Events.TEvent[]): [any, any, GridModel[]] {\n    // Step 1 - topologically sort RowAligns of changed cells\n    // Step 2 - topologically sort ColAligns of changed cells\n    // Step 3 -\n    const cellVisited = {} as any;\n    const changedRowAligns = {} as any;\n    const changedColAligns = {} as any;\n    const affectedGridModelsSet = new Set<GridModel>();\n    // Going in reverse means we only get the latest event affecting a cell\n    // instead of going through every change.\n    // Later on we can revisit this if the events are edge triggered instead\n    // of level triggered\n    for (let i = events.length - 1; i >= 0; i--) {\n      const event = events[i];\n      const loc = event.payload.loc;\n      if (cellVisited[loc]) continue;\n      cellVisited[loc] = true;\n      const [row, col] = loc.split(\":\").map((x: string) => parseInt(x));\n      const gridModel = event.source as GridModel;\n      affectedGridModelsSet.add(gridModel);\n      const cell = gridModel.getRow(row).cellAt(col);\n      if (cell) {\n        // TODO - For now we are marking both row and col as having\n        // changed for a cell.  We can optimize this to only row or\n        // col based on whether height or width has changed.\n        if (!(cell.rowAlign.uuid in changedRowAligns)) {\n          changedRowAligns[cell.rowAlign.uuid] = {\n            align: cell.rowAlign,\n            cells: [],\n          };\n        }\n        changedRowAligns[cell.rowAlign.uuid][\"cells\"].push(cell);\n\n        if (!(cell.colAlign.uuid in changedColAligns)) {\n          changedColAligns[cell.colAlign.uuid] = {\n            align: cell.colAlign,\n            cells: [],\n          };\n        }\n        changedColAligns[cell.colAlign.uuid][\"cells\"].push(cell);\n      }\n    }\n    return [changedRowAligns, changedColAligns, Array.from(affectedGridModelsSet)];\n  }\n\n  /**\n   * Ensures that a cell view getter function is available for an alignment.\n   * @param align The alignment to check\n   * @returns The cell view getter function\n   */\n  protected ensureGetCellView(align: AlignedLine) {\n    if (!align.getCellView) {\n      if (!this.getCellView) {\n        return null;\n      }\n      align.getCellView = this.getCellView;\n    }\n    return align.getCellView;\n  }\n\n  /**\n   * Performs a breadth-first layout of aligned lines.\n   * @param startingLines The lines to start from\n   * @param changedAligns Map of alignment IDs to changed alignments\n   * @param previousLengths Map to track previous lengths for change detection\n   * @returns true if any dimension (width/height) actually changed\n   */\n  protected doBfsLayout<T extends AlignedLine>(\n    startingLines: T[],\n    changedAligns: any,\n    previousLengths?: Map<number, number>,\n  ): boolean {\n    // 1. start from the starting lines and do a BF traversal\n    // 2. If a line not visited (ie laid out):\n    //      if it is in the changedAlign list then reval its length (w/h)\n    //      set its offset and length if either width or offset has changed\n    //      offset can be thought of changed if the preceding line's offset has changed\n    // first do above for rows\n    if (!this.getCellView) return false;\n    let anyDimensionChanged = false;\n\n    for (const alignId in changedAligns) {\n      const val = changedAligns[alignId];\n      this.ensureGetCellView(val.align);\n      val.align.evalMaxLength(val.cells);\n\n      // Check if this alignment's length actually changed (O(1))\n      if (previousLengths && this.checkAndUpdateLength(val.align, previousLengths)) {\n        anyDimensionChanged = true;\n      }\n    }\n\n    let lineQueue = [] as [null | T, T][];\n    const visitedLines = {} as any;\n    for (const line of startingLines) lineQueue.push([null, line]);\n    const lineOffsetChanged = {} as any;\n    while (lineQueue.length > 0) {\n      const nextQueue = [] as [null | T, T][];\n      for (let i = 0; i < lineQueue.length; i++) {\n        const [prevLineAlign, lineAlign] = lineQueue[i];\n        visitedLines[lineAlign.uuid] = true;\n        let newOffset = lineAlign.coordOffset;\n        let lineChanged = lineAlign.uuid in changedAligns;\n        if (prevLineAlign) {\n          if (lineOffsetChanged[prevLineAlign.uuid]) {\n            newOffset = prevLineAlign.coordOffset + prevLineAlign.maxLength;\n            lineChanged = true;\n          }\n        }\n        if (lineChanged) {\n          this.ensureGetCellView(lineAlign);\n          lineAlign.setOffset(newOffset);\n          lineOffsetChanged[lineAlign.uuid] = true;\n        }\n\n        // Add next neighbors now\n        for (const next of lineAlign.nextLines) {\n          if (!visitedLines[next.uuid]) {\n            nextQueue.push([lineAlign, next]);\n          }\n        }\n      }\n      lineQueue = nextQueue;\n    }\n\n    return anyDimensionChanged;\n  }\n}\n","import * as TSU from \"@panyam/tsutils\";\nimport { Entity } from \"./entity\";\nimport { Cycle } from \"./cycle\";\nimport { Line } from \"./core\";\nimport { LayoutParams } from \"./layouts\";\nimport { BlockObserver } from \"./events\";\n\n/**\n * Definition of a role in a block context.\n * This is used for block-scoped role definitions.\n */\nexport class RoleDef {\n  /** Name of the role */\n  name = \"\";\n\n  /** Whether this role contains only notes (true) or can also contain syllables/text (false) */\n  notesOnly = false;\n\n  /** Index of this role in the notation */\n  index = 0;\n}\n\n/**\n * Represents a raw block of content in the notation.\n * Raw blocks can contain arbitrary content like markdown, HTML, etc.\n */\nexport class RawBlock extends Entity {\n  readonly TYPE: string = \"RawBlock\";\n\n  /**\n   * Creates a new RawBlock.\n   * @param content The content of the block\n   * @param contentType The type of content (e.g., \"md\" for markdown)\n   */\n  constructor(\n    public content: string,\n    public contentType: string = \"md\",\n  ) {\n    super();\n  }\n\n  /**\n   * Returns a debug-friendly representation of this raw block.\n   * @returns An object containing debug information\n   */\n  debugValue(): any {\n    return { ...super.debugValue(), content: this.content, contentType: this.contentType };\n  }\n}\n\n/**\n * Union type for items that can appear in a block.\n */\nexport type BlockItem = Block | Line | RawBlock;\n\n/**\n * Type guard to check if an entity is a Block.\n */\nexport function isBlock(item: BlockItem): item is Block {\n  return item.TYPE === \"Block\";\n}\n\n/**\n * Type guard to check if an entity is a Line.\n */\nexport function isLine(item: BlockItem): item is Line {\n  return item.TYPE === \"Line\";\n}\n\n/**\n * Type guard to check if an entity is a RawBlock.\n */\nexport function isRawBlock(item: BlockItem): item is RawBlock {\n  return item.TYPE === \"RawBlock\";\n}\n\n/**\n * Represents a scoped block created by a command with braces.\n * For example: \\section(\"Pallavi\") { ... }\n *\n * Blocks inherit properties from their parent Block and can override them locally.\n * Properties are resolved lazily by walking up the tree.\n *\n * Block = Command + Children (unified model)\n */\nexport class Block extends Entity {\n  readonly TYPE: string = \"Block\";\n\n  /** The type of block (e.g., \"section\", \"repeat\", \"cycle\") */\n  readonly blockType: string;\n\n  /** Optional name for the block (e.g., section name) */\n  readonly name: TSU.Nullable<string>;\n\n  /** Child items (before expansion by subclasses) */\n  readonly blockItems: BlockItem[] = [];\n\n  // Local properties\n  localCycle: TSU.Nullable<Cycle> = null;\n  localAtomsPerBeat: TSU.Nullable<number> = null;\n  localBreaks: TSU.Nullable<number[]> = null;\n  readonly localRoles = new Map<string, RoleDef>();\n\n  // Store parent reference (Block or null for root)\n  private _parentBlock: TSU.Nullable<Block> = null;\n\n  // State tracking for command application (protected for Notation override)\n  protected _currRoleDef: TSU.Nullable<RoleDef> = null;\n  protected _currentLine: TSU.Nullable<Line> = null;\n\n  /**\n   * Observers that receive notifications when block items change.\n   */\n  private _observers: BlockObserver<BlockItem, Block>[] = [];\n\n  /**\n   * Creates a new Block.\n   * @param blockType The type of block (e.g., \"section\", \"group\")\n   * @param parent The parent block (null for root)\n   * @param name Optional name for the block\n   */\n  constructor(blockType: string, parent: TSU.Nullable<Block> = null, name: TSU.Nullable<string> = null) {\n    super();\n    this.blockType = blockType;\n    this.name = name;\n    this._parentBlock = parent;\n    // Also set Entity's parent for tree traversal\n    if (parent) {\n      this.setParent(parent);\n    }\n  }\n\n  /**\n   * Adds an observer to receive block item change notifications.\n   * @param observer The observer to add\n   * @returns A function to remove the observer\n   */\n  addObserver(observer: BlockObserver<BlockItem, Block>): () => void {\n    this._observers.push(observer);\n    return () => this.removeObserver(observer);\n  }\n\n  /**\n   * Removes an observer.\n   * @param observer The observer to remove\n   */\n  removeObserver(observer: BlockObserver<BlockItem, Block>): void {\n    const index = this._observers.indexOf(observer);\n    if (index >= 0) {\n      this._observers.splice(index, 1);\n    }\n  }\n\n  /**\n   * Returns the expanded children for layout iteration.\n   * Subclasses can override this to transform children (e.g., Repeat, Section).\n   */\n  children(): BlockItem[] {\n    return this.blockItems;\n  }\n\n  /**\n   * Gets the parent block.\n   */\n  get parentBlock(): TSU.Nullable<Block> {\n    return this._parentBlock;\n  }\n\n  // ============================================\n  // Property inheritance via tree walking\n  // ============================================\n\n  /**\n   * Gets the effective cycle by walking up the tree.\n   */\n  get cycle(): TSU.Nullable<Cycle> {\n    if (this.localCycle !== null) {\n      return this.localCycle;\n    }\n    return this.parentBlock?.cycle ?? null;\n  }\n\n  /**\n   * Gets the effective atoms per beat by walking up the tree.\n   * Defaults to 1 if not set anywhere in the tree.\n   */\n  get atomsPerBeat(): number {\n    if (this.localAtomsPerBeat !== null) {\n      return this.localAtomsPerBeat;\n    }\n    return this.parentBlock?.atomsPerBeat ?? 1;\n  }\n\n  /**\n   * Gets the effective line breaks by walking up the tree.\n   * Defaults to empty array if not set anywhere.\n   */\n  get breaks(): number[] {\n    if (this.localBreaks !== null) {\n      return this.localBreaks;\n    }\n    return this.parentBlock?.breaks ?? [];\n  }\n\n  // ============================================\n  // Layout parameters management\n  // ============================================\n\n  /** Layout parameters caching for this block scope */\n  private _unnamedLayoutParams: LayoutParams[] = [];\n  private _namedLayoutParams = new Map<string, LayoutParams>();\n  private _layoutParams: LayoutParams | null = null;\n\n  /**\n   * Gets the unnamed layout parameters for this block.\n   */\n  get unnamedLayoutParams(): ReadonlyArray<LayoutParams> {\n    return this._unnamedLayoutParams;\n  }\n\n  /**\n   * Gets the named layout parameters for this block.\n   */\n  get namedLayoutParams(): ReadonlyMap<string, LayoutParams> {\n    return this._namedLayoutParams;\n  }\n\n  /**\n   * Gets the current layout parameters for this block scope.\n   * Uses the effective cycle, atomsPerBeat, and breaks from tree walking.\n   * Creates or finds a matching LayoutParams if needed.\n   */\n  get layoutParams(): LayoutParams {\n    if (this._layoutParams == null) {\n      // Find or create layout params matching current effective values\n      this._layoutParams = this.findUnnamedLayoutParams();\n      if (this._layoutParams == null) {\n        this._layoutParams = this.snapshotLayoutParams();\n        this._unnamedLayoutParams.push(this._layoutParams);\n      }\n    }\n    return this._layoutParams;\n  }\n\n  /**\n   * Resets the current layout parameters to null.\n   * Called when layout-affecting properties change.\n   */\n  resetLayoutParams(): void {\n    this._layoutParams = null;\n    this.resetLine();\n  }\n\n  /**\n   * Creates a snapshot of the current layout parameters.\n   * @returns A new LayoutParams object with the current effective settings\n   */\n  protected snapshotLayoutParams(): LayoutParams {\n    const effectiveCycle = this.cycle;\n    if (effectiveCycle == null) {\n      throw new Error(\"Cannot create layout params: no cycle defined\");\n    }\n    return new LayoutParams({\n      cycle: effectiveCycle,\n      beatDuration: this.atomsPerBeat,\n      layout: this.breaks,\n    });\n  }\n\n  /**\n   * Finds an unnamed layout parameters object that matches the current effective settings.\n   * @returns Matching layout parameters, or null if none found\n   */\n  protected findUnnamedLayoutParams(): LayoutParams | null {\n    const effectiveCycle = this.cycle;\n    if (effectiveCycle == null) return null;\n\n    return (\n      this._unnamedLayoutParams.find((lp) => {\n        return (\n          lp.beatDuration == this.atomsPerBeat && effectiveCycle.equals(lp.cycle) && lp.lineBreaksEqual(this.breaks)\n        );\n      }) || null\n    );\n  }\n\n  /**\n   * Ensures that named layout parameters with the given name exist.\n   * @param name The name of the layout parameters\n   * @returns The layout parameters\n   */\n  ensureNamedLayoutParams(name: string): LayoutParams {\n    let lp = this._namedLayoutParams.get(name) || null;\n    if (lp == null || this._layoutParams != lp) {\n      if (lp == null) {\n        // Create new named layout params\n        lp = this.snapshotLayoutParams();\n        this._namedLayoutParams.set(name, lp);\n      } else {\n        // Copy named LPs attributes into our locals\n        this.localCycle = lp.cycle;\n        this.localAtomsPerBeat = lp.beatDuration;\n        this.localBreaks = lp.lineBreaks;\n      }\n      this._layoutParams = lp;\n      this.resetLine();\n    }\n    return this._layoutParams!;\n  }\n\n  /**\n   * Gets a role definition by name, walking up the tree if not found locally.\n   * @param name The name of the role\n   */\n  getRole(name: string): TSU.Nullable<RoleDef> {\n    const local = this.localRoles.get(name.toLowerCase());\n    if (local) {\n      return local;\n    }\n    return this.parentBlock?.getRole(name) ?? null;\n  }\n\n  // ============================================\n  // State tracking for command application\n  // ============================================\n\n  /**\n   * Gets the current role definition.\n   * Falls back to parent's current role or the last defined role.\n   */\n  get currRoleDef(): TSU.Nullable<RoleDef> {\n    if (this._currRoleDef !== null) {\n      return this._currRoleDef;\n    }\n    // Fall back to parent's current role\n    if (this.parentBlock) {\n      return this.parentBlock.currRoleDef;\n    }\n    // Or use the last locally defined role\n    const roles = Array.from(this.localRoles.values());\n    return roles.length > 0 ? roles[roles.length - 1] : null;\n  }\n\n  /**\n   * Sets the current role by name.\n   * If the role doesn't exist, tries to create it via the root container's onMissingRole.\n   * @param name The name of the role to activate\n   * @throws Error if the role is not found and cannot be created\n   */\n  setCurrRole(name: string): void {\n    name = name.trim().toLowerCase();\n    if (name === \"\") {\n      throw new Error(\"Role name cannot be empty\");\n    }\n    let roleDef = this.getRole(name);\n    // If role not found, try auto-creation\n    if (roleDef == null) {\n      // Create the role locally in this block\n      // Default: \"sw\" is notes-only, others are not\n      roleDef = this.newRoleDef(name, name === \"sw\");\n    }\n    this._currRoleDef = roleDef;\n  }\n\n  /**\n   * Gets the current line, creating one if needed.\n   */\n  get currentLine(): Line {\n    if (this._currentLine === null) {\n      return this.newLine();\n    }\n    return this._currentLine;\n  }\n\n  /**\n   * Creates a new line in this block.\n   */\n  newLine(): Line {\n    if (this._currentLine !== null && this._currentLine.isEmpty) {\n      // Remove empty line before creating new one\n      this.removeBlockItem(this._currentLine);\n    }\n    this._currentLine = new Line();\n    this.addBlockItem(this._currentLine);\n    return this._currentLine;\n  }\n\n  /**\n   * Resets the current line pointer to null.\n   * Called when layout parameters change to force a new line.\n   */\n  resetLine(): void {\n    this._currentLine = null;\n  }\n\n  /**\n   * Creates a new role definition local to this block.\n   * @param name The name of the role\n   * @param notesOnly Whether this role contains only notes\n   */\n  newRoleDef(name: string, notesOnly = false): RoleDef {\n    name = name.trim().toLowerCase();\n    if (name === \"\") {\n      throw new Error(\"Role name cannot be empty\");\n    }\n    if (this.localRoles.has(name)) {\n      throw new Error(`Role '${name}' already exists in this block`);\n    }\n    const rd = new RoleDef();\n    rd.name = name;\n    rd.notesOnly = notesOnly;\n    rd.index = this.localRoles.size;\n    this.localRoles.set(name, rd);\n    return rd;\n  }\n\n  // ============================================\n  // Child management\n  // ============================================\n\n  /**\n   * Adds a child item to this block.\n   * @param item The item to add\n   */\n  addBlockItem(item: BlockItem): void {\n    const index = this.blockItems.length;\n    item.setParent(this);\n    this.blockItems.push(item);\n\n    // Notify observers of added item\n    if (this._eventsEnabled) {\n      for (const observer of this._observers) {\n        observer.onItemAdded?.(this, item, index);\n      }\n    }\n  }\n\n  /**\n   * Removes a child item from this block.\n   * @param item The item to remove\n   * @returns The index of the removed item, or -1 if not found\n   */\n  removeBlockItem(item: BlockItem): number {\n    const index = this.blockItems.indexOf(item);\n    if (index >= 0) {\n      this.blockItems.splice(index, 1);\n      item.setParent(null);\n\n      // Notify observers of removed item\n      if (this._eventsEnabled) {\n        for (const observer of this._observers) {\n          observer.onItemRemoved?.(this, item, index);\n        }\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Returns a debug-friendly representation of this block.\n   */\n  debugValue(): any {\n    const out: any = {\n      ...super.debugValue(),\n      blockType: this.blockType,\n      blockItems: this.blockItems.map((c) => c.debugValue()),\n    };\n    if (this.name) {\n      out.name = this.name;\n    }\n    if (this.localCycle) {\n      out.localCycle = this.localCycle.uuid;\n    }\n    if (this.localAtomsPerBeat !== null) {\n      out.localAtomsPerBeat = this.localAtomsPerBeat;\n    }\n    if (this.localBreaks !== null) {\n      out.localBreaks = this.localBreaks;\n    }\n    if (this.localRoles.size > 0) {\n      out.localRoles = Array.from(this.localRoles.keys());\n    }\n    return out;\n  }\n}\n\n/**\n * Helper function to find the containing block of an entity by walking up the tree.\n * @param entity The entity to start from\n * @returns The containing Block, or null if not found\n */\nexport function findContainingBlock(entity: Entity): TSU.Nullable<Block> {\n  let current: TSU.Nullable<Entity> = entity.parent;\n  while (current !== null) {\n    if (current instanceof Block) {\n      return current;\n    }\n    current = current.parent;\n  }\n  return null;\n}\n\n// ============================================\n// Block Subclasses\n// ============================================\n\n/**\n * A section block with a heading.\n * Expands children to include a heading RawBlock followed by the content.\n *\n * Usage: \\section(\"Pallavi\") { ... }\n */\nexport class SectionBlock extends Block {\n  constructor(sectionName: string, parent: TSU.Nullable<Block> = null) {\n    super(\"section\", parent, sectionName);\n  }\n\n  /**\n   * Expands children to include a heading RawBlock.\n   */\n  children(): BlockItem[] {\n    const heading = new RawBlock(`# ${this.name}`, \"md\");\n    return [heading, ...this.blockItems];\n  }\n}\n\n/**\n * A repeat block that expands its children N times.\n *\n * Usage: \\repeat(2) { ... }\n */\nexport class RepeatBlock extends Block {\n  /** Number of times to repeat (0 = visual markers only) */\n  readonly repeatCount: number;\n\n  constructor(repeatCount: number, parent: TSU.Nullable<Block> = null) {\n    super(\"repeat\", parent);\n    this.repeatCount = repeatCount;\n  }\n\n  /**\n   * Expands children by repeating them N times.\n   * If count is 0, returns children as-is (visual repeat markers only).\n   */\n  children(): BlockItem[] {\n    if (this.repeatCount <= 0) {\n      return this.blockItems;\n    }\n    const expanded: BlockItem[] = [];\n    for (let i = 0; i < this.repeatCount; i++) {\n      expanded.push(...this.blockItems);\n    }\n    return expanded;\n  }\n}\n\n/**\n * A cycle block that sets localCycle for scoped notation.\n *\n * Usage: \\cycle(\"|4|4|\") { ... }\n */\nexport class CycleBlock extends Block {\n  constructor(cycle: Cycle, parent: TSU.Nullable<Block> = null) {\n    super(\"cycle\", parent);\n    this.localCycle = cycle;\n  }\n}\n\n/**\n * A beat duration block that sets localAtomsPerBeat for scoped notation.\n *\n * Usage: \\beatDuration(2) { ... }\n */\nexport class BeatDurationBlock extends Block {\n  constructor(atomsPerBeat: number, parent: TSU.Nullable<Block> = null) {\n    super(\"beatduration\", parent);\n    this.localAtomsPerBeat = atomsPerBeat;\n  }\n}\n\n/**\n * A breaks block that sets localBreaks for scoped notation.\n *\n * Usage: \\breaks(4, 2, 2) { ... }\n */\nexport class BreaksBlock extends Block {\n  constructor(breaks: number[], parent: TSU.Nullable<Block> = null) {\n    super(\"breaks\", parent);\n    this.localBreaks = breaks;\n  }\n}\n\n/**\n * A role block that creates a local role definition.\n *\n * Usage: \\role(\"Vocals\", notes=false) { ... }\n */\nexport class RoleBlock extends Block {\n  constructor(roleName: string, notesOnly: boolean, parent: TSU.Nullable<Block> = null) {\n    super(\"role\", parent);\n    // Create the role locally\n    this.newRoleDef(roleName, notesOnly);\n  }\n}\n\n/**\n * A group block for organizing notation without special semantics.\n *\n * Usage: \\group(\"optional-name\") { ... }\n */\nexport class GroupBlock extends Block {\n  constructor(groupName: string | null, parent: TSU.Nullable<Block> = null) {\n    super(\"group\", parent, groupName);\n  }\n}\n","import { load } from \"../../loader\";\nimport { NotationView } from \"../../carnatic\";\n\nexport interface NotationBlockConfig {\n  /** Function to create a notation viewer - allows different implementations */\n  createViewer: (container: HTMLDivElement) => NotationView;\n\n  /** CSS classes to apply to various elements */\n  cssClasses?: {\n    root?: string;\n    sourceContainer?: string;\n    sourceCaption?: string;\n    sourceCode?: string;\n    outputLabel?: string;\n    outputContainer?: string;\n  };\n}\n\nexport default class NotationBlock {\n  id: string;\n  source: string;\n  caption = \"\";\n  height: string;\n  newRoot: HTMLDivElement;\n  notationView: NotationView;\n  showSource: boolean;\n  isEditing = false;\n  editTextarea: HTMLTextAreaElement | null = null;\n  sourceCodeElement: HTMLElement | null = null;\n\n  constructor(\n    public readonly container: HTMLElement,\n    public readonly config: NotationBlockConfig,\n  ) {\n    this.id = (container.getAttribute(\"id\") || \"\").trim();\n    this.caption = (container.getAttribute(\"caption\") || \"\").trim();\n    const sourceFrom = (container.getAttribute(\"sourceFrom\") || \"\").trim();\n    this.source = container.textContent || \"\";\n\n    if (sourceFrom.length > 0) {\n      const sourceElem = document.getElementById(sourceFrom);\n      if (sourceElem) {\n        this.source = sourceElem.textContent || \"\";\n      }\n    }\n\n    this.height = container.getAttribute(\"height\") || \"\";\n    this.showSource = (container.getAttribute(\"showSource\") || \"false\") == \"true\";\n\n    const parent = container.parentNode as HTMLDivElement;\n    const newRoot = document.createElement(\"div\");\n    newRoot.classList.add(\"notationBlockRoot\");\n    if (config.cssClasses?.root) {\n      newRoot.className += \" \" + config.cssClasses.root;\n    }\n    this.newRoot = newRoot;\n\n    // Build HTML structure\n    let html = \"\";\n\n    // Add source code section if showSource is true\n    if (this.showSource) {\n      const sourceLines = this.source.split(\"\\n\");\n      const sourceClass = config.cssClasses?.sourceContainer || \"\";\n      const captionClass = config.cssClasses?.sourceCaption || \"\";\n      const codeClass = config.cssClasses?.sourceCode || \"\";\n\n      html += `\n        <figure class=\"notation-source-block ${sourceClass}\">\n          <div class=\"notation-source-header\">\n            <figcaption class=\"notation-caption ${captionClass}\">${this.caption}</figcaption>\n            <div class=\"notation-source-actions\">\n              <button class=\"notation-btn notation-copy-btn\" id=\"copyBtn_${this.id}\" title=\"Copy to clipboard\">\n                <svg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"currentColor\">\n                  <path d=\"M4 2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V2zm2-1a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H6zM2 5a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1v-1h1v1a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h1v1H2z\"/>\n                </svg>\n                <span class=\"notation-btn-text\">Copy</span>\n              </button>\n              <button class=\"notation-btn notation-edit-btn\" id=\"editBtn_${this.id}\" title=\"Edit notation\">\n                <svg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"currentColor\">\n                  <path d=\"M12.146.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1 0 .708l-10 10a.5.5 0 0 1-.168.11l-5 2a.5.5 0 0 1-.65-.65l2-5a.5.5 0 0 1 .11-.168l10-10zM11.207 2.5 13.5 4.793 14.793 3.5 12.5 1.207 11.207 2.5zm1.586 3L10.5 3.207 4 9.707V10h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.293l6.5-6.5zm-9.761 5.175-.106.106-1.528 3.821 3.821-1.528.106-.106A.5.5 0 0 1 5 12.5V12h-.5a.5.5 0 0 1-.5-.5V11h-.5a.5.5 0 0 1-.468-.325z\"/>\n                </svg>\n                <span class=\"notation-btn-text\">Edit</span>\n              </button>\n            </div>\n          </div>\n          <div class=\"notation-source\" id=\"notationSource_${this.id}\">\n            <pre class=\"notation-source-pre\">\n              <code class=\"${codeClass}\" id=\"sourceCode_${this.id}\">${sourceLines.map((x) => `<span>${x}</span>`).join(\"\\n\")}</code>\n            </pre>\n            <textarea class=\"notation-edit-textarea\" id=\"editTextarea_${this.id}\" style=\"display: none;\"></textarea>\n          </div>\n          <div class=\"notation-edit-actions\" id=\"editActions_${this.id}\" style=\"display: none;\">\n            <button class=\"notation-btn notation-apply-btn\" id=\"applyBtn_${this.id}\">Apply</button>\n            <button class=\"notation-btn notation-cancel-btn\" id=\"cancelBtn_${this.id}\">Cancel</button>\n          </div>\n        </figure>`;\n    }\n\n    // Add output section\n    const outputLabelClass = config.cssClasses?.outputLabel || \"\";\n    const outputClass = config.cssClasses?.outputContainer || \"\";\n\n    html += `\n      <div class=\"notation-output\">\n        <span class=\"notation-output-label ${outputLabelClass}\"><strong>Output:</strong></span>\n        <div id=\"notationViewer_${this.id}\" class=\"notation-view ${outputClass}\">\n        </div>\n      </div>`;\n\n    newRoot.innerHTML = html;\n    parent.insertBefore(newRoot, container);\n    parent.removeChild(container);\n\n    const notationViewerBlock = newRoot.querySelector(\".notation-view\") as HTMLDivElement;\n    this.notationView = config.createViewer(notationViewerBlock);\n\n    // Set up event handlers\n    if (this.showSource) {\n      this.sourceCodeElement = newRoot.querySelector(`#sourceCode_${this.id}`);\n      this.editTextarea = newRoot.querySelector(`#editTextarea_${this.id}`);\n\n      // Copy button\n      const copyBtn = newRoot.querySelector(`#copyBtn_${this.id}`);\n      if (copyBtn) {\n        copyBtn.addEventListener(\"click\", () => this.copyToClipboard());\n      }\n\n      // Edit button\n      const editBtn = newRoot.querySelector(`#editBtn_${this.id}`);\n      if (editBtn) {\n        editBtn.addEventListener(\"click\", () => this.toggleEditMode());\n      }\n\n      // Apply button\n      const applyBtn = newRoot.querySelector(`#applyBtn_${this.id}`);\n      if (applyBtn) {\n        applyBtn.addEventListener(\"click\", () => this.applyEdit());\n      }\n\n      // Cancel button\n      const cancelBtn = newRoot.querySelector(`#cancelBtn_${this.id}`);\n      if (cancelBtn) {\n        cancelBtn.addEventListener(\"click\", () => this.cancelEdit());\n      }\n    }\n\n    this.updatePreview();\n    console.log(\"Done Rendering... Adjusting height\");\n  }\n\n  updatePreview(): void {\n    const fullContents = this.source;\n    // Clear previous render to avoid appending multiple times\n    this.notationView.tableElement.innerHTML = \"\";\n\n    const [notation, beatLayout, errors, timings] = load(fullContents, { log: true });\n\n    if (errors.length > 0) {\n      console.log(\"Errors: \", errors);\n    } else {\n      console.log(\"Rendering notation...\");\n      this.notationView.renderNotation(notation, beatLayout);\n    }\n\n    const msg = `Document parsed (${Math.trunc(timings.parseTime * 100) / 100} ms) and built (${\n      Math.trunc(timings.buildTime * 100) / 100\n    } ms)`;\n    console.log(msg);\n  }\n\n  get captionId(): string {\n    return \"notationCaption_\" + this.id;\n  }\n\n  async copyToClipboard(): Promise<void> {\n    try {\n      await navigator.clipboard.writeText(this.source);\n      const copyBtn = this.newRoot.querySelector(`#copyBtn_${this.id}`);\n      if (copyBtn) {\n        const btnText = copyBtn.querySelector(\".notation-btn-text\");\n        const originalText = btnText?.textContent;\n        if (btnText) {\n          btnText.textContent = \"Copied!\";\n          setTimeout(() => {\n            if (btnText) btnText.textContent = originalText || \"Copy\";\n          }, 2000);\n        }\n      }\n    } catch (err) {\n      console.error(\"Failed to copy to clipboard:\", err);\n      alert(\"Failed to copy to clipboard\");\n    }\n  }\n\n  toggleEditMode(): void {\n    this.isEditing = !this.isEditing;\n\n    if (this.isEditing) {\n      this.enterEditMode();\n    } else {\n      this.exitEditMode();\n    }\n  }\n\n  enterEditMode(): void {\n    if (!this.editTextarea || !this.sourceCodeElement) return;\n\n    // Populate textarea with current source\n    this.editTextarea.value = this.source;\n\n    // Hide source code, show textarea\n    if (this.sourceCodeElement.parentElement) {\n      this.sourceCodeElement.parentElement.style.display = \"none\";\n    }\n    this.editTextarea.style.display = \"block\";\n\n    // Auto-resize textarea to fit content\n    this.editTextarea.style.height = \"auto\";\n    this.editTextarea.style.height = this.editTextarea.scrollHeight + \"px\";\n\n    // Show edit actions\n    const editActions = this.newRoot.querySelector(`#editActions_${this.id}`) as HTMLElement;\n    if (editActions) {\n      editActions.style.display = \"flex\";\n    }\n\n    // Update edit button text\n    const editBtn = this.newRoot.querySelector(`#editBtn_${this.id}`);\n    const btnText = editBtn?.querySelector(\".notation-btn-text\");\n    if (btnText) {\n      btnText.textContent = \"Editing...\";\n    }\n\n    this.editTextarea.focus();\n  }\n\n  exitEditMode(): void {\n    if (!this.editTextarea || !this.sourceCodeElement) return;\n\n    // Hide textarea, show source code\n    this.editTextarea.style.display = \"none\";\n    if (this.sourceCodeElement.parentElement) {\n      this.sourceCodeElement.parentElement.style.display = \"block\";\n    }\n\n    // Hide edit actions\n    const editActions = this.newRoot.querySelector(`#editActions_${this.id}`) as HTMLElement;\n    if (editActions) {\n      editActions.style.display = \"none\";\n    }\n\n    // Update edit button text\n    const editBtn = this.newRoot.querySelector(`#editBtn_${this.id}`);\n    const btnText = editBtn?.querySelector(\".notation-btn-text\");\n    if (btnText) {\n      btnText.textContent = \"Edit\";\n    }\n  }\n\n  applyEdit(): void {\n    if (!this.editTextarea) return;\n\n    // Update source\n    this.source = this.editTextarea.value;\n\n    // Update source code display\n    if (this.sourceCodeElement) {\n      const sourceLines = this.source.split(\"\\n\");\n      this.sourceCodeElement.innerHTML = sourceLines.map((x) => `<span>${x}</span>`).join(\"\\n\");\n    }\n\n    // Re-render notation\n    this.updatePreview();\n\n    // Exit edit mode\n    this.isEditing = false;\n    this.exitEditMode();\n  }\n\n  cancelEdit(): void {\n    // Simply exit edit mode without applying changes\n    this.isEditing = false;\n    this.exitEditMode();\n  }\n}\n","import { load } from \"../../src/loader\";\nimport { NotationView } from \"../../src/carnatic\";\nconst MarkdownIt = require(\"markdown-it\");\n\n/**\n * Creates a markdown parser function using markdown-it.\n */\nexport function createMarkdownParser(): (contents: string) => string {\n  const md = new MarkdownIt({\n    html: true,\n  });\n  return (contents: string) => {\n    const tokens = md.parse(contents.trim(), {});\n    return md.renderer.render(tokens, { langPrefix: \"v4_\" });\n  };\n}\n\nexport function createViewer(rootElement: HTMLElement): NotationView {\n  const notationView = new NotationView(rootElement); // , {debugEagerPositioning: true});\n  notationView.markdownParser = createMarkdownParser();\n  return notationView;\n}\n\nexport function initViewerDiv(elemSelector: string, codeSelector: string): NotationView | null {\n  const elem = document.querySelector(elemSelector) as HTMLDivElement;\n  const codeElem = document.querySelector(codeSelector) || null;\n  if (codeElem != null && codeElem.textContent != null && codeElem.textContent.trim() != \"\") {\n    // const contents = JSON.parse(codeElem.textContent);\n    let contents = codeElem.textContent;\n    try {\n      contents = JSON.parse(codeElem.textContent).main || \"\";\n    } catch (e) {\n      console.log(\"Content is plain string: \", e);\n    }\n    const [notation, beatLayout, errors] = load(contents, { log: true });\n    if (errors.length > 0) {\n      console.log(\"Errors: \", errors);\n    } else {\n      const notationView = createViewer(elem);\n      console.log(\"Rendering notation...\");\n      notationView.renderNotation(notation, beatLayout);\n      return notationView;\n    }\n  }\n  return null;\n}\n\n","import { NotationBlock, NotationBlockConfig } from \"../../src/web\";\nimport * as N from \"../../src\";\nimport * as NV from \"./NotationViewer\";\n\n// Import core notation styles (CSS variables for theming)\nimport \"../../styles/NotationView.scss\";\n\n// Expose notations library globally for integration demos\n(window as any).N = N;\n\nclass DocsPage {\n  notations: NotationBlock[] = [];\n\n  constructor() {\n    // Configure for docs site styling\n    const config: NotationBlockConfig = {\n      createViewer: NV.createViewer,\n      cssClasses: {\n        // Docs site uses these CSS classes (defined in main.css)\n        sourceContainer: \"\",\n        sourceCaption: \"\",\n        sourceCode: \"\",\n        outputContainer: \"\",\n      }\n    };\n\n    // Find and process all <notation> tags\n    const genIds = {} as any;\n    let genCounter = 1;\n    const notations = document.querySelectorAll(\"notation\");\n\n    for (const container of notations) {\n      let id = (container.getAttribute(\"id\") || \"\").trim();\n      if (id.length == 0) {\n        while (true) {\n          id = \"notation_\" + genCounter++;\n          if (!genIds[id] || null) {\n            break;\n          }\n        }\n      }\n      container.setAttribute(\"id\", id);\n      const block = new NotationBlock(container as HTMLElement, config);\n      this.notations.push(block);\n      console.log(\"Source: \", id, container.textContent);\n    }\n  }\n}\n\ndocument.addEventListener(\"DOMContentLoaded\", function() {\n  (window as any).docsPage = new DocsPage();\n});\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t251: 0,\n\t747: 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = this[\"webpackChunknotations\"] = this[\"webpackChunknotations\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","__webpack_require__.nc = undefined;","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [995,446,359,126], () => (__webpack_require__(8481)))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n"],"names":["root","factory","exports","module","define","amd","this","deferred","GridCellEvent","GridModel","uuid","idCounter","lastUpdatedAt","rows","rowAligns","Map","colAligns","debugValue","map","r","firstRow","gr","numCells","rowIndex","firstCol","minCol","fc","cellsInRow","row","out","cell","cells","value","push","cellsInCol","col","cellAt","addRowAlign","align","set","addColAlign","addRows","insertBefore","numRows","length","next","prev","i","newRow","GridRow","splice","defaultRowAlign","addSuccessor","getRow","setValue","cellCreator","grow","GridCell","clearCellAt","eventHub","emit","CLEARED","loc","location","oldValue","UPDATED","eventHubChanged","console","log","constructor","gridRow","colIndex","rowAlign","_rowAlign","val","addCell","colAlign","_colAlign","grid","c","y","coordOffset","h","maxLength","x","w","RowAlign","numCols","creator","filter","AlignedLine","needsLayout","_coordOffset","_maxLength","paddingBefore","paddingAfter","prevLines","nextLines","setMaxLength","setPadding","before","after","beforeAddingCell","removeCell","beforeRemovingCell","ColAlign","setOffset","cellView","getCellView","evalMaxLength","setBounds","changedCells","Math","max","minSize","width","height","GridLayoutGroup","gridModels","layoutChangeSubscribers","Set","previousColumnWidths","previousRowHeights","eventHandler","event","applyModelEvents","payload","onLayoutChange","callback","add","delete","notifyLayoutChange","e","error","subscriberCount","size","addGridModel","gridModel","on","BATCH_EVENTS","startingRowAligns","visited","gm","startingColAligns","removeGridModel","removeOn","startingRows","startingCols","refreshLayout","notify","changedRowAligns","changedColAligns","rowHeightsChanged","doBfsLayout","columnWidthsChanged","affectedRowRange","affectedColRange","affectedGridModels","events","changesForEvents","hadRowChanges","Object","keys","hadColChanges","calculateAffectedRowRange","calculateAffectedColRange","minRow","Infinity","maxRow","alignId","min","start","end","maxCol","checkAndUpdateLength","previousMap","previous","get","current","undefined","cellVisited","affectedGridModelsSet","split","parseInt","source","Array","from","ensureGetCellView","startingLines","changedAligns","previousLengths","anyDimensionChanged","lineQueue","visitedLines","line","lineOffsetChanged","nextQueue","prevLineAlign","lineAlign","newOffset","lineChanged","RoleDef","name","notesOnly","index","RawBlock","content","contentType","super","TYPE","isBlock","item","isLine","isRawBlock","Block","blockType","parent","blockItems","localCycle","localAtomsPerBeat","localBreaks","localRoles","_parentBlock","_currRoleDef","_currentLine","_observers","_unnamedLayoutParams","_namedLayoutParams","_layoutParams","setParent","addObserver","observer","removeObserver","indexOf","children","parentBlock","cycle","atomsPerBeat","breaks","unnamedLayoutParams","namedLayoutParams","layoutParams","findUnnamedLayoutParams","snapshotLayoutParams","resetLayoutParams","resetLine","effectiveCycle","Error","beatDuration","layout","find","lp","equals","lineBreaksEqual","ensureNamedLayoutParams","lineBreaks","getRole","toLowerCase","currRoleDef","roles","values","setCurrRole","trim","roleDef","newRoleDef","currentLine","newLine","isEmpty","removeBlockItem","addBlockItem","has","rd","_eventsEnabled","onItemAdded","onItemRemoved","findContainingBlock","entity","SectionBlock","sectionName","RepeatBlock","repeatCount","expanded","CycleBlock","BeatDurationBlock","BreaksBlock","RoleBlock","roleName","GroupBlock","groupName","NotationBlock","container","config","caption","isEditing","editTextarea","sourceCodeElement","id","getAttribute","sourceFrom","textContent","sourceElem","document","getElementById","showSource","parentNode","newRoot","createElement","classList","cssClasses","className","html","sourceLines","sourceClass","sourceContainer","captionClass","sourceCaption","codeClass","sourceCode","join","outputLabelClass","outputLabel","outputClass","outputContainer","innerHTML","removeChild","notationViewerBlock","querySelector","notationView","createViewer","copyBtn","addEventListener","copyToClipboard","editBtn","toggleEditMode","applyBtn","applyEdit","cancelBtn","cancelEdit","updatePreview","fullContents","tableElement","notation","beatLayout","errors","timings","renderNotation","msg","trunc","parseTime","buildTime","captionId","navigator","clipboard","writeText","btnText","originalText","setTimeout","err","alert","enterEditMode","exitEditMode","parentElement","style","display","scrollHeight","editActions","focus","MarkdownIt","rootElement","NotationView","markdownParser","md","contents","tokens","parse","renderer","render","langPrefix","createMarkdownParser","window","N","DocsPage","notations","genIds","genCounter","querySelectorAll","setAttribute","block","docsPage","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call","m","O","result","chunkIds","fn","priority","notFulfilled","fulfilled","j","every","key","n","getter","__esModule","d","a","definition","o","defineProperty","enumerable","obj","prop","prototype","hasOwnProperty","Symbol","toStringTag","installedChunks","chunkId","webpackJsonpCallback","parentChunkLoadingFunction","data","moreModules","runtime","some","chunkLoadingGlobal","forEach","bind","nc","__webpack_exports__"],"ignoreList":[],"sourceRoot":""}