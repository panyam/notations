{"version":3,"file":"747.d5395923d81283f4312f.js","mappings":"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","sources":["webpack://notations/./src/grids.ts","webpack://notations/./src/block.ts"],"sourcesContent":["import * as TSU from \"@panyam/tsutils\";\n// import * as kiwi from \"@lume/kiwi\";\n\n/**\n * Event emitted when layout changes occur in a GridLayoutGroup.\n * Subscribers can use this to update their views incrementally.\n */\nexport interface LayoutChangeEvent {\n  /** The range of rows affected by the change */\n  affectedRowRange: { start: number; end: number } | null;\n  /** The range of columns affected by the change */\n  affectedColRange: { start: number; end: number } | null;\n  /** Whether column widths changed (requires horizontal re-layout) */\n  columnWidthsChanged: boolean;\n  /** Whether row heights changed (requires vertical re-layout) */\n  rowHeightsChanged: boolean;\n  /** The grid models that were affected */\n  affectedGridModels: GridModel[];\n}\n\n/**\n * Callback type for layout change subscribers.\n */\nexport type LayoutChangeCallback = (event: LayoutChangeEvent) => void;\n\n/**\n * A generic grid layout system for hosting child views (similar to GridBagLayout).\n * This provides a framework for hosting BeatViews in a structured grid arrangement,\n * with support for rows, columns, and alignment.\n *\n * Grid \"cells\" can be referred to by cell indexes. Additionally, grid rows and\n * columns can have names (like in spreadsheets) so that even when rows and columns\n * are inserted, though indexes may change, the \"addresses\" remain fixed and immovable.\n */\nexport class GridModel extends TSU.Events.EventEmitter {\n  private static idCounter = 0;\n  readonly uuid = GridModel.idCounter++;\n  /** Timestamp of the last update to this grid */\n  lastUpdatedAt = 0;\n  // cells = new SparseArray<SparseArray<GridCell>>();\n  /** The rows in this grid */\n  rows: GridRow[] = [];\n  /** Mapping of row indices to row alignment objects */\n  rowAligns = new Map<number, RowAlign>();\n  /** Mapping of column indices to column alignment objects */\n  colAligns = new Map<number, ColAlign>();\n\n  /**\n   * Returns a debug-friendly representation of this GridModel.\n   * @returns An object containing debug information\n   */\n  debugValue() {\n    const out = {\n      rows: this.rows.map((r) => r.debugValue()),\n      lastUpdatedAt: this.lastUpdatedAt,\n    } as any;\n    return out;\n  }\n\n  /**\n   * Gets the index of the first non-empty row.\n   * @returns The index of the first row containing cells, or -1 if none\n   */\n  get firstRow(): number {\n    for (const gr of this.rows) {\n      if (gr.numCells > 0) return gr.rowIndex;\n    }\n    return -1;\n  }\n\n  /**\n   * Gets the index of the leftmost column containing cells.\n   * @returns The index of the first column containing cells, or -1 if none\n   */\n  get firstCol(): number {\n    let minCol = -1;\n    for (const gr of this.rows) {\n      const fc = gr.firstCol;\n      if (fc >= 0) {\n        if (minCol < 0 || fc < minCol) {\n          minCol = fc;\n        }\n      }\n    }\n    return minCol;\n  }\n\n  /**\n   * Gets all non-empty cells in a specific row.\n   * @param row The index of the row\n   * @returns An array of cells in the row\n   */\n  cellsInRow(row: number): GridCell[] {\n    const out = [] as GridCell[];\n    const gr = this.rows[row];\n    if (gr) {\n      for (const cell of gr.cells) {\n        if (cell?.value) out.push(cell);\n      }\n    }\n    return out;\n  }\n\n  /**\n   * Gets all non-empty cells in a specific column.\n   * @param col The index of the column\n   * @returns An array of cells in the column\n   */\n  cellsInCol(col: number): GridCell[] {\n    const out = [] as GridCell[];\n    for (const gr of this.rows) {\n      const cell = gr.cellAt(col);\n      if (cell?.value) out.push(cell);\n    }\n    return out;\n  }\n\n  /**\n   * Adds a row alignment object to the grid.\n   * @param align The row alignment to add\n   */\n  addRowAlign(align: RowAlign): void {\n    this.rowAligns.set(align.uuid, align);\n  }\n\n  /**\n   * Adds a column alignment object to the grid.\n   * @param align The column alignment to add\n   */\n  addColAlign(align: ColAlign): void {\n    this.colAligns.set(align.uuid, align);\n  }\n\n  /**\n   * Adds rows to the grid.\n   * @param insertBefore The index before which to insert the rows, or -1 to append\n   * @param numRows The number of rows to add\n   * @returns This grid instance for method chaining\n   */\n  addRows(insertBefore = -1, numRows = 1): this {\n    if (insertBefore < 0) {\n      insertBefore = this.rows.length;\n    }\n    let next = this.rows[insertBefore] || null;\n    const prev = this.rows[insertBefore - 1] || null;\n    for (let i = numRows - 1; i >= 0; i--) {\n      const newRow = new GridRow(this, insertBefore + i);\n      this.rows.splice(insertBefore, 0, newRow);\n      if (next != null) {\n        newRow.defaultRowAlign.addSuccessor(next.defaultRowAlign);\n      }\n      if (i == 0 && insertBefore > 0) {\n        prev.defaultRowAlign.addSuccessor(newRow.defaultRowAlign);\n      }\n      next = newRow;\n    }\n    for (let i = insertBefore + numRows; i < this.rows.length; i++) {\n      this.rows[i].rowIndex += numRows;\n    }\n    return this;\n  }\n\n  /**\n   * Gets a row at the specified index, creating it if necessary.\n   * @param row The index of the row to get\n   * @returns The row at the specified index\n   */\n  getRow(row: number): GridRow {\n    if (row >= this.rows.length) {\n      this.addRows(-1, 1 + row - this.rows.length);\n    }\n    return this.rows[row];\n  }\n\n  /**\n   * Sets a value in a cell at the specified row and column.\n   * @param row The row index\n   * @param col The column index\n   * @param value The value to set\n   * @param cellCreator Optional function to create a custom cell\n   * @returns The previous value of the cell\n   */\n  setValue(row: number, col: number, value: any, cellCreator?: (row: GridRow, col: number) => GridCell): any {\n    const grow = this.getRow(row);\n    if (!cellCreator) {\n      cellCreator = (row: GridRow, col: number) => {\n        return new GridCell(row, col);\n      };\n    }\n    if (value == null) {\n      const out = grow.clearCellAt(col);\n      if (out != null) {\n        this.eventHub?.emit(GridCellEvent.CLEARED, this, {\n          loc: out.location,\n        });\n      }\n      return out;\n    } else {\n      const cell = grow.cellAt(col, cellCreator) as GridCell;\n      const oldValue = cell.value;\n      this.eventHub?.emit(GridCellEvent.UPDATED, this, {\n        loc: cell.location,\n        cell: cell,\n        oldValue: cell.value,\n      });\n      cell.value = value;\n      return oldValue;\n    }\n  }\n\n  /**\n   * Handles changes to the event hub.\n   */\n  protected eventHubChanged(): void {\n    console.log(\"Event Hub Changed for GridModel\");\n  }\n}\n\n/**\n * Interface for a view associated with a grid cell.\n * GridCellView defines the contract for views that can be placed in grid cells.\n */\nexport interface GridCellView {\n  /** The grid cell this view is associated with */\n  readonly cell: GridCell;\n  /** X-coordinate of the view */\n  x: number;\n  /** Y-coordinate of the view */\n  y: number;\n  /** Width of the view */\n  width: number;\n  /** Height of the view */\n  height: number;\n\n  /**\n   * Sets the bounds of the view.\n   * @param x New x-coordinate, or null to keep current value\n   * @param y New y-coordinate, or null to keep current value\n   * @param w New width, or null to keep current value\n   * @param h New height, or null to keep current value\n   * @param applyLayout Whether to apply layout immediately\n   * @returns The new bounds values\n   */\n  setBounds(\n    x: number | null,\n    y: number | null,\n    w: number | null,\n    h: number | null,\n    applyLayout: boolean,\n  ): [number | null, number | null, number | null, number | null];\n\n  /** Whether this view needs layout */\n  readonly needsLayout: boolean;\n\n  /** The minimum size this view requires */\n  readonly minSize: TSU.Geom.Size;\n\n  /** The bounding box of this view */\n  readonly bbox: TSU.Geom.Rect;\n}\n\n/**\n * Enum defining the events that can occur on grid cells.\n */\nexport enum GridCellEvent {\n  ADDED = \"CellAdded\",\n  CLEARED = \"CellCleared\",\n  REMOVED = \"CellRemoved\",\n  UPDATED = \"CellUpdated\",\n  MOVED = \"CellMoved\",\n}\n\n/**\n * Represents a cell in the grid.\n * GridCell holds a value and manages alignment with rows and columns.\n */\nexport class GridCell {\n  private static idCounter = 0;\n  readonly uuid = GridCell.idCounter++;\n  /** The view associated with this cell */\n  cellView: GridCellView | null;\n  private _rowAlign: RowAlign;\n  private _colAlign: ColAlign;\n\n  /**\n   * Creates a new GridCell.\n   * @param gridRow The row this cell belongs to\n   * @param colIndex The column index of this cell\n   * @param value Optional initial value for the cell\n   */\n  constructor(\n    public gridRow: GridRow,\n    public colIndex: number,\n    public value: any = null,\n  ) {\n    this.rowAlign = gridRow.defaultRowAlign;\n  }\n\n  /**\n   * Gets the row alignment for this cell.\n   */\n  get rowAlign(): RowAlign {\n    return this._rowAlign;\n  }\n\n  /**\n   * Sets the row alignment for this cell.\n   */\n  set rowAlign(val: RowAlign) {\n    val.addCell(this);\n    this._rowAlign = val;\n  }\n\n  /**\n   * Gets the column alignment for this cell.\n   */\n  get colAlign(): ColAlign {\n    return this._colAlign;\n  }\n\n  /**\n   * Sets the column alignment for this cell.\n   */\n  set colAlign(val: ColAlign) {\n    val.addCell(this);\n    this._colAlign = val;\n  }\n\n  /**\n   * Gets the location string for this cell (rowIndex:colIndex).\n   */\n  get location(): string {\n    return this.gridRow.rowIndex + \":\" + this.colIndex;\n  }\n\n  /**\n   * Gets the grid this cell belongs to.\n   */\n  get grid(): GridModel {\n    return this.gridRow.grid;\n  }\n\n  /**\n   * Gets the row index of this cell.\n   */\n  get rowIndex(): number {\n    return this.gridRow.rowIndex;\n  }\n\n  /**\n   * Returns a debug-friendly representation of this GridCell.\n   * @returns An object containing debug information\n   */\n  debugValue() {\n    const out = {\n      r: this.gridRow.rowIndex,\n      c: this.colIndex,\n      value: this.value,\n      y: this.rowAlign.coordOffset,\n      h: this.rowAlign.maxLength,\n    } as any;\n    if (this.colAlign) {\n      out.x = this.colAlign.coordOffset;\n      out.w = this.colAlign.maxLength;\n    }\n    return out;\n  }\n}\n\n/**\n * Represents a row of grid cells in a GridModel.\n */\nexport class GridRow {\n  /** The cells in this row */\n  cells: (null | GridCell)[] = [];\n  /** The default vertical alignment for all cells in this row */\n  defaultRowAlign: RowAlign;\n\n  /**\n   * Creates a new GridRow.\n   * @param grid The grid this row belongs to\n   * @param rowIndex The index of this row\n   */\n  constructor(\n    public grid: GridModel,\n    public rowIndex: number,\n  ) {\n    this.defaultRowAlign = new RowAlign();\n    this.grid.addRowAlign(this.defaultRowAlign);\n  }\n\n  /**\n   * Gets the index of the first non-empty column in this row.\n   */\n  get firstCol() {\n    for (let i = 0; i < this.cells.length; i++) {\n      if (this.cells[i]?.value) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Gets the number of columns in this row.\n   */\n  get numCols() {\n    return this.cells.length;\n  }\n\n  /**\n   * Gets the number of cells that contain values.\n   */\n  get numCells() {\n    let i = 0;\n    for (const cell of this.cells) {\n      if (cell != null && cell.value != null) i++;\n    }\n    return i;\n  }\n\n  /**\n   * Gets the cell at the specified column index, optionally creating it if it doesn't exist.\n   * @param col The column index\n   * @param creator Optional function to create the cell if it doesn't exist\n   * @returns The cell at the specified index, or null if it doesn't exist and no creator was provided\n   */\n  cellAt(col: number, creator?: (row: GridRow, col: number) => GridCell): GridCell | null {\n    let out = this.cells[col] || null;\n    if (!out && creator) {\n      this.cells[col] = out = creator(this, col);\n      out.gridRow = this;\n      out.colIndex = col;\n      if (out.rowAlign) {\n        this.grid.addRowAlign(out.rowAlign);\n      }\n      if (out.colAlign) {\n        this.grid.addColAlign(out.colAlign);\n      }\n    }\n    return out;\n  }\n\n  /**\n   * Clears the cell at the given column.\n   * Note this is not the same as \"removing\" a cell.\n   * Removing a cell would require all cells to the \"right\" to be shifted left.\n   * @param col The column index\n   * @returns The cell that was cleared, or null if none existed\n   */\n  clearCellAt(col: number): GridCell | null {\n    const out = this.cells[col] || null;\n    if (out) {\n      this.cells[col] = null;\n    }\n    return out;\n  }\n\n  /**\n   * Returns a debug-friendly representation of this GridRow.\n   * @returns An object containing debug information\n   */\n  debugValue() {\n    return {\n      r: this.rowIndex,\n      cells: this.cells.filter((c) => c).map((c) => c?.debugValue()),\n    };\n  }\n}\n\n/**\n * Base class for row and column alignment objects.\n * AlignedLine manages the alignment of cells along a line (row or column).\n */\nexport abstract class AlignedLine {\n  private static idCounter = 0;\n  readonly uuid = AlignedLine.idCounter++;\n  /** Whether this line needs layout */\n  needsLayout = false;\n  /** The coordinate offset of this line */\n  protected _coordOffset = 0;\n  /** The maximum length of this line */\n  protected _maxLength = 0;\n  /** Padding before this line */\n  paddingBefore = 5;\n  /** Padding after this line */\n  paddingAfter = 5;\n  /** The cells that belong to this line */\n  cells: GridCell[] = [];\n  /** Function to get a view for a cell value */\n  getCellView: (value: any) => GridCellView;\n\n  /**\n   * Sets the offset of this line.\n   * @param val The new offset value\n   */\n  abstract setOffset(val: number): void;\n\n  /**\n   * Evaluates the maximum length required for this line.\n   * @param changedCells Cells that have changed and need re-evaluation\n   * @returns The maximum length\n   */\n  abstract evalMaxLength(changedCells: GridCell[]): number;\n\n  /**\n   * Gets the coordinate offset of this line.\n   */\n  get coordOffset(): number {\n    return this._coordOffset;\n  }\n\n  /**\n   * Gets the maximum length of this line, including padding.\n   */\n  get maxLength(): number {\n    return this._maxLength + this.paddingBefore + this.paddingAfter;\n  }\n\n  /**\n   * Sets the maximum length of this line.\n   * @param length The new maximum length\n   */\n  setMaxLength(length: number) {\n    this._maxLength = length;\n  }\n\n  /**\n   * Sets the padding before and after this line.\n   * @param before Padding before the line\n   * @param after Padding after the line\n   */\n  setPadding(before: number, after: number): void {\n    if (before >= 0) {\n      this.paddingBefore = before;\n    }\n    if (after >= 0) {\n      this.paddingAfter = after;\n    }\n  }\n\n  /**\n   * Adds a cell to this line.\n   * @param cell The cell to add\n   * @returns This line instance for method chaining\n   */\n  addCell(cell: GridCell): this {\n    if (this.beforeAddingCell(cell)) {\n      this.cells.push(cell);\n    }\n    return this;\n  }\n\n  /**\n   * Called before adding a cell to perform validation or preparation.\n   * @param cell The cell to be added\n   * @returns Whether the cell should be added\n   */\n  protected abstract beforeAddingCell(cell: GridCell): boolean;\n\n  /**\n   * Removes a cell from this line.\n   * @param cell The cell to remove\n   * @returns This line instance for method chaining\n   */\n  removeCell(cell: GridCell): this {\n    if (this.beforeRemovingCell(cell)) {\n      for (let i = 0; i < this.cells.length; i++) {\n        if (this.cells[i].uuid == cell.uuid) {\n          this.cells.splice(i, 1);\n          break;\n        }\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Called before removing a cell to perform validation.\n   * @param cell The cell to be removed\n   * @returns Whether the cell should be removed\n   */\n  protected abstract beforeRemovingCell(cell: GridCell): boolean;\n\n  // The \"neighboring\" lines that depend on this line to be placed\n  // before they are placed\n  /** Lines that must be positioned before this line */\n  prevLines = [] as this[];\n  /** Lines that must be positioned after this line */\n  nextLines = [] as this[];\n\n  /**\n   * Adds a successor line to this line.\n   * @param next The line to add as a successor\n   */\n  addSuccessor(next: this): void {\n    // Set nextCol as a successor of this col\n    // TODO - Ensure no cycles\n    for (const c of this.nextLines) {\n      if (c == next) return;\n    }\n    this.nextLines.push(next);\n    next.prevLines.push(this);\n  }\n\n  /* TODO: Disabling only to improve test coverage as this method is\n   * not used.\n   * When we have mutable grids where we can insert/remove neighbors\n   * we can enable this again.\n   */\n  /*\n  removeSuccessor(next: this): void {\n    // Set nextCol as a successor of this col\n    // TODO - Ensure no cycles\n    for (let i = 0; i < this.nextLines.length; i++) {\n      if (this.nextLines[i] == next) {\n        this.nextLines.splice(i, 1);\n        break;\n      }\n    }\n    for (let i = 0; i < next.prevLines.length; i++) {\n      if (next.prevLines[i] == this) {\n        next.prevLines.splice(i, 1);\n        break;\n      }\n    }\n  }\n  */\n}\n\n/**\n * Manages the alignment of cells in a column.\n */\nexport class ColAlign extends AlignedLine {\n  paddingBefore = 10;\n  /** Padding after this line */\n  paddingAfter = 10;\n\n  /**\n   * Sets the offset of this column and updates all associated cells.\n   * @param val The new offset value\n   */\n  setOffset(val: number): void {\n    this._coordOffset = val;\n    for (const cell of this.cells) {\n      if (cell.value) {\n        const cellView = this.getCellView(cell);\n        if (this._maxLength <= 0) {\n          // this hasnt been evaluated yet so do it!\n          this.evalMaxLength();\n        }\n        cellView.setBounds(val, null, this.maxLength, null, true);\n      }\n    }\n  }\n\n  /**\n   * Evaluates the maximum width required for this column.\n   * @param changedCells Cells that have changed and need re-evaluation\n   * @returns The maximum width\n   */\n  evalMaxLength(changedCells: GridCell[] = []): number {\n    this._maxLength = 0;\n    for (const cell of this.cells) {\n      if (cell.value) {\n        const cellView = this.getCellView(cell);\n        this._maxLength = Math.max(cellView.minSize.width, this._maxLength);\n      }\n    }\n    return this._maxLength;\n  }\n\n  /**\n   * Called before adding a cell to perform validation or preparation.\n   * @param cell The cell to be added\n   * @returns Whether the cell should be added\n   */\n  protected beforeAddingCell(cell: GridCell): boolean {\n    if (cell.colAlign && cell.colAlign != this) {\n      cell.colAlign.removeCell(cell);\n    }\n    return cell.colAlign != this;\n  }\n\n  /**\n   * Called before removing a cell to perform validation.\n   * @param cell The cell to be removed\n   * @returns Whether the cell should be removed\n   */\n  beforeRemovingCell(cell: GridCell): boolean {\n    return cell.colAlign == this;\n  }\n}\n\n/**\n * Manages the alignment of cells in a row.\n */\nexport class RowAlign extends AlignedLine {\n  /**\n   * Sets the Y coordinate of all cells in this row.\n   * @param val The new Y coordinate\n   */\n  setOffset(val: number): void {\n    this._coordOffset = val;\n    for (const cell of this.cells) {\n      if (cell.value) {\n        const cellView = this.getCellView(cell);\n        if (this._maxLength <= 0) {\n          // this hasnt been evaluated yet so do it!\n          this.evalMaxLength();\n        }\n        cellView.setBounds(null, val, null, this.maxLength, true);\n      }\n    }\n  }\n\n  /**\n   * Evaluates the maximum height required for this row.\n   * @param changedCells Cells that have changed and need re-evaluation\n   * @returns The maximum height\n   */\n  evalMaxLength(changedCells: GridCell[] = []): number {\n    this._maxLength = 0;\n    for (const cell of this.cells) {\n      if (cell.value) {\n        const cellView = this.getCellView(cell);\n        this._maxLength = Math.max(cellView.minSize.height, this._maxLength);\n      }\n    }\n    return this._maxLength;\n  }\n\n  /**\n   * Called before adding a cell to perform validation or preparation.\n   * @param cell The cell to be added\n   * @returns Whether the cell should be added\n   */\n  protected beforeAddingCell(cell: GridCell): boolean {\n    if (cell.rowAlign && cell.rowAlign != this) {\n      cell.rowAlign.removeCell(cell);\n    }\n    return cell.rowAlign != this;\n  }\n\n  /**\n   * Called before removing a cell to perform validation.\n   * @param cell The cell to be removed\n   * @returns Whether the cell should be removed\n   */\n  beforeRemovingCell(cell: GridCell): boolean {\n    return cell.rowAlign == this;\n  }\n}\n\n/**\n * The layout manager for a collection of GridViews bound by common alignment objects.\n * Manages the layout of multiple grid models, ensuring proper alignment between them.\n */\nexport class GridLayoutGroup {\n  // rowAligns = new Map<number, RowAlign>();\n  // colAligns = new Map<number, ColAlign>();\n  /** The grid models managed by this layout group */\n  gridModels = [] as GridModel[];\n\n  /** Subscribers to layout change events */\n  private layoutChangeSubscribers = new Set<LayoutChangeCallback>();\n\n  /** Previous column widths by ColAlign uuid - for detecting actual changes */\n  private previousColumnWidths = new Map<number, number>();\n\n  /** Previous row heights by RowAlign uuid - for detecting actual changes */\n  private previousRowHeights = new Map<number, number>();\n\n  /**\n   * Subscribes to layout change events.\n   * @param callback Function to call when layout changes\n   * @returns Unsubscribe function\n   */\n  onLayoutChange(callback: LayoutChangeCallback): () => void {\n    this.layoutChangeSubscribers.add(callback);\n    return () => {\n      this.layoutChangeSubscribers.delete(callback);\n    };\n  }\n\n  /**\n   * Notifies all subscribers of a layout change.\n   * @param event The layout change event\n   */\n  protected notifyLayoutChange(event: LayoutChangeEvent): void {\n    for (const callback of this.layoutChangeSubscribers) {\n      try {\n        callback(event);\n      } catch (e) {\n        console.error(\"Error in layout change callback:\", e);\n      }\n    }\n  }\n\n  /**\n   * Gets the number of layout change subscribers.\n   */\n  get subscriberCount(): number {\n    return this.layoutChangeSubscribers.size;\n  }\n\n  /**\n   * Event handler for processing events from grid models.\n   */\n  private eventHandler = (event: TSU.Events.TEvent) => {\n    this.applyModelEvents(event.payload);\n  };\n\n  /**\n   * Adds a grid model to this layout group.\n   * @param gridModel The grid model to add\n   * @returns True if the model was added successfully\n   */\n  addGridModel(gridModel: GridModel): boolean {\n    gridModel.eventHub?.on(TSU.Events.EventHub.BATCH_EVENTS, this.eventHandler);\n    this.gridModels.push(gridModel);\n    return true;\n  }\n\n  /**\n   * Gets all row alignment objects that have no predecessors.\n   * @returns An array of starting row alignments\n   */\n  startingRowAligns(): RowAlign[] {\n    const out = [] as RowAlign[];\n    const visited = {} as any;\n    for (const gm of this.gridModels) {\n      for (const cell of gm.cellsInRow(gm.firstRow)) {\n        if (cell.rowAlign && !visited[cell.rowAlign.uuid]) {\n          visited[cell.rowAlign.uuid] = true;\n          out.push(cell.rowAlign);\n        }\n      }\n    }\n    return out;\n  }\n\n  /**\n   * Gets all column alignment objects that have no predecessors.\n   * @returns An array of starting column alignments\n   */\n  startingColAligns(): ColAlign[] {\n    const out = [] as ColAlign[];\n    const visited = {} as any;\n    for (const gm of this.gridModels) {\n      for (const cell of gm.cellsInCol(gm.firstCol)) {\n        if (cell.colAlign && !visited[cell.colAlign.uuid]) {\n          visited[cell.colAlign.uuid] = true;\n          out.push(cell.colAlign);\n        }\n      }\n    }\n    return out;\n  }\n\n  /**\n   * Removes a grid model from this layout group.\n   * @param gridModel The grid model to remove\n   */\n  removeGridModel(gridModel: GridModel): void {\n    gridModel.eventHub?.removeOn(TSU.Events.EventHub.BATCH_EVENTS, this.eventHandler);\n  }\n\n  /**\n   * Function to get a view for a cell value.\n   */\n  getCellView: (cell: GridCell) => GridCellView;\n\n  /**\n   * Gets the starting row alignments.\n   */\n  get startingRows(): RowAlign[] {\n    return this.startingRowAligns();\n  }\n\n  /**\n   * Gets the starting column alignments.\n   */\n  get startingCols(): ColAlign[] {\n    return this.startingColAligns();\n  }\n\n  /**\n   * Forces a full refresh of the layout.\n   * This recalculates all row and column sizes and positions.\n   * @param notify Whether to notify subscribers of the change (default: true)\n   */\n  refreshLayout(notify = true): void {\n    const changedRowAligns = {} as any;\n    const changedColAligns = {} as any;\n\n    for (const rowAlign of this.startingRowAligns()) {\n      if (!(rowAlign.uuid in changedRowAligns)) {\n        changedRowAligns[rowAlign.uuid] = {\n          align: rowAlign,\n          cells: [],\n        };\n      }\n    }\n\n    for (const colAlign of this.startingColAligns()) {\n      if (!(colAlign.uuid in changedColAligns)) {\n        changedColAligns[colAlign.uuid] = {\n          align: colAlign,\n          cells: [],\n        };\n      }\n    }\n\n    // Pass the previous dimension maps for O(1) inline change detection\n    const rowHeightsChanged = this.doBfsLayout(this.startingRows, changedRowAligns, this.previousRowHeights);\n    const columnWidthsChanged = this.doBfsLayout(this.startingCols, changedColAligns, this.previousColumnWidths);\n\n    // Notify subscribers of full refresh\n    if (notify && this.layoutChangeSubscribers.size > 0) {\n      this.notifyLayoutChange({\n        affectedRowRange: null, // null means all rows\n        affectedColRange: null, // null means all columns\n        columnWidthsChanged,\n        rowHeightsChanged,\n        affectedGridModels: this.gridModels,\n      });\n    }\n  }\n\n  /**\n   * Applies model events to update the layout.\n   * @param events The events to process\n   */\n  protected applyModelEvents(events: TSU.Events.TEvent[]): void {\n    // As the grid model changes (cell content changed, cleared etc) we need\n    // to refresh our layout based on this.\n    // As a first step the new height and width of all changed cells is\n    // evaluted to see which rows and/or columns are affected (and need to be\n    // resized/repositioned).\n    const [changedRowAligns, changedColAligns, affectedGridModels] = this.changesForEvents(events);\n    const hadRowChanges = Object.keys(changedRowAligns).length > 0;\n    const hadColChanges = Object.keys(changedColAligns).length > 0;\n\n    // Pass the previous dimension maps for O(1) inline change detection\n    const rowHeightsChanged = this.doBfsLayout(this.startingRows, changedRowAligns, this.previousRowHeights);\n    const columnWidthsChanged = this.doBfsLayout(this.startingCols, changedColAligns, this.previousColumnWidths);\n\n    // Notify subscribers of incremental changes\n    if (this.layoutChangeSubscribers.size > 0 && (hadRowChanges || hadColChanges)) {\n      // Calculate affected ranges from the changed alignments\n      const affectedRowRange = this.calculateAffectedRowRange(changedRowAligns);\n      const affectedColRange = this.calculateAffectedColRange(changedColAligns);\n\n      this.notifyLayoutChange({\n        affectedRowRange,\n        affectedColRange,\n        columnWidthsChanged,\n        rowHeightsChanged,\n        affectedGridModels: affectedGridModels,\n      });\n    }\n  }\n\n  /**\n   * Calculates the range of affected rows from changed row alignments.\n   * Returns null if no rows changed or range cannot be determined.\n   */\n  protected calculateAffectedRowRange(changedRowAligns: any): { start: number; end: number } | null {\n    let minRow = Infinity;\n    let maxRow = -Infinity;\n\n    for (const alignId in changedRowAligns) {\n      const { cells } = changedRowAligns[alignId];\n      for (const cell of cells) {\n        const rowIndex = cell.gridRow.rowIndex;\n        minRow = Math.min(minRow, rowIndex);\n        maxRow = Math.max(maxRow, rowIndex);\n      }\n    }\n\n    if (minRow === Infinity) return null;\n    return { start: minRow, end: maxRow };\n  }\n\n  /**\n   * Calculates the range of affected columns from changed column alignments.\n   * Returns null if no columns changed or range cannot be determined.\n   */\n  protected calculateAffectedColRange(changedColAligns: any): { start: number; end: number } | null {\n    let minCol = Infinity;\n    let maxCol = -Infinity;\n\n    for (const alignId in changedColAligns) {\n      const { cells } = changedColAligns[alignId];\n      for (const cell of cells) {\n        const colIndex = cell.colIndex;\n        minCol = Math.min(minCol, colIndex);\n        maxCol = Math.max(maxCol, colIndex);\n      }\n    }\n\n    if (minCol === Infinity) return null;\n    return { start: minCol, end: maxCol };\n  }\n\n  /**\n   * Checks if an alignment's maxLength changed from previous value.\n   * Updates the stored previous value. O(1) cost.\n   * @param align The alignment to check\n   * @param previousMap Map storing previous lengths\n   * @returns true if length changed (or is new)\n   */\n  private checkAndUpdateLength<T extends AlignedLine>(align: T, previousMap: Map<number, number>): boolean {\n    const previous = previousMap.get(align.uuid);\n    const current = align.maxLength;\n    previousMap.set(align.uuid, current);\n    return previous === undefined || previous !== current;\n  }\n\n  /**\n   * Determines which rows and columns need to be updated based on events.\n   * @param events The events to process\n   * @returns A tuple containing the changed row alignments, column alignments, and affected grid models\n   */\n  protected changesForEvents(events: TSU.Events.TEvent[]): [any, any, GridModel[]] {\n    // Step 1 - topologically sort RowAligns of changed cells\n    // Step 2 - topologically sort ColAligns of changed cells\n    // Step 3 -\n    const cellVisited = {} as any;\n    const changedRowAligns = {} as any;\n    const changedColAligns = {} as any;\n    const affectedGridModelsSet = new Set<GridModel>();\n    // Going in reverse means we only get the latest event affecting a cell\n    // instead of going through every change.\n    // Later on we can revisit this if the events are edge triggered instead\n    // of level triggered\n    for (let i = events.length - 1; i >= 0; i--) {\n      const event = events[i];\n      const loc = event.payload.loc;\n      if (cellVisited[loc]) continue;\n      cellVisited[loc] = true;\n      const [row, col] = loc.split(\":\").map((x: string) => parseInt(x));\n      const gridModel = event.source as GridModel;\n      affectedGridModelsSet.add(gridModel);\n      const cell = gridModel.getRow(row).cellAt(col);\n      if (cell) {\n        // TODO - For now we are marking both row and col as having\n        // changed for a cell.  We can optimize this to only row or\n        // col based on whether height or width has changed.\n        if (!(cell.rowAlign.uuid in changedRowAligns)) {\n          changedRowAligns[cell.rowAlign.uuid] = {\n            align: cell.rowAlign,\n            cells: [],\n          };\n        }\n        changedRowAligns[cell.rowAlign.uuid][\"cells\"].push(cell);\n\n        if (!(cell.colAlign.uuid in changedColAligns)) {\n          changedColAligns[cell.colAlign.uuid] = {\n            align: cell.colAlign,\n            cells: [],\n          };\n        }\n        changedColAligns[cell.colAlign.uuid][\"cells\"].push(cell);\n      }\n    }\n    return [changedRowAligns, changedColAligns, Array.from(affectedGridModelsSet)];\n  }\n\n  /**\n   * Ensures that a cell view getter function is available for an alignment.\n   * @param align The alignment to check\n   * @returns The cell view getter function\n   */\n  protected ensureGetCellView(align: AlignedLine) {\n    if (!align.getCellView) {\n      if (!this.getCellView) {\n        return null;\n      }\n      align.getCellView = this.getCellView;\n    }\n    return align.getCellView;\n  }\n\n  /**\n   * Performs a breadth-first layout of aligned lines.\n   * @param startingLines The lines to start from\n   * @param changedAligns Map of alignment IDs to changed alignments\n   * @param previousLengths Map to track previous lengths for change detection\n   * @returns true if any dimension (width/height) actually changed\n   */\n  protected doBfsLayout<T extends AlignedLine>(\n    startingLines: T[],\n    changedAligns: any,\n    previousLengths?: Map<number, number>,\n  ): boolean {\n    // 1. start from the starting lines and do a BF traversal\n    // 2. If a line not visited (ie laid out):\n    //      if it is in the changedAlign list then reval its length (w/h)\n    //      set its offset and length if either width or offset has changed\n    //      offset can be thought of changed if the preceding line's offset has changed\n    // first do above for rows\n    if (!this.getCellView) return false;\n    let anyDimensionChanged = false;\n\n    for (const alignId in changedAligns) {\n      const val = changedAligns[alignId];\n      this.ensureGetCellView(val.align);\n      val.align.evalMaxLength(val.cells);\n\n      // Check if this alignment's length actually changed (O(1))\n      if (previousLengths && this.checkAndUpdateLength(val.align, previousLengths)) {\n        anyDimensionChanged = true;\n      }\n    }\n\n    let lineQueue = [] as [null | T, T][];\n    const visitedLines = {} as any;\n    for (const line of startingLines) lineQueue.push([null, line]);\n    const lineOffsetChanged = {} as any;\n    while (lineQueue.length > 0) {\n      const nextQueue = [] as [null | T, T][];\n      for (let i = 0; i < lineQueue.length; i++) {\n        const [prevLineAlign, lineAlign] = lineQueue[i];\n        visitedLines[lineAlign.uuid] = true;\n        let newOffset = lineAlign.coordOffset;\n        let lineChanged = lineAlign.uuid in changedAligns;\n        if (prevLineAlign) {\n          if (lineOffsetChanged[prevLineAlign.uuid]) {\n            newOffset = prevLineAlign.coordOffset + prevLineAlign.maxLength;\n            lineChanged = true;\n          }\n        }\n        if (lineChanged) {\n          this.ensureGetCellView(lineAlign);\n          lineAlign.setOffset(newOffset);\n          lineOffsetChanged[lineAlign.uuid] = true;\n        }\n\n        // Add next neighbors now\n        for (const next of lineAlign.nextLines) {\n          if (!visitedLines[next.uuid]) {\n            nextQueue.push([lineAlign, next]);\n          }\n        }\n      }\n      lineQueue = nextQueue;\n    }\n\n    return anyDimensionChanged;\n  }\n}\n","import * as TSU from \"@panyam/tsutils\";\nimport { Entity } from \"./entity\";\nimport { Cycle } from \"./cycle\";\nimport { Line } from \"./core\";\nimport { LayoutParams } from \"./layouts\";\nimport { BlockObserver } from \"./events\";\n\n/**\n * Definition of a role in a block context.\n * This is used for block-scoped role definitions.\n */\nexport class RoleDef {\n  /** Name of the role */\n  name = \"\";\n\n  /** Whether this role contains only notes (true) or can also contain syllables/text (false) */\n  notesOnly = false;\n\n  /** Index of this role in the notation */\n  index = 0;\n}\n\n/**\n * Represents a raw block of content in the notation.\n * Raw blocks can contain arbitrary content like markdown, HTML, etc.\n */\nexport class RawBlock extends Entity {\n  readonly TYPE: string = \"RawBlock\";\n\n  /**\n   * Creates a new RawBlock.\n   * @param content The content of the block\n   * @param contentType The type of content (e.g., \"md\" for markdown)\n   */\n  constructor(\n    public content: string,\n    public contentType: string = \"md\",\n  ) {\n    super();\n  }\n\n  /**\n   * Returns a debug-friendly representation of this raw block.\n   * @returns An object containing debug information\n   */\n  debugValue(): any {\n    return { ...super.debugValue(), content: this.content, contentType: this.contentType };\n  }\n}\n\n/**\n * Union type for items that can appear in a block.\n */\nexport type BlockItem = Block | Line | RawBlock;\n\n/**\n * Type guard to check if an entity is a Block.\n */\nexport function isBlock(item: BlockItem): item is Block {\n  return item.TYPE === \"Block\";\n}\n\n/**\n * Type guard to check if an entity is a Line.\n */\nexport function isLine(item: BlockItem): item is Line {\n  return item.TYPE === \"Line\";\n}\n\n/**\n * Type guard to check if an entity is a RawBlock.\n */\nexport function isRawBlock(item: BlockItem): item is RawBlock {\n  return item.TYPE === \"RawBlock\";\n}\n\n/**\n * Represents a scoped block created by a command with braces.\n * For example: \\section(\"Pallavi\") { ... }\n *\n * Blocks inherit properties from their parent Block and can override them locally.\n * Properties are resolved lazily by walking up the tree.\n *\n * Block = Command + Children (unified model)\n */\nexport class Block extends Entity {\n  readonly TYPE: string = \"Block\";\n\n  /** The type of block (e.g., \"section\", \"repeat\", \"cycle\") */\n  readonly blockType: string;\n\n  /** Optional name for the block (e.g., section name) */\n  readonly name: TSU.Nullable<string>;\n\n  /** Child items (before expansion by subclasses) */\n  readonly blockItems: BlockItem[] = [];\n\n  // Local properties\n  localCycle: TSU.Nullable<Cycle> = null;\n  localAtomsPerBeat: TSU.Nullable<number> = null;\n  localBreaks: TSU.Nullable<number[]> = null;\n  readonly localRoles = new Map<string, RoleDef>();\n\n  // Store parent reference (Block or null for root)\n  private _parentBlock: TSU.Nullable<Block> = null;\n\n  // State tracking for command application (protected for Notation override)\n  protected _currRoleDef: TSU.Nullable<RoleDef> = null;\n  protected _currentLine: TSU.Nullable<Line> = null;\n\n  /**\n   * Observers that receive notifications when block items change.\n   */\n  private _observers: BlockObserver<BlockItem, Block>[] = [];\n\n  /**\n   * Creates a new Block.\n   * @param blockType The type of block (e.g., \"section\", \"group\")\n   * @param parent The parent block (null for root)\n   * @param name Optional name for the block\n   */\n  constructor(blockType: string, parent: TSU.Nullable<Block> = null, name: TSU.Nullable<string> = null) {\n    super();\n    this.blockType = blockType;\n    this.name = name;\n    this._parentBlock = parent;\n    // Also set Entity's parent for tree traversal\n    if (parent) {\n      this.setParent(parent);\n    }\n  }\n\n  /**\n   * Adds an observer to receive block item change notifications.\n   * @param observer The observer to add\n   * @returns A function to remove the observer\n   */\n  addObserver(observer: BlockObserver<BlockItem, Block>): () => void {\n    this._observers.push(observer);\n    return () => this.removeObserver(observer);\n  }\n\n  /**\n   * Removes an observer.\n   * @param observer The observer to remove\n   */\n  removeObserver(observer: BlockObserver<BlockItem, Block>): void {\n    const index = this._observers.indexOf(observer);\n    if (index >= 0) {\n      this._observers.splice(index, 1);\n    }\n  }\n\n  /**\n   * Returns the expanded children for layout iteration.\n   * Subclasses can override this to transform children (e.g., Repeat, Section).\n   */\n  children(): BlockItem[] {\n    return this.blockItems;\n  }\n\n  /**\n   * Gets the parent block.\n   */\n  get parentBlock(): TSU.Nullable<Block> {\n    return this._parentBlock;\n  }\n\n  // ============================================\n  // Property inheritance via tree walking\n  // ============================================\n\n  /**\n   * Gets the effective cycle by walking up the tree.\n   */\n  get cycle(): TSU.Nullable<Cycle> {\n    if (this.localCycle !== null) {\n      return this.localCycle;\n    }\n    return this.parentBlock?.cycle ?? null;\n  }\n\n  /**\n   * Gets the effective atoms per beat by walking up the tree.\n   * Defaults to 1 if not set anywhere in the tree.\n   */\n  get atomsPerBeat(): number {\n    if (this.localAtomsPerBeat !== null) {\n      return this.localAtomsPerBeat;\n    }\n    return this.parentBlock?.atomsPerBeat ?? 1;\n  }\n\n  /**\n   * Gets the effective line breaks by walking up the tree.\n   * Defaults to empty array if not set anywhere.\n   */\n  get breaks(): number[] {\n    if (this.localBreaks !== null) {\n      return this.localBreaks;\n    }\n    return this.parentBlock?.breaks ?? [];\n  }\n\n  // ============================================\n  // Layout parameters management\n  // ============================================\n\n  /** Layout parameters caching for this block scope */\n  private _unnamedLayoutParams: LayoutParams[] = [];\n  private _namedLayoutParams = new Map<string, LayoutParams>();\n  private _layoutParams: LayoutParams | null = null;\n\n  /**\n   * Gets the unnamed layout parameters for this block.\n   */\n  get unnamedLayoutParams(): ReadonlyArray<LayoutParams> {\n    return this._unnamedLayoutParams;\n  }\n\n  /**\n   * Gets the named layout parameters for this block.\n   */\n  get namedLayoutParams(): ReadonlyMap<string, LayoutParams> {\n    return this._namedLayoutParams;\n  }\n\n  /**\n   * Gets the current layout parameters for this block scope.\n   * Uses the effective cycle, atomsPerBeat, and breaks from tree walking.\n   * Creates or finds a matching LayoutParams if needed.\n   */\n  get layoutParams(): LayoutParams {\n    if (this._layoutParams == null) {\n      // Find or create layout params matching current effective values\n      this._layoutParams = this.findUnnamedLayoutParams();\n      if (this._layoutParams == null) {\n        this._layoutParams = this.snapshotLayoutParams();\n        this._unnamedLayoutParams.push(this._layoutParams);\n      }\n    }\n    return this._layoutParams;\n  }\n\n  /**\n   * Resets the current layout parameters to null.\n   * Called when layout-affecting properties change.\n   */\n  resetLayoutParams(): void {\n    this._layoutParams = null;\n    this.resetLine();\n  }\n\n  /**\n   * Creates a snapshot of the current layout parameters.\n   * @returns A new LayoutParams object with the current effective settings\n   */\n  protected snapshotLayoutParams(): LayoutParams {\n    const effectiveCycle = this.cycle;\n    if (effectiveCycle == null) {\n      throw new Error(\"Cannot create layout params: no cycle defined\");\n    }\n    return new LayoutParams({\n      cycle: effectiveCycle,\n      beatDuration: this.atomsPerBeat,\n      layout: this.breaks,\n    });\n  }\n\n  /**\n   * Finds an unnamed layout parameters object that matches the current effective settings.\n   * @returns Matching layout parameters, or null if none found\n   */\n  protected findUnnamedLayoutParams(): LayoutParams | null {\n    const effectiveCycle = this.cycle;\n    if (effectiveCycle == null) return null;\n\n    return (\n      this._unnamedLayoutParams.find((lp) => {\n        return (\n          lp.beatDuration == this.atomsPerBeat && effectiveCycle.equals(lp.cycle) && lp.lineBreaksEqual(this.breaks)\n        );\n      }) || null\n    );\n  }\n\n  /**\n   * Ensures that named layout parameters with the given name exist.\n   * @param name The name of the layout parameters\n   * @returns The layout parameters\n   */\n  ensureNamedLayoutParams(name: string): LayoutParams {\n    let lp = this._namedLayoutParams.get(name) || null;\n    if (lp == null || this._layoutParams != lp) {\n      if (lp == null) {\n        // Create new named layout params\n        lp = this.snapshotLayoutParams();\n        this._namedLayoutParams.set(name, lp);\n      } else {\n        // Copy named LPs attributes into our locals\n        this.localCycle = lp.cycle;\n        this.localAtomsPerBeat = lp.beatDuration;\n        this.localBreaks = lp.lineBreaks;\n      }\n      this._layoutParams = lp;\n      this.resetLine();\n    }\n    return this._layoutParams!;\n  }\n\n  /**\n   * Gets a role definition by name, walking up the tree if not found locally.\n   * @param name The name of the role\n   */\n  getRole(name: string): TSU.Nullable<RoleDef> {\n    const local = this.localRoles.get(name.toLowerCase());\n    if (local) {\n      return local;\n    }\n    return this.parentBlock?.getRole(name) ?? null;\n  }\n\n  // ============================================\n  // State tracking for command application\n  // ============================================\n\n  /**\n   * Gets the current role definition.\n   * Falls back to parent's current role or the last defined role.\n   */\n  get currRoleDef(): TSU.Nullable<RoleDef> {\n    if (this._currRoleDef !== null) {\n      return this._currRoleDef;\n    }\n    // Fall back to parent's current role\n    if (this.parentBlock) {\n      return this.parentBlock.currRoleDef;\n    }\n    // Or use the last locally defined role\n    const roles = Array.from(this.localRoles.values());\n    return roles.length > 0 ? roles[roles.length - 1] : null;\n  }\n\n  /**\n   * Sets the current role by name.\n   * If the role doesn't exist, tries to create it via the root container's onMissingRole.\n   * @param name The name of the role to activate\n   * @throws Error if the role is not found and cannot be created\n   */\n  setCurrRole(name: string): void {\n    name = name.trim().toLowerCase();\n    if (name === \"\") {\n      throw new Error(\"Role name cannot be empty\");\n    }\n    let roleDef = this.getRole(name);\n    // If role not found, try auto-creation\n    if (roleDef == null) {\n      // Create the role locally in this block\n      // Default: \"sw\" is notes-only, others are not\n      roleDef = this.newRoleDef(name, name === \"sw\");\n    }\n    this._currRoleDef = roleDef;\n  }\n\n  /**\n   * Gets the current line, creating one if needed.\n   */\n  get currentLine(): Line {\n    if (this._currentLine === null) {\n      return this.newLine();\n    }\n    return this._currentLine;\n  }\n\n  /**\n   * Creates a new line in this block.\n   */\n  newLine(): Line {\n    if (this._currentLine !== null && this._currentLine.isEmpty) {\n      // Remove empty line before creating new one\n      this.removeBlockItem(this._currentLine);\n    }\n    this._currentLine = new Line();\n    this.addBlockItem(this._currentLine);\n    return this._currentLine;\n  }\n\n  /**\n   * Resets the current line pointer to null.\n   * Called when layout parameters change to force a new line.\n   */\n  resetLine(): void {\n    this._currentLine = null;\n  }\n\n  /**\n   * Creates a new role definition local to this block.\n   * @param name The name of the role\n   * @param notesOnly Whether this role contains only notes\n   */\n  newRoleDef(name: string, notesOnly = false): RoleDef {\n    name = name.trim().toLowerCase();\n    if (name === \"\") {\n      throw new Error(\"Role name cannot be empty\");\n    }\n    if (this.localRoles.has(name)) {\n      throw new Error(`Role '${name}' already exists in this block`);\n    }\n    const rd = new RoleDef();\n    rd.name = name;\n    rd.notesOnly = notesOnly;\n    rd.index = this.localRoles.size;\n    this.localRoles.set(name, rd);\n    return rd;\n  }\n\n  // ============================================\n  // Child management\n  // ============================================\n\n  /**\n   * Adds a child item to this block.\n   * @param item The item to add\n   */\n  addBlockItem(item: BlockItem): void {\n    const index = this.blockItems.length;\n    item.setParent(this);\n    this.blockItems.push(item);\n\n    // Notify observers of added item\n    if (this._eventsEnabled) {\n      for (const observer of this._observers) {\n        observer.onItemAdded?.(this, item, index);\n      }\n    }\n  }\n\n  /**\n   * Removes a child item from this block.\n   * @param item The item to remove\n   * @returns The index of the removed item, or -1 if not found\n   */\n  removeBlockItem(item: BlockItem): number {\n    const index = this.blockItems.indexOf(item);\n    if (index >= 0) {\n      this.blockItems.splice(index, 1);\n      item.setParent(null);\n\n      // Notify observers of removed item\n      if (this._eventsEnabled) {\n        for (const observer of this._observers) {\n          observer.onItemRemoved?.(this, item, index);\n        }\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Returns a debug-friendly representation of this block.\n   */\n  debugValue(): any {\n    const out: any = {\n      ...super.debugValue(),\n      blockType: this.blockType,\n      blockItems: this.blockItems.map((c) => c.debugValue()),\n    };\n    if (this.name) {\n      out.name = this.name;\n    }\n    if (this.localCycle) {\n      out.localCycle = this.localCycle.uuid;\n    }\n    if (this.localAtomsPerBeat !== null) {\n      out.localAtomsPerBeat = this.localAtomsPerBeat;\n    }\n    if (this.localBreaks !== null) {\n      out.localBreaks = this.localBreaks;\n    }\n    if (this.localRoles.size > 0) {\n      out.localRoles = Array.from(this.localRoles.keys());\n    }\n    return out;\n  }\n}\n\n/**\n * Helper function to find the containing block of an entity by walking up the tree.\n * @param entity The entity to start from\n * @returns The containing Block, or null if not found\n */\nexport function findContainingBlock(entity: Entity): TSU.Nullable<Block> {\n  let current: TSU.Nullable<Entity> = entity.parent;\n  while (current !== null) {\n    if (current instanceof Block) {\n      return current;\n    }\n    current = current.parent;\n  }\n  return null;\n}\n\n// ============================================\n// Block Subclasses\n// ============================================\n\n/**\n * A section block with a heading.\n * Expands children to include a heading RawBlock followed by the content.\n *\n * Usage: \\section(\"Pallavi\") { ... }\n */\nexport class SectionBlock extends Block {\n  constructor(sectionName: string, parent: TSU.Nullable<Block> = null) {\n    super(\"section\", parent, sectionName);\n  }\n\n  /**\n   * Expands children to include a heading RawBlock.\n   */\n  children(): BlockItem[] {\n    const heading = new RawBlock(`# ${this.name}`, \"md\");\n    return [heading, ...this.blockItems];\n  }\n}\n\n/**\n * A repeat block that expands its children N times.\n *\n * Usage: \\repeat(2) { ... }\n */\nexport class RepeatBlock extends Block {\n  /** Number of times to repeat (0 = visual markers only) */\n  readonly repeatCount: number;\n\n  constructor(repeatCount: number, parent: TSU.Nullable<Block> = null) {\n    super(\"repeat\", parent);\n    this.repeatCount = repeatCount;\n  }\n\n  /**\n   * Expands children by repeating them N times.\n   * If count is 0, returns children as-is (visual repeat markers only).\n   */\n  children(): BlockItem[] {\n    if (this.repeatCount <= 0) {\n      return this.blockItems;\n    }\n    const expanded: BlockItem[] = [];\n    for (let i = 0; i < this.repeatCount; i++) {\n      expanded.push(...this.blockItems);\n    }\n    return expanded;\n  }\n}\n\n/**\n * A cycle block that sets localCycle for scoped notation.\n *\n * Usage: \\cycle(\"|4|4|\") { ... }\n */\nexport class CycleBlock extends Block {\n  constructor(cycle: Cycle, parent: TSU.Nullable<Block> = null) {\n    super(\"cycle\", parent);\n    this.localCycle = cycle;\n  }\n}\n\n/**\n * A beat duration block that sets localAtomsPerBeat for scoped notation.\n *\n * Usage: \\beatDuration(2) { ... }\n */\nexport class BeatDurationBlock extends Block {\n  constructor(atomsPerBeat: number, parent: TSU.Nullable<Block> = null) {\n    super(\"beatduration\", parent);\n    this.localAtomsPerBeat = atomsPerBeat;\n  }\n}\n\n/**\n * A breaks block that sets localBreaks for scoped notation.\n *\n * Usage: \\breaks(4, 2, 2) { ... }\n */\nexport class BreaksBlock extends Block {\n  constructor(breaks: number[], parent: TSU.Nullable<Block> = null) {\n    super(\"breaks\", parent);\n    this.localBreaks = breaks;\n  }\n}\n\n/**\n * A role block that creates a local role definition.\n *\n * Usage: \\role(\"Vocals\", notes=false) { ... }\n */\nexport class RoleBlock extends Block {\n  constructor(roleName: string, notesOnly: boolean, parent: TSU.Nullable<Block> = null) {\n    super(\"role\", parent);\n    // Create the role locally\n    this.newRoleDef(roleName, notesOnly);\n  }\n}\n\n/**\n * A group block for organizing notation without special semantics.\n *\n * Usage: \\group(\"optional-name\") { ... }\n */\nexport class GroupBlock extends Block {\n  constructor(groupName: string | null, parent: TSU.Nullable<Block> = null) {\n    super(\"group\", parent, groupName);\n  }\n}\n"],"names":["GridCellEvent","GridModel","uuid","idCounter","lastUpdatedAt","rows","rowAligns","Map","colAligns","debugValue","this","map","r","firstRow","gr","numCells","rowIndex","firstCol","minCol","fc","cellsInRow","row","out","cell","cells","value","push","cellsInCol","col","cellAt","addRowAlign","align","set","addColAlign","addRows","insertBefore","numRows","length","next","prev","i","newRow","GridRow","splice","defaultRowAlign","addSuccessor","getRow","setValue","cellCreator","grow","GridCell","clearCellAt","eventHub","emit","CLEARED","loc","location","oldValue","UPDATED","eventHubChanged","console","log","constructor","gridRow","colIndex","rowAlign","_rowAlign","val","addCell","colAlign","_colAlign","grid","c","y","coordOffset","h","maxLength","x","w","RowAlign","numCols","creator","filter","AlignedLine","needsLayout","_coordOffset","_maxLength","paddingBefore","paddingAfter","prevLines","nextLines","setMaxLength","setPadding","before","after","beforeAddingCell","removeCell","beforeRemovingCell","ColAlign","setOffset","cellView","getCellView","evalMaxLength","setBounds","changedCells","Math","max","minSize","width","height","GridLayoutGroup","gridModels","layoutChangeSubscribers","Set","previousColumnWidths","previousRowHeights","eventHandler","event","applyModelEvents","payload","onLayoutChange","callback","add","delete","notifyLayoutChange","e","error","subscriberCount","size","addGridModel","gridModel","on","BATCH_EVENTS","startingRowAligns","visited","gm","startingColAligns","removeGridModel","removeOn","startingRows","startingCols","refreshLayout","notify","changedRowAligns","changedColAligns","rowHeightsChanged","doBfsLayout","columnWidthsChanged","affectedRowRange","affectedColRange","affectedGridModels","events","changesForEvents","hadRowChanges","Object","keys","hadColChanges","calculateAffectedRowRange","calculateAffectedColRange","minRow","Infinity","maxRow","alignId","min","start","end","maxCol","checkAndUpdateLength","previousMap","previous","get","current","undefined","cellVisited","affectedGridModelsSet","split","parseInt","source","Array","from","ensureGetCellView","startingLines","changedAligns","previousLengths","anyDimensionChanged","lineQueue","visitedLines","line","lineOffsetChanged","nextQueue","prevLineAlign","lineAlign","newOffset","lineChanged","RoleDef","name","notesOnly","index","RawBlock","content","contentType","super","TYPE","isBlock","item","isLine","isRawBlock","Block","blockType","parent","blockItems","localCycle","localAtomsPerBeat","localBreaks","localRoles","_parentBlock","_currRoleDef","_currentLine","_observers","_unnamedLayoutParams","_namedLayoutParams","_layoutParams","setParent","addObserver","observer","removeObserver","indexOf","children","parentBlock","cycle","atomsPerBeat","breaks","unnamedLayoutParams","namedLayoutParams","layoutParams","findUnnamedLayoutParams","snapshotLayoutParams","resetLayoutParams","resetLine","effectiveCycle","Error","beatDuration","layout","find","lp","equals","lineBreaksEqual","ensureNamedLayoutParams","lineBreaks","getRole","toLowerCase","currRoleDef","roles","values","setCurrRole","trim","roleDef","newRoleDef","currentLine","newLine","isEmpty","removeBlockItem","addBlockItem","has","rd","_eventsEnabled","onItemAdded","onItemRemoved","findContainingBlock","entity","SectionBlock","sectionName","RepeatBlock","repeatCount","expanded","CycleBlock","BeatDurationBlock","BreaksBlock","RoleBlock","roleName","GroupBlock","groupName"],"ignoreList":[],"sourceRoot":""}